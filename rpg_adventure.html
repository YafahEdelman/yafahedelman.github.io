<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Station Alpha - Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f0b1e;
            color: #fff;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
            top: 50vh;
            transform: translateY(-50%);
            box-shadow: 0 0 50px rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            overflow: hidden;
            background: #1a1625;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(15, 11, 30, 0.9);
            border: 2px solid #a78bfa;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            display: none;
            pointer-events: auto;
        }
        .dialogue-text {
            font-size: 16px;
            line-height: 1.5;
            color: #e5e7eb;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        .battery-icon {
            width: 20px;
            height: 30px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            position: relative;
        }
        .battery-icon.filled {
            background: #4ade80;
            border-color: #22c55e;
            box-shadow: 0 0 10px #4ade80;
        }
        .battery-icon::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 4px;
            width: 8px;
            height: 4px;
            background: inherit;
            border-radius: 2px 2px 0 0;
        }
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            gap: 10px;
            pointer-events: auto;
        }
        @media (max-width: 850px) {
            #game-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
                top: 0;
                transform: none;
            }
            #mobile-controls {
                display: grid;
                grid-template-columns: 60px 60px 60px;
                grid-template-rows: 60px 60px;
            }
            .dpad-btn {
                background: rgba(255,255,255,0.1);
                border: 1px solid rgba(255,255,255,0.3);
                border-radius: 50%;
                color: white;
                font-size: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                user-select: none;
            }
            .dpad-btn:active {
                background: rgba(255,255,255,0.3);
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="ui-layer">
        <div class="hud" id="hud-batteries">
            <!-- Batteries will be injected here -->
            <div class="battery-icon"></div>
            <div class="battery-icon"></div>
            <div class="battery-icon"></div>
        </div>

        <div class="dialogue-box" id="dialogue-box">
            <div class="dialogue-text" id="dialogue-text"></div>
            <div class="text-xs text-gray-400 mt-2 text-right">Press SPACE or TAP to continue</div>
        </div>

        <div id="mobile-controls">
            <div></div>
            <div class="dpad-btn" id="btn-up">↑</div>
            <div></div>
            <div class="dpad-btn" id="btn-left">←</div>
            <div class="dpad-btn" id="btn-down">↓</div>
            <div class="dpad-btn" id="btn-right">→</div>
        </div>
    </div>
</div>

<script>
/**
 * Cute Sci-Fi RPG: RoboQuest
 * A simple JS-only engine.
 */

// --- Constants & Config ---
const TILE_SIZE = 40;
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;

// --- Assets / Drawing Helpers ---
const drawRobot = (ctx, x, y, frame) => {
    // Bobbing animation
    const bob = Math.sin(frame * 0.1) * 3;

    // Body
    ctx.fillStyle = '#a78bfa'; // Light purple
    ctx.beginPath();
    ctx.arc(x, y + bob, 15, 0, Math.PI * 2);
    ctx.fill();

    // Screen/Face
    ctx.fillStyle = '#1e1b4b'; // Dark blue
    ctx.beginPath();
    ctx.roundRect(x - 10, y - 5 + bob, 20, 12, 4);
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#38bdf8'; // Cyan
    // Left eye
    ctx.fillRect(x - 6, y - 2 + bob, 4, 4);
    // Right eye
    ctx.fillRect(x + 2, y - 2 + bob, 4, 4);

    // Antenna
    ctx.strokeStyle = '#a78bfa';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y - 15 + bob);
    ctx.lineTo(x, y - 25 + bob);
    ctx.stroke();

    // Antenna ball
    ctx.fillStyle = '#f472b6'; // Pink
    ctx.beginPath();
    ctx.arc(x, y - 25 + bob, 3, 0, Math.PI * 2);
    ctx.fill();

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + 20, 10 + (bob*0.5), 4, 0, 0, Math.PI * 2);
    ctx.fill();
};

const drawBattery = (ctx, x, y, frame) => {
    const float = Math.sin(frame * 0.05) * 5;

    ctx.save();
    ctx.translate(x, y + float);

    // Glow
    ctx.shadowColor = '#4ade80';
    ctx.shadowBlur = 15;

    // Battery Body
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(-8, -12, 16, 24);

    // Cap
    ctx.fillStyle = '#86efac';
    ctx.fillRect(-4, -16, 8, 4);

    // Bolt symbol
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(-2, -6);
    ctx.lineTo(4, -1);
    ctx.lineTo(0, 1);
    ctx.lineTo(2, 6);
    ctx.lineTo(-4, 1);
    ctx.lineTo(0, -1);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
};

const drawTile = (ctx, x, y, type) => {
    if (type === 1) { // Wall
        ctx.fillStyle = '#312e81'; // Indigo 900
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        // Bevel
        ctx.fillStyle = '#4338ca';
        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);

        // Detail
        ctx.fillStyle = '#312e81';
        ctx.fillRect(x + 10, y + 10, TILE_SIZE - 20, TILE_SIZE - 20);
    } else if (type === 2) { // Floor
        ctx.strokeStyle = '#2e2b3b';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

        // Center dot
        ctx.fillStyle = '#2e2b3b';
        ctx.fillRect(x + TILE_SIZE/2 - 1, y + TILE_SIZE/2 - 1, 2, 2);
    } else if (type === 3) { // Door
        ctx.fillStyle = '#be123c';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = '#fda4af';
        for(let i=0; i<4; i++) {
             ctx.fillRect(x, y + i*10 + 2, TILE_SIZE, 2);
        }
    } else if (type === 4) { // Open Door
        ctx.fillStyle = '#064e3b';
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    } else if (type === 5) { // Terminal
        // Screen base
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(x + 5, y + 10, TILE_SIZE - 10, TILE_SIZE - 15);

        // Screen glass
        ctx.fillStyle = '#0ea5e9'; // Sky blue
        ctx.fillRect(x + 8, y + 13, TILE_SIZE - 16, TILE_SIZE - 24);

        // Animated text lines
        ctx.fillStyle = '#e0f2fe';
        if (Math.random() > 0.5) {
             ctx.fillRect(x + 10, y + 16, 15, 2);
             ctx.fillRect(x + 10, y + 20, 10, 2);
        } else {
             ctx.fillRect(x + 10, y + 16, 12, 2);
             ctx.fillRect(x + 10, y + 20, 18, 2);
        }
    }
};

// --- Game Engine ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.keys = {};
        this.frameCount = 0;
        this.lastInputTime = 0;

        this.player = {
            x: 3 * TILE_SIZE + TILE_SIZE/2,
            y: 2 * TILE_SIZE + TILE_SIZE/2,
            speed: 3,
            vx: 0,
            vy: 0,
            width: 30,
            height: 30
        };

        // 0: Void, 1: Wall, 2: Floor, 3: Door (Closed), 4: Door (Open), 5: Terminal
        // 20x15 grid (800x600 / 40)
        this.map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,2,5,2,1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,2,2,2,1,2,2,2,1,1,1,1,2,1,2,2,2,2,2,1],
            [1,2,2,2,2,2,2,2,1,0,0,1,2,1,2,2,2,2,2,1],
            [1,1,1,3,1,1,1,1,1,0,0,1,2,2,2,2,2,2,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,2,1,1,1],
            [1,2,1,1,1,1,2,1,1,1,2,1,2,2,2,1,2,2,2,1],
            [1,2,1,0,0,1,2,2,2,1,2,1,2,2,2,1,1,1,2,1],
            [1,2,1,0,0,1,1,1,2,1,2,1,2,2,2,2,2,2,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,1,1,1,1,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];

        // Map text for terminals (row, col) key
        this.terminalLogs = {
            "2,2": "LOG 492: The reactor leak is worse than predicted. Evacuation protocol initiated. If any maintenance bots are reading this... good luck.",
            "12,13": "LOG 501: Coordinates set for Sector 7. The portal is unstable, but it's our only way out. We're leaving the power cells behind for the next shift."
        };

        this.items = [
            { x: 8 * TILE_SIZE + 20, y: 2 * TILE_SIZE + 20, collected: false },
            { x: 18 * TILE_SIZE + 20, y: 13 * TILE_SIZE + 20, collected: false },
            { x: 3 * TILE_SIZE + 20, y: 12 * TILE_SIZE + 20, collected: false }
        ];

        this.dialogueQueue = [];
        this.isDialogueOpen = false;
        this.batteriesCollected = 0;
        this.doorOpen = false;
        this.nearTerminal = null; // Store position of nearby terminal

        this.init();
    }

    init() {
        this.setupInputs();
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.queueDialogue("B-0p: Reboot sequence complete. Memory banks... corrupted.");
        this.queueDialogue("Diagnostic: Station deserted. Life support offline.");
        this.queueDialogue("Objective: Locate 3 Energy Cells to restore power to the portal. I must follow them.");

        requestAnimationFrame(() => this.loop());
    }

    setupInputs() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            if (this.isDialogueOpen && (e.key === ' ' || e.key === 'Enter')) {
                // Debounce slightly to prevent accidental skipping
                if (Date.now() - this.lastInputTime > 200) {
                     this.advanceDialogue();
                     this.lastInputTime = Date.now();
                }
            } else if (!this.isDialogueOpen && (e.key === ' ' || e.key === 'Enter')) {
                // Interact
                this.checkInteraction();
            }
        });
        window.addEventListener('keyup', (e) => this.keys[e.key] = false);

        // Mobile Controls
        const handleTouch = (id, active) => {
            const map = {
                'btn-up': 'ArrowUp',
                'btn-down': 'ArrowDown',
                'btn-left': 'ArrowLeft',
                'btn-right': 'ArrowRight'
            };
            if (map[id]) this.keys[map[id]] = active;
        };

        ['touchstart', 'touchend'].forEach(evt => {
            document.querySelectorAll('.dpad-btn').forEach(btn => {
                btn.addEventListener(evt, (e) => {
                    e.preventDefault();
                    handleTouch(btn.id, evt === 'touchstart');
                });
            });
        });

        // Tap to advance dialogue or interact
        document.getElementById('dialogue-box').addEventListener('click', () => {
             if (this.isDialogueOpen) this.advanceDialogue();
        });

        // Add an interact button for mobile? Or just tap screen?
        // For now let's just use tap on canvas for interaction if not moving?
        // Simplest is making the dpad usable or adding a specific button,
        // but for now let's assume keyboard for interaction or tapping the dialogue box when it appears.
    }

    resize() {
        // Keeps aspect ratio if possible or just fits
    }

    checkInteraction() {
        if (this.nearTerminal) {
            const key = `${this.nearTerminal.row},${this.nearTerminal.col}`;
            if (this.terminalLogs[key]) {
                this.queueDialogue(this.terminalLogs[key]);
            }
        }
    }

    queueDialogue(text) {
        this.dialogueQueue.push(text);
        if (!this.isDialogueOpen) {
            this.showNextDialogue();
        }
    }

    showNextDialogue() {
        if (this.dialogueQueue.length > 0) {
            const text = this.dialogueQueue.shift();
            const box = document.getElementById('dialogue-box');
            const content = document.getElementById('dialogue-text');
            content.innerText = text;
            box.style.display = 'block';
            this.isDialogueOpen = true;
            this.lastInputTime = Date.now();
        } else {
            document.getElementById('dialogue-box').style.display = 'none';
            this.isDialogueOpen = false;
        }
    }

    advanceDialogue() {
        this.showNextDialogue();
    }

    update() {
        if (this.isDialogueOpen) return;

        // Movement
        this.player.vx = 0;
        this.player.vy = 0;

        if (this.keys['ArrowUp'] || this.keys['w']) this.player.vy = -this.player.speed;
        if (this.keys['ArrowDown'] || this.keys['s']) this.player.vy = this.player.speed;
        if (this.keys['ArrowLeft'] || this.keys['a']) this.player.vx = -this.player.speed;
        if (this.keys['ArrowRight'] || this.keys['d']) this.player.vx = this.player.speed;

        // Collision Check (Simple box vs Tile)
        const nextX = this.player.x + this.player.vx;
        const nextY = this.player.y + this.player.vy;

        if (!this.checkCollision(nextX, this.player.y)) {
            this.player.x = nextX;
        }
        if (!this.checkCollision(this.player.x, nextY)) {
            this.player.y = nextY;
        }

        // Check for nearby interaction points
        this.checkProximity();

        // Item Collection
        this.items.forEach(item => {
            if (!item.collected) {
                const dx = this.player.x - item.x;
                const dy = this.player.y - item.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 20) {
                    item.collected = true;
                    this.batteriesCollected++;
                    this.updateHUD();
                    if (this.batteriesCollected === 3) {
                        this.queueDialogue("System: POWER RESTORED. Portal logic active.");
                        this.openDoor();
                    }
                }
            }
        });

        // Door interaction
        if (this.doorOpen) {
            // Check if player enters door (Tile 3 now 4)
             const col = Math.floor(this.player.x / TILE_SIZE);
             const row = Math.floor(this.player.y / TILE_SIZE);
             if (this.map[row][col] === 4) {
                 this.queueDialogue("B-0p: Entering portal... Destination: Sector 7.");
                 this.queueDialogue("TO BE CONTINUED...");
                 // Reset for fun
                 this.player.x = 3.5 * TILE_SIZE;
                 this.player.y = 2.5 * TILE_SIZE;
                 this.doorOpen = false;
                 this.items.forEach(i => i.collected = false);
                 this.batteriesCollected = 0;
                 this.updateHUD();
                 this.map[5][3] = 3; // Close door
             }
        }
    }

    checkProximity() {
        // Check grid cells around player
        const col = Math.floor(this.player.x / TILE_SIZE);
        const row = Math.floor(this.player.y / TILE_SIZE);

        // Check neighbors
        const neighbors = [
            {r: row, c: col},
            {r: row-1, c: col},
            {r: row+1, c: col},
            {r: row, c: col-1},
            {r: row, c: col+1},
        ];

        this.nearTerminal = null;
        for (let n of neighbors) {
            if (n.r >= 0 && n.r < this.map.length && n.c >= 0 && n.c < this.map[0].length) {
                if (this.map[n.r][n.c] === 5) {
                    this.nearTerminal = {row: n.r, col: n.c};
                    break;
                }
            }
        }
    }

    openDoor() {
        this.doorOpen = true;
        // Find door in map
        for(let r=0; r<this.map.length; r++){
            for(let c=0; c<this.map[0].length; c++){
                if(this.map[r][c] === 3) this.map[r][c] = 4;
            }
        }
    }

    checkCollision(x, y) {
        // Radius check against tile map
        const radius = 10;
        const corners = [
            {x: x - radius, y: y - radius},
            {x: x + radius, y: y - radius},
            {x: x - radius, y: y + radius},
            {x: x + radius, y: y + radius}
        ];

        for (let p of corners) {
            const col = Math.floor(p.x / TILE_SIZE);
            const row = Math.floor(p.y / TILE_SIZE);

            // Bounds check
            if (row < 0 || row >= this.map.length || col < 0 || col >= this.map[0].length) return true;

            const tile = this.map[row][col];
            if (tile === 1 || tile === 0 || tile === 3 || tile === 5) return true; // Solid tiles
        }
        return false;
    }

    updateHUD() {
        const icons = document.querySelectorAll('.battery-icon');
        icons.forEach((icon, idx) => {
            if (idx < this.batteriesCollected) {
                icon.classList.add('filled');
            } else {
                icon.classList.remove('filled');
            }
        });
    }

    draw() {
        // Clear
        this.ctx.fillStyle = '#1a1625';
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Map
        for (let row = 0; row < this.map.length; row++) {
            for (let col = 0; col < this.map[0].length; col++) {
                const tile = this.map[row][col];
                if (tile !== 0) {
                    drawTile(this.ctx, col * TILE_SIZE, row * TILE_SIZE, tile);
                }
            }
        }

        // Draw interaction hint if near terminal
        if (this.nearTerminal && !this.isDialogueOpen) {
            const tX = this.nearTerminal.col * TILE_SIZE + TILE_SIZE/2;
            const tY = this.nearTerminal.row * TILE_SIZE;

            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px Inter';
            this.ctx.textAlign = 'center';
            this.ctx.fillText("SPACE", tX, tY - 5);
        }

        // Draw Items
        this.items.forEach(item => {
            if (!item.collected) {
                drawBattery(this.ctx, item.x, item.y, this.frameCount);
            }
        });

        // Draw Player
        drawRobot(this.ctx, this.player.x, this.player.y, this.frameCount);
    }

    loop() {
        this.frameCount++;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// Start Game
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
