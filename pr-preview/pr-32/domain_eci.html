<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Domain-ECI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #d1d5db;
        }

        .filter-transition {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            /* Hides the slider so that custom slider can be made */
            width: 100%;
            background: transparent;
            /* Otherwise white in Chrome */
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -6px;
            /* You need to specify a margin in Chrome, but in Firefox and IE it is automatic */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 2px solid white;
            position: relative;
            z-index: 10;
        }

        input[type=range]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 2px solid white;
            position: relative;
            z-index: 10;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 999px;
        }

        input[type=range]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 999px;
        }

        input[type=range]:focus {
            outline: none;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900 h-dvh flex flex-col">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 px-4 lg:px-6 py-4 flex justify-between items-center shadow-sm z-10 relative">
        <div class="flex items-center gap-3">
            <button id="mobile-menu-btn" class="lg:hidden p-2 -ml-2 text-gray-600 hover:bg-gray-100 rounded-md">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
            <div>
                <h1 class="text-lg lg:text-xl font-bold text-gray-800">Domain-ECI Explorer</h1>
                <p class="hidden lg:block text-sm text-gray-500">Select benchmarks to estimate capability over time</p>
            </div>
        </div>

        <!-- Desktop Controls -->
        <div class="hidden lg:flex items-center gap-4">
            <div class="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                <button id="view-chart"
                    class="px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200">
                    Chart
                </button>
                <button id="view-table"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Table
                </button>
            </div>
            <div class="w-px h-8 bg-gray-200"></div>
            <div class="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                <button id="mode-fixed"
                    class="px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200">
                    Fixed Parameters
                </button>
                <button id="mode-refit"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Refit (JMLE)
                </button>
                <button id="mode-compare"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Compare
                </button>
                <button id="mode-rank-compare"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Rank Comparison
                </button>
            </div>
            <label
                class="flex items-center gap-2 cursor-pointer select-none bg-gray-50 px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm hover:bg-gray-100 transition-colors">
                <input type="checkbox" id="show-breakpoint-toggle"
                    class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="text-sm font-medium text-gray-700">Frontier Breakpoint</span>
            </label>
            <label
                class="flex items-center gap-2 cursor-pointer select-none bg-gray-50 px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm hover:bg-gray-100 transition-colors">
                <input type="checkbox" id="show-ci-toggle"
                    class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="text-sm font-medium text-gray-700">Show 90% CI</span>
            </label>
            <label
                class="flex items-center gap-2 cursor-pointer select-none bg-gray-50 px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm hover:bg-gray-100 transition-colors">
                <input type="checkbox" id="std-scale-toggle"
                    class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="text-sm font-medium text-gray-700">Std Scale Refit</span>
            </label>
            <button id="share-btn"
                class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path></svg>
                Share
            </button>
            <button id="download-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                Export Data
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden relative">

        <!-- Mobile Overlay -->
        <div id="sidebar-overlay" class="absolute inset-0 bg-gray-900/50 z-20 hidden lg:hidden backdrop-blur-sm transition-opacity opacity-0"></div>

        <!-- Sidebar: Search & Filter -->
        <aside id="sidebar"
            class="fixed inset-y-0 left-0 w-80 bg-white border-r border-gray-200 flex flex-col z-30 transition-transform duration-300 transform -translate-x-full lg:relative lg:translate-x-0 shadow-[4px_0_24px_-12px_rgba(0,0,0,0.1)] lg:shadow-none">

            <!-- Mobile Close Button (Fixed at Top) -->
            <div class="lg:hidden flex-none border-b border-gray-100 px-5 py-4 flex justify-between items-center bg-white z-20">
                <h2 class="font-bold text-gray-800">Settings</h2>
                <button id="sidebar-close-btn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- Scrollable Content Container -->
            <div class="flex-1 overflow-y-auto lg:overflow-hidden lg:flex lg:flex-col">

                <!-- Mobile Controls (Scrollable) -->
                <div class="lg:hidden p-4 space-y-4 border-b border-gray-200 bg-gray-50">
                     <div class="flex flex-col space-y-1 bg-white p-1 rounded-lg border border-gray-200">
                        <button id="mobile-view-chart" class="px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900">Chart</button>
                        <button id="mobile-view-table" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Table</button>
                     </div>

                     <div class="flex flex-col space-y-1 bg-white p-1 rounded-lg border border-gray-200">
                        <button id="mobile-mode-fixed" class="px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900">Fixed Parameters</button>
                        <button id="mobile-mode-refit" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Refit (JMLE)</button>
                        <button id="mobile-mode-compare" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Compare</button>
                        <button id="mobile-mode-rank-compare" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Rank Comparison</button>
                      </div>

                      <div class="flex items-center justify-between">
                          <span class="text-sm font-medium text-gray-700">Frontier Breakpoint</span>
                          <input type="checkbox" id="mobile-show-breakpoint-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                     </div>

                     <div class="flex items-center justify-between">
                         <span class="text-sm font-medium text-gray-700">Show 90% CI</span>
                         <input type="checkbox" id="mobile-show-ci-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                     </div>

                     <div class="flex items-center justify-between">
                         <span class="text-sm font-medium text-gray-700">Std Scale Refit</span>
                         <input type="checkbox" id="mobile-std-scale-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                     </div>

                     <button id="mobile-share-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors flex items-center justify-center gap-2 mb-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path></svg>
                        Share
                     </button>
                     <button id="mobile-download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                        Export Data
                     </button>
                </div>

                <!-- Filters (Static on Desktop, Scrollable on Mobile) -->
                <div class="flex-none">
                    <div class="px-5 py-4 border-b border-gray-100 flex justify-between items-center bg-gray-50/30">
                        <h2 class="font-black text-gray-800 tracking-tight text-base">Filters</h2>
                        <span id="benchmark-count" class="bg-indigo-50 text-indigo-600 text-[10px] font-bold px-2 py-0.5 rounded-full ring-1 ring-indigo-100/50">0/0</span>
                    </div>

                    <!-- Min Scores Selector -->
                    <div class="px-5 py-3 border-b border-gray-100 bg-gray-50/30">
                        <div class="flex justify-between items-center mb-2">
                            <label for="min-benchmarks" class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Min Scores</label>
                            <span id="min-benchmarks-val" class="text-[10px] font-bold text-indigo-600 bg-white px-2 py-0.5 rounded shadow-sm ring-1 ring-gray-100">2</span>
                        </div>
                        <div class="relative w-full h-6 flex items-center">
                            <!-- Custom Ticks (Dots) on Track -->
                            <div class="absolute w-full h-1 top-1/2 -translate-y-1/2 pointer-events-none px-[8px]">
                                <div class="absolute left-[0%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[6.66%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[20%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[46.66%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[100%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                            </div>
                            <input type="range" id="min-benchmarks" min="1" max="16" value="2" step="1" class="w-full relative z-20 bg-transparent">
                        </div>
                        <div class="relative w-full h-2 mt-1 px-[8px] pointer-events-none">
                            <div class="absolute left-[0%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[6.66%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[20%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[46.66%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[100%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                        </div>
                    </div>

                    <!-- Domain Selection Dropdown -->
                    <div class="px-5 py-3 border-b border-gray-100">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Category</h3>
                            <button id="clear-domains" class="text-[10px] text-indigo-600 font-bold hover:text-indigo-700 transition-colors hidden">CLEAR</button>
                        </div>
                        <div class="relative">
                            <select id="domain-selector" class="w-full pl-3 pr-10 py-2 bg-gray-50 border border-gray-200 rounded-lg text-xs font-medium appearance-none focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all cursor-pointer">
                                <!-- Options will be injected here -->
                            </select>
                            <div class="absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none text-gray-400">
                                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path d="M19 9l-7 7-7-7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- Search Section -->
                    <div class="px-5 py-3 border-b border-gray-100">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Search Benchmarks</h3>
                        </div>
                        <div class="relative group">
                            <span class="absolute inset-y-0 left-0 pl-3 flex items-center text-gray-400 group-focus-within:text-indigo-500 transition-colors">
                                <svg class="h-3.5 w-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </span>
                            <input type="text" id="search-benchmarks" placeholder="Find benchmarks..." class="w-full pl-9 pr-3 py-2 bg-gray-100 border border-gray-200 rounded-lg text-xs font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 focus:bg-white transition-all">
                        </div>
                    </div>

                    <!-- Active Labels/Filters Area -->
                    <div id="active-filters-container" class="px-5 py-3 border-b border-gray-100 hidden bg-indigo-50/10">
                        <h3 class="text-[10px] font-bold text-indigo-400 uppercase tracking-wider mb-2 font-black">Selection</h3>
                        <div class="flex flex-wrap gap-1.5 max-h-32 overflow-y-auto custom-scrollbar" id="active-filters">
                            <!-- Filter tags will be injected here -->
                        </div>
                    </div>

                    <div class="px-5 py-3 border-b border-gray-100 bg-gray-50/50 flex justify-between items-center sticky top-0 backdrop-blur-sm z-10">
                        <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Benchmarks</h2>
                        <div class="flex gap-2">
                            <button id="select-all" class="text-indigo-600 text-[10px] font-bold hover:text-indigo-800 transition-colors tracking-tight">ALL</button>
                            <span class="text-gray-300 text-[10px]">|</span>
                            <button id="deselect-all" class="text-gray-400 text-[10px] font-bold hover:text-gray-600 transition-colors tracking-tight">NONE</button>
                        </div>
                    </div>
                </div>

                <!-- Benchmark List (Scrollable on Desktop independently) -->
                <div class="lg:flex-1 lg:overflow-y-auto px-5 py-2 space-y-1 bg-white custom-scrollbar pb-8" id="benchmark-list">
                    <!-- Benchmarks list will be injected here -->
                </div>
            </div>
        </aside>

        <!-- Visualization Area -->
        <main class="flex-1 flex flex-col bg-white overflow-hidden relative">
            <div id="loading-overlay"
                class="absolute inset-0 bg-white/80 z-50 flex items-center justify-center hidden backdrop-blur-sm">
                <div class="flex flex-col items-center">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-3"></div>
                    <span class="text-gray-600 font-medium">Refitting Model...</span>
                </div>
            </div>

            <div class="flex-1 flex flex-col relative overflow-hidden" id="chart-wrapper">
                <!-- Custom Mobile Legend -->
                <div id="mobile-chart-legend" class="lg:hidden w-full overflow-x-auto whitespace-nowrap py-2 px-4 border-b border-gray-100 flex gap-3 min-h-[40px] scrollbar-hide"></div>

                <!-- Plotly Chart -->
                <div class="flex-1 p-2 lg:p-6 relative min-h-0">
                    <div id="chart-container" class="w-full h-full"></div>
                </div>
            <div id="breakpoint-stats" class="w-full bg-white border-t border-gray-200 p-2 lg:p-4 text-xs hidden z-10 shadow-[0_-4px_12px_rgba(0,0,0,0.05)]">
                    <h3 id="stats-title" class="font-bold text-gray-800 mb-2 border-b pb-1 inline-block mr-4">Frontier Breakpoint Analysis</h3>
                    <div id="breakpoint-content" class="text-gray-600 inline-block"></div>
                </div>
            </div>
            <div class="flex-1 px-2 lg:px-6 pb-2 lg:pb-6 pt-0 hidden overflow-auto custom-scrollbar" id="table-container">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                    <thead class="bg-gray-50 sticky top-0 z-10">
                        <tr id="table-header">
                            <!-- Headers injected via JS -->
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="table-body">
                        <!-- Rows injected via JS -->
                    </tbody>
                </table>
            </div>
        <!-- Status Bar Removed -->
        <div id="status-text" class="hidden"></div>
        </main>
    </div>

    <!-- Data Injection -->
    <script>
        const RAW_DATA = { "models": { "Baichuan 2-7B": { "name": "Baichuan 2-7B", "date": "2023-09-20" }, "Baichuan1-7B": { "name": "Baichuan1-7B", "date": "2023-06-01" }, "Baichuan2-13B": { "name": "Baichuan2-13B", "date": "2023-09-06" }, "Cerebras-GPT-13B": { "name": "Cerebras-GPT-13B", "date": "2023-03-20" }, "Claude 2": { "name": "Claude 2", "date": "2023-07-11" }, "Claude 2.1": { "name": "Claude 2.1", "date": "2023-11-21" }, "Claude 3 Haiku": { "name": "Claude 3 Haiku", "date": "2024-03-07" }, "Claude 3 Opus": { "name": "Claude 3 Opus", "date": "2024-02-29" }, "Claude 3 Sonnet": { "name": "Claude 3 Sonnet", "date": "2024-02-29" }, "Claude 3.5 Haiku": { "name": "Claude 3.5 Haiku", "date": "2024-10-22" }, "Claude 3.5 Sonnet": { "name": "Claude 3.5 Sonnet", "date": "2024-06-20" }, "Claude 3.5 Sonnet (October 2024)": { "name": "Claude 3.5 Sonnet (October 2024)", "date": "2024-10-22" }, "Claude 3.7 Sonnet": { "name": "Claude 3.7 Sonnet", "date": "2025-02-24" }, "Claude Haiku 4.5": { "name": "Claude Haiku 4.5", "date": "2025-10-15" }, "Claude Instant": { "name": "Claude Instant", "date": "2023-08-09" }, "Claude Opus 4": { "name": "Claude Opus 4", "date": "2025-05-22" }, "Claude Opus 4.1": { "name": "Claude Opus 4.1", "date": "2025-08-05" }, "Claude Opus 4.5": { "name": "Claude Opus 4.5", "date": "2025-11-24" }, "Claude Sonnet 4": { "name": "Claude Sonnet 4", "date": "2025-05-22" }, "Claude Sonnet 4.5": { "name": "Claude Sonnet 4.5", "date": "2025-09-29" }, "DeepSeek Coder 1.3B": { "name": "DeepSeek Coder 1.3B", "date": "2023-11-02" }, "DeepSeek Coder 33B": { "name": "DeepSeek Coder 33B", "date": "2023-11-02" }, "DeepSeek Coder 6.7B": { "name": "DeepSeek Coder 6.7B", "date": "2023-11-02" }, "DeepSeek-R1": { "name": "DeepSeek-R1", "date": "2025-01-20" }, "DeepSeek-R1 (May 2025)": { "name": "DeepSeek-R1 (May 2025)", "date": "2025-05-28" }, "DeepSeek-V2 (MoE-236B)": { "name": "DeepSeek-V2 (MoE-236B)", "date": "2024-05-07" }, "DeepSeek-V3": { "name": "DeepSeek-V3", "date": "2024-12-26" }, "DeepSeek-V3.1": { "name": "DeepSeek-V3.1", "date": "2025-08-21" }, "DeepSeek-V3.2": { "name": "DeepSeek-V3.2", "date": "2025-12-01" }, "DeepSeek-V3.2-Exp": { "name": "DeepSeek-V3.2-Exp", "date": "2025-09-29" }, "Dolly 2.0-12b": { "name": "Dolly 2.0-12b", "date": "2023-04-11" }, "Falcon 2 11B": { "name": "Falcon 2 11B", "date": "2024-05-09" }, "Falcon-180B": { "name": "Falcon-180B", "date": "2023-09-06" }, "Falcon-40B": { "name": "Falcon-40B", "date": "2023-03-15" }, "Falcon-7B": { "name": "Falcon-7B", "date": "2023-04-24" }, "GPT-3.5 Turbo": { "name": "GPT-3.5 Turbo", "date": "2023-11-06" }, "GPT-4 (Jun 2023)": { "name": "GPT-4 (Jun 2023)", "date": "2023-06-13" }, "GPT-4 (Mar 2023)": { "name": "GPT-4 (Mar 2023)", "date": "2023-03-14" }, "GPT-4 Turbo (Apr 2024)": { "name": "GPT-4 Turbo (Apr 2024)", "date": "2024-04-09" }, "GPT-4.1": { "name": "GPT-4.1", "date": "2025-04-14" }, "GPT-4.1 mini": { "name": "GPT-4.1 mini", "date": "2025-04-14" }, "GPT-4.1 nano": { "name": "GPT-4.1 nano", "date": "2025-04-14" }, "GPT-4.5": { "name": "GPT-4.5", "date": "2025-02-27" }, "GPT-4o (Aug 2024)": { "name": "GPT-4o (Aug 2024)", "date": "2024-08-06" }, "GPT-4o (May 2024)": { "name": "GPT-4o (May 2024)", "date": "2024-05-13" }, "GPT-4o (Nov 2024)": { "name": "GPT-4o (Nov 2024)", "date": "2024-11-20" }, "GPT-4o mini": { "name": "GPT-4o mini", "date": "2024-07-18" }, "GPT-5": { "name": "GPT-5", "date": "2025-08-07" }, "GPT-5 Pro": { "name": "GPT-5 Pro", "date": "2025-10-07" }, "GPT-5 mini": { "name": "GPT-5 mini", "date": "2025-08-07" }, "GPT-5 nano": { "name": "GPT-5 nano", "date": "2025-08-07" }, "GPT-5.1": { "name": "GPT-5.1", "date": "2025-11-13" }, "GPT-5.2": { "name": "GPT-5.2", "date": "2025-12-11" }, "Gemini 1.0 Pro": { "name": "Gemini 1.0 Pro", "date": "2024-02-15" }, "Gemini 1.5 Flash (May 2024)": { "name": "Gemini 1.5 Flash (May 2024)", "date": "2024-05-23" }, "Gemini 1.5 Flash (Sep 2024)": { "name": "Gemini 1.5 Flash (Sep 2024)", "date": "2024-09-24" }, "Gemini 1.5 Pro": { "name": "Gemini 1.5 Pro", "date": "2024-09-24" }, "Gemini 2.0 Flash": { "name": "Gemini 2.0 Flash", "date": "2025-02-05" }, "Gemini 2.0 Flash Thinking (Jan 2025)": { "name": "Gemini 2.0 Flash Thinking (Jan 2025)", "date": "2025-01-21" }, "Gemini 2.0 Pro": { "name": "Gemini 2.0 Pro", "date": "2025-02-05" }, "Gemini 2.5 Flash (Apr 2025)": { "name": "Gemini 2.5 Flash (Apr 2025)", "date": "2025-04-17" }, "Gemini 2.5 Flash (Jun 2025)": { "name": "Gemini 2.5 Flash (Jun 2025)", "date": "2025-06-17" }, "Gemini 2.5 Flash (May 2025)": { "name": "Gemini 2.5 Flash (May 2025)", "date": "2025-05-20" }, "Gemini 2.5 Flash (Sep 2025)": { "name": "Gemini 2.5 Flash (Sep 2025)", "date": "2025-09-25" }, "Gemini 2.5 Pro (Jun 2025)": { "name": "Gemini 2.5 Pro (Jun 2025)", "date": "2025-06-17" }, "Gemini 2.5 Pro (Mar 2025)": { "name": "Gemini 2.5 Pro (Mar 2025)", "date": "2025-03-25" }, "Gemini 2.5 Pro (May 2025)": { "name": "Gemini 2.5 Pro (May 2025)", "date": "2025-05-06" }, "Gemini 3 Flash": { "name": "Gemini 3 Flash", "date": "2025-12-17" }, "Gemini 3 Pro": { "name": "Gemini 3 Pro", "date": "2025-11-18" }, "Gemma 2 27B": { "name": "Gemma 2 27B", "date": "2024-06-24" }, "Gemma 2 9B": { "name": "Gemma 2 9B", "date": "2024-06-24" }, "Gemma 2B": { "name": "Gemma 2B", "date": "2024-02-21" }, "Gemma 3 27B": { "name": "Gemma 3 27B", "date": "2025-03-12" }, "Gemma 7B": { "name": "Gemma 7B", "date": "2024-02-21" }, "Grok 3": { "name": "Grok 3", "date": "2025-04-09" }, "Grok 4": { "name": "Grok 4", "date": "2025-07-09" }, "Grok-2": { "name": "Grok-2", "date": "2024-12-12" }, "Grok-3 mini": { "name": "Grok-3 mini", "date": "2025-04-09" }, "INTELLECT-1": { "name": "INTELLECT-1", "date": "2024-11-29" }, "Kimi K2": { "name": "Kimi K2", "date": "2025-07-12" }, "Kimi K2 Thinking": { "name": "Kimi K2 Thinking", "date": "2025-11-06" }, "LLaMA-13B": { "name": "LLaMA-13B", "date": "2023-02-24" }, "LLaMA-33B": { "name": "LLaMA-33B", "date": "2023-02-24" }, "LLaMA-65B": { "name": "LLaMA-65B", "date": "2023-02-24" }, "LLaMA-7B": { "name": "LLaMA-7B", "date": "2023-02-24" }, "Llama 2-13B": { "name": "Llama 2-13B", "date": "2023-07-18" }, "Llama 2-34B": { "name": "Llama 2-34B", "date": "2023-07-18" }, "Llama 2-70B": { "name": "Llama 2-70B", "date": "2023-07-18" }, "Llama 2-7B": { "name": "Llama 2-7B", "date": "2023-07-18" }, "Llama 3-70B": { "name": "Llama 3-70B", "date": "2024-04-18" }, "Llama 3-8B": { "name": "Llama 3-8B", "date": "2024-04-18" }, "Llama 3.1-405B": { "name": "Llama 3.1-405B", "date": "2024-07-23" }, "Llama 3.1-70B": { "name": "Llama 3.1-70B", "date": "2024-07-23" }, "Llama 3.1-8B": { "name": "Llama 3.1-8B", "date": "2024-07-23" }, "Llama 3.2 90B": { "name": "Llama 3.2 90B", "date": "2024-09-24" }, "Llama 3.3 70B": { "name": "Llama 3.3 70B", "date": "2024-12-06" }, "Llama 4 Maverick": { "name": "Llama 4 Maverick", "date": "2025-04-05" }, "Llama 4 Scout": { "name": "Llama 4 Scout", "date": "2025-04-05" }, "MPT-30B": { "name": "MPT-30B", "date": "2023-06-22" }, "MPT-7B": { "name": "MPT-7B", "date": "2023-05-05" }, "Mistral 7B": { "name": "Mistral 7B", "date": "2023-09-27" }, "Mistral Large": { "name": "Mistral Large", "date": "2024-02-26" }, "Mistral Large 2": { "name": "Mistral Large 2", "date": "2024-11-18" }, "Mistral Medium 3": { "name": "Mistral Medium 3", "date": "2025-05-07" }, "Mistral NeMo": { "name": "Mistral NeMo", "date": "2024-07-18" }, "Mixtral 8x22B": { "name": "Mixtral 8x22B", "date": "2024-04-17" }, "Mixtral 8x7B": { "name": "Mixtral 8x7B", "date": "2023-12-11" }, "Nemotron-4 15B": { "name": "Nemotron-4 15B", "date": "2024-02-26" }, "Phi-1.5": { "name": "Phi-1.5", "date": "2023-09-11" }, "Phi-2": { "name": "Phi-2", "date": "2023-12-12" }, "Phi-4": { "name": "Phi-4", "date": "2024-12-12" }, "Qwen Plus": { "name": "Qwen Plus", "date": "2025-01-25" }, "Qwen-14B": { "name": "Qwen-14B", "date": "2023-09-28" }, "Qwen-7B": { "name": "Qwen-7B", "date": "2023-09-28" }, "Qwen2-72B": { "name": "Qwen2-72B", "date": "2024-06-07" }, "Qwen2.5-72B": { "name": "Qwen2.5-72B", "date": "2024-09-19" }, "Qwen2.5-Coder (1.5B)": { "name": "Qwen2.5-Coder (1.5B)", "date": "2024-09-18" }, "Qwen2.5-Coder (32B)": { "name": "Qwen2.5-Coder (32B)", "date": "2024-09-18" }, "Qwen2.5-Coder (7B)": { "name": "Qwen2.5-Coder (7B)", "date": "2024-09-18" }, "Qwen2.5-Max": { "name": "Qwen2.5-Max", "date": "2025-01-25" }, "Qwen3-235B-A22B": { "name": "Qwen3-235B-A22B", "date": "2025-04-29" }, "Qwen3-235B-A22B-Thinking (Jul 2025)": { "name": "Qwen3-235B-A22B-Thinking (Jul 2025)", "date": "2025-07-25" }, "Qwen3-Coder-480B-A35B": { "name": "Qwen3-Coder-480B-A35B", "date": "2025-07-31" }, "Qwen3-Max": { "name": "Qwen3-Max", "date": "2025-09-24" }, "Stable Beluga 2": { "name": "Stable Beluga 2", "date": "2023-07-20" }, "StarCoder 2 15B": { "name": "StarCoder 2 15B", "date": "2024-02-20" }, "StarCoder 2 3B": { "name": "StarCoder 2 3B", "date": "2024-02-22" }, "StarCoder 2 7B": { "name": "StarCoder 2 7B", "date": "2024-02-20" }, "XGen-7B": { "name": "XGen-7B", "date": "2023-06-27" }, "Yi 6B": { "name": "Yi 6B", "date": "2023-11-02" }, "Yi-34B": { "name": "Yi-34B", "date": "2023-11-22" }, "gpt-oss-120b": { "name": "gpt-oss-120b", "date": "2025-08-05" }, "o1": { "name": "o1", "date": "2024-12-17" }, "o1-mini": { "name": "o1-mini", "date": "2024-09-12" }, "o1-preview": { "name": "o1-preview", "date": "2024-09-12" }, "o3": { "name": "o3", "date": "2025-04-16" }, "o3-mini": { "name": "o3-mini", "date": "2025-01-31" }, "o3-pro": { "name": "o3-pro", "date": "2025-06-10" }, "o4-mini": { "name": "o4-mini", "date": "2025-04-16" }, "phi-3-medium 14B": { "name": "phi-3-medium 14B", "date": "2024-04-23" }, "phi-3-mini 3.8B": { "name": "phi-3-mini 3.8B", "date": "2024-04-23" }, "phi-3-small 7.4B": { "name": "phi-3-small 7.4B", "date": "2024-04-23" } }, "benchmarks": { "ARC AI2": { "name": "ARC AI2", "diff": 105.1930405856702, "disc": 0.0944288087686699 }, "BBH": { "name": "BBH", "diff": 113.60350501413456, "disc": 0.084821943823402 }, "GSM8K": { "name": "GSM8K", "diff": 105.65084306346868, "disc": 0.0963752526209175 }, "HellaSwag": { "name": "HellaSwag", "diff": 76.54614285395945, "disc": 0.0301332309687049 }, "LAMBADA": { "name": "LAMBADA", "diff": 32.37583948836671, "disc": 0.0152206717542228 }, "MMLU": { "name": "MMLU", "diff": 109.84539034547636, "disc": 0.0666196953012477 }, "GPQA diamond": { "name": "GPQA diamond", "diff": 135.905859745637, "disc": 0.1205381131999341 }, "MATH level 5": { "name": "MATH level 5", "diff": 128.11393930948424, "disc": 0.1849098233215427 }, "OTIS Mock AIME 2024-2025": { "name": "OTIS Mock AIME 2024-2025", "diff": 138.04409483210003, "disc": 0.2353216021056998 }, "WeirdML": { "name": "WeirdML", "diff": 145.0710546736157, "disc": 0.0814742311916497 }, "Winogrande": { "name": "Winogrande", "diff": 109.73284588313348, "disc": 0.0452915372619513 }, "TriviaQA": { "name": "TriviaQA", "diff": 50.24834447104708, "disc": 0.0181355933800949 }, "Cybench": { "name": "Cybench", "diff": 147.41076875706423, "disc": 0.1474436270890705 }, "SimpleBench": { "name": "SimpleBench", "diff": 149.2864892654243, "disc": 0.1201644182250022 }, "The Agent Company": { "name": "The Agent Company", "diff": 146.93112836234894, "disc": 0.14284206272087 }, "PIQA": { "name": "PIQA", "diff": 75.44154840421315, "disc": 0.016737696321792 }, "OpenBookQA": { "name": "OpenBookQA", "diff": 105.06526736914988, "disc": 0.0516643993159377 }, "Balrog": { "name": "Balrog", "diff": 158.7415159126036, "disc": 0.0408850679569183 }, "GeoBench": { "name": "GeoBench", "diff": 118.04089607750711, "disc": 0.0320612927702825 }, "Fiction.LiveBench": { "name": "Fiction.LiveBench", "diff": 135.46100907423966, "disc": 0.1237881484208301 }, "FrontierMath-2025-02-28-Private": { "name": "FrontierMath-2025-02-28-Private", "diff": 155.73473920633722, "disc": 0.1660351142989665 }, "Aider polyglot": { "name": "Aider polyglot", "diff": 138.80808212823638, "disc": 0.1766038501623188 }, "Lech Mazur Writing": { "name": "Lech Mazur Writing", "diff": 108.8215952802692, "disc": 0.0408249757909401 }, "ARC-AGI": { "name": "ARC-AGI", "diff": 146.10321514972603, "disc": 0.2159491664898188 }, "SWE-Bench Verified (Bash Only)": { "name": "SWE-Bench Verified (Bash Only)", "diff": 142.8387294620133, "disc": 0.1325078119866445 }, "CadEval": { "name": "CadEval", "diff": 139.94976565935565, "disc": 0.1012534267007525 }, "SimpleQA Verified": { "name": "SimpleQA Verified", "diff": 149.508369395908, "disc": 0.1451753901944211 }, "ANLI": { "name": "ANLI", "diff": 129.76641601907025, "disc": 0.0647584914337646 }, "FrontierMath-Tier-4-2025-07-01-Private": { "name": "FrontierMath-Tier-4-2025-07-01-Private", "diff": 161.93389444503427, "disc": 0.1854878328641463 }, "VideoMME": { "name": "VideoMME", "diff": 108.55584885904462, "disc": 0.0180996852544703 }, "VPCT": { "name": "VPCT", "diff": 145.08306464982996, "disc": 0.0717011218908533 }, "OSWorld": { "name": "OSWorld", "diff": 146.8083216994265, "disc": 0.1256180284929259 }, "GSO-Bench": { "name": "GSO-Bench", "diff": 164.8551803608777, "disc": 0.1249943043964883 }, "Chess Puzzles": { "name": "Chess Puzzles", "diff": 157.73009457333544, "disc": 0.1166623682165005 }, "Terminal Bench": { "name": "Terminal Bench", "diff": 150.56323908697456, "disc": 0.1248082673348482 }, "DeepResearch Bench": { "name": "DeepResearch Bench", "diff": 148.7751386129299, "disc": 0.0355571039883531 }, "ScienceQA": { "name": "ScienceQA", "diff": 110.19904769844744, "disc": 0.0854500706191642 } }, "performances": { "Baichuan 2-7B": { "ARC AI2": 0.1, "BBH": 0.2213333333333333, "GSM8K": 0.246, "HellaSwag": 0.5733333333333334, "LAMBADA": 0.733, "MMLU": 0.3888 }, "Claude 3 Sonnet": { "GPQA diamond": 0.2079124579124579, "MATH level 5": 0.1817409365558912, "OTIS Mock AIME 2024-2025": 0.024024024024024, "WeirdML": 0.1016, "MMLU": 0.6786666666666666, "Winogrande": 0.502 }, "Llama 3.1-405B": { "ARC AI2": 0.9373333333333332, "TriviaQA": 0.827, "GPQA diamond": 0.3455387205387206, "MATH level 5": 0.4977341389728096, "OTIS Mock AIME 2024-2025": 0.0963185407629851, "WeirdML": 0.2138, "Cybench": 0.075, "SimpleBench": 0.076, "BBH": 0.7719999999999999, "The Agent Company": 0.074, "HellaSwag": 0.856, "MMLU": 0.7933333333333333, "PIQA": 0.718, "OpenBookQA": 0.3226666666666666, "Winogrande": 0.784 }, "Llama 3.1-70B": { "GPQA diamond": 0.2558922558922558, "MATH level 5": 0.366786253776435, "OTIS Mock AIME 2024-2025": 0.0351462573684795, "WeirdML": 0.0897, "Balrog": 0.279, "The Agent Company": 0.069, "MMLU": 0.7346666666666667 }, "Llama 3.1-8B": { "GPQA diamond": 0.0126262626262625, "MATH level 5": 0.2287575528700906, "OTIS Mock AIME 2024-2025": 0.024024024024024, "WeirdML": 0.0173, "Balrog": 0.151, "GSM8K": 0.824, "MMLU": 0.4146666666666667, "PIQA": 0.6240000000000001 }, "Llama 3.2 90B": { "GPQA diamond": 0.2138047138047137, "MATH level 5": 0.3943542296072507, "OTIS Mock AIME 2024-2025": 0.0254143031920808, "Balrog": 0.273, "GeoBench": 0.52, "MMLU": 0.7373333333333334 }, "Llama 3.3 70B": { "GPQA diamond": 0.2992424242424242, "MATH level 5": 0.4159743202416918, "OTIS Mock AIME 2024-2025": 0.0504393282171059, "WeirdML": 0.1444, "SimpleBench": 0.0388, "Balrog": 0.23, "Fiction.LiveBench": 0.333, "MMLU": 0.8173333333333334 }, "Llama 4 Maverick": { "GPQA diamond": 0.5597643097643098, "MATH level 5": 0.7301737160120846, "OTIS Mock AIME 2024-2025": 0.2047603158714269, "WeirdML": 0.2447, "SimpleBench": 0.1324, "FrontierMath-2025-02-28-Private": 0.0068965517241379, "Aider polyglot": 0.156, "GeoBench": 0.52, "Lech Mazur Writing": 0.637, "ARC-AGI": 0.044, "Fiction.LiveBench": 0.462, "SWE-Bench Verified (Bash Only)": 0.2104 }, "Llama 4 Scout": { "GPQA diamond": 0.3577441077441077, "MATH level 5": 0.6227341389728097, "OTIS Mock AIME 2024-2025": 0.0768546324101878, "FrontierMath-2025-02-28-Private": 0.0, "ARC-AGI": 0.005, "Fiction.LiveBench": 0.36, "SWE-Bench Verified (Bash Only)": 0.0906 }, "MPT-30B": { "ARC AI2": 0.3413333333333333, "TriviaQA": 0.736, "BBH": 0.1733333333333333, "GSM8K": 0.344, "MMLU": 0.3053333333333333, "PIQA": 0.6379999999999999, "OpenBookQA": 0.36, "Winogrande": 0.4199999999999999 }, "MPT-7B": { "ARC AI2": 0.2346666666666666, "TriviaQA": 0.616, "BBH": 0.1413333333333333, "GSM8K": 0.091, "HellaSwag": 0.6853333333333333, "LAMBADA": 0.7, "MMLU": 0.0773333333333333, "PIQA": 0.6120000000000001, "OpenBookQA": 0.352, "Winogrande": 0.3720000000000001 }, "Claude 3.5 Haiku": { "GPQA diamond": 0.1750841750841751, "MATH level 5": 0.4635574018126888, "OTIS Mock AIME 2024-2025": 0.0420976532087642, "WeirdML": 0.3073, "CadEval": 0.32, "FrontierMath-2025-02-28-Private": 0.0034482758620689, "SimpleQA Verified": 0.067, "Aider polyglot": 0.28, "Balrog": 0.193, "GeoBench": 0.34, "Lech Mazur Writing": 0.735, "MMLU": 0.6573333333333333 }, "Mistral 7B": { "ARC AI2": 0.7146666666666667, "TriviaQA": 0.752, "MATH level 5": 0.0368202416918429, "BBH": 0.4146666666666667, "GSM8K": 0.544, "ANLI": 0.2064999999999999, "HellaSwag": 0.7466666666666667, "MMLU": 0.5, "PIQA": 0.6599999999999999, "OpenBookQA": 0.7306666666666667, "Winogrande": 0.506 }, "Mistral Large": { "GPQA diamond": 0.1835016835016834, "MATH level 5": 0.2446185800604229, "OTIS Mock AIME 2024-2025": 0.0184629073517961, "MMLU": 0.584 }, "Mistral Large 2": { "GPQA diamond": 0.351010101010101, "MATH level 5": 0.5028323262839879, "OTIS Mock AIME 2024-2025": 0.0838060282504726, "SimpleBench": 0.07, "FrontierMath-2025-02-28-Private": 0.0034482758620689, "Lech Mazur Writing": 0.6900000000000001, "MMLU": 0.7333333333333334 }, "Mistral Medium 3": { "GPQA diamond": 0.4604377104377105, "MATH level 5": 0.8162764350453172, "OTIS Mock AIME 2024-2025": 0.3215437659882104, "FrontierMath-2025-02-28-Private": 0.0034602076124567 }, "Mistral NeMo": { "GPQA diamond": 0.0652356902356902, "MATH level 5": 0.1082892749244713, "Balrog": 0.176, "GSM8K": 0.842, "PIQA": 0.6699999999999999 }, "Mixtral 8x22B": { "GPQA diamond": 0.1207912457912457, "MATH level 5": 0.2424471299093655, "WeirdML": 0.0317, "Cybench": 0.075, "MMLU": 0.7040000000000001 }, "Mixtral 8x7B": { "ARC AI2": 0.8306666666666667, "TriviaQA": 0.822, "GPQA diamond": 0.0744949494949494, "MATH level 5": 0.0995090634441087, "GSM8K": 0.744, "ANLI": 0.328, "HellaSwag": 0.8226666666666667, "MMLU": 0.608, "PIQA": 0.6719999999999999, "OpenBookQA": 0.8106666666666666, "Winogrande": 0.544 }, "Nemotron-4 15B": { "ARC AI2": 0.4066666666666667, "BBH": 0.4493333333333333, "GSM8K": 0.46, "HellaSwag": 0.7653333333333333, "MMLU": 0.4493333333333333, "PIQA": 0.6479999999999999, "Winogrande": 0.56 }, "Phi-1.5": { "ARC AI2": 0.2586666666666666, "HellaSwag": 0.3013333333333333, "MMLU": 0.168, "OpenBookQA": 0.1626666666666666, "Winogrande": 0.4679999999999999 }, "Claude 3.5 Sonnet": { "GPQA diamond": 0.3872053872053873, "MATH level 5": 0.5168051359516617, "OTIS Mock AIME 2024-2025": 0.0643421198976753, "WeirdML": 0.3097, "Cybench": 0.175, "SimpleBench": 0.13, "FrontierMath-2025-02-28-Private": 0.0103448275862068, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "VideoMME": 0.4666666666666666, "VPCT": 0.33, "MMLU": 0.82 }, "Phi-2": { "ARC AI2": 0.6786666666666666, "TriviaQA": 0.452, "BBH": 0.4586666666666666, "ANLI": 0.1374999999999999, "HellaSwag": 0.3813333333333333, "MMLU": 0.4453333333333333, "OpenBookQA": 0.648, "Winogrande": 0.094 }, "Phi-4": { "GPQA diamond": 0.4141414141414141, "MATH level 5": 0.6493580060422961, "OTIS Mock AIME 2024-2025": 0.1366366366366366, "Balrog": 0.116, "Lech Mazur Writing": 0.626, "MMLU": 0.7973333333333333 }, "Qwen Plus": { "GPQA diamond": 0.3080808080808081, "MATH level 5": 0.6527567975830816, "OTIS Mock AIME 2024-2025": 0.1769547325102879, "FrontierMath-2025-02-28-Private": 0.0172413793103448 }, "Qwen-14B": { "ARC AI2": 0.7919999999999999, "BBH": 0.4000000000000001, "GSM8K": 0.613, "LAMBADA": 0.711, "MMLU": 0.5506666666666667, "PIQA": 0.5980000000000001 }, "Qwen-7B": { "ARC AI2": 0.6706666666666666, "BBH": 0.2666666666666666, "GSM8K": 0.517, "LAMBADA": 0.679, "MMLU": 0.2666666666666666, "PIQA": 0.558 }, "Qwen2-72B": { "GPQA diamond": 0.2104377104377104, "MATH level 5": 0.3906722054380664, "The Agent Company": 0.011, "MMLU": 0.7653333333333333 }, "Qwen2.5-72B": { "ARC AI2": 0.9266666666666666, "TriviaQA": 0.719, "GPQA diamond": 0.3219696969696969, "MATH level 5": 0.631703172205438, "OTIS Mock AIME 2024-2025": 0.0796351907463018, "BBH": 0.7306666666666667, "Balrog": 0.162, "GeoBench": 0.62, "VideoMME": 0.6466666666666666, "The Agent Company": 0.057, "OSWorld": 0.05, "HellaSwag": 0.7973333333333333, "MMLU": 0.8039999999999999, "PIQA": 0.6519999999999999, "Winogrande": 0.6459999999999999 }, "Qwen2.5-Coder (1.5B)": { "ARC AI2": 0.2693333333333333, "GSM8K": 0.658, "HellaSwag": 0.4906666666666666, "MMLU": 0.3813333333333333, "Winogrande": 0.2139999999999999 }, "Qwen2.5-Coder (32B)": { "ARC AI2": 0.6066666666666666, "Aider polyglot": 0.1639999999999999, "GSM8K": 0.93, "SWE-Bench Verified (Bash Only)": 0.09, "HellaSwag": 0.7733333333333333, "MMLU": 0.7213333333333334, "Winogrande": 0.6160000000000001 }, "Qwen2.5-Coder (7B)": { "ARC AI2": 0.4786666666666666, "GSM8K": 0.867, "HellaSwag": 0.6906666666666667, "MMLU": 0.5733333333333334, "Winogrande": 0.4579999999999999 }, "Claude 3.5 Sonnet (October 2024)": { "GPQA diamond": 0.404040404040404, "MATH level 5": 0.5694864048338368, "OTIS Mock AIME 2024-2025": 0.0838060282504726, "WeirdML": 0.3997, "CadEval": 0.48, "SimpleBench": 0.2967999999999999, "FrontierMath-2025-02-28-Private": 0.0206896551724137, "Aider polyglot": 0.516, "Balrog": 0.326, "GeoBench": 0.62, "Lech Mazur Writing": 0.8029999999999999, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "VPCT": 0.33, "GSO-Bench": 0.046, "The Agent Company": 0.24, "MMLU": 0.8306666666666667 }, "Qwen2.5-Max": { "GPQA diamond": 0.4149831649831649, "MATH level 5": 0.6718277945619335, "OTIS Mock AIME 2024-2025": 0.1602713824936047, "FrontierMath-2025-02-28-Private": 0.0103448275862068, "Aider polyglot": 0.218, "Lech Mazur Writing": 0.7290000000000001, "Fiction.LiveBench": 0.667 }, "Qwen3-235B-A22B": { "GPQA diamond": 0.6094276094276094, "MATH level 5": 0.6885699899295065, "SimpleBench": 0.172, "Aider polyglot": 0.596, "Lech Mazur Writing": 0.8300000000000001, "Fiction.LiveBench": 0.677 }, "Qwen3-235B-A22B-Thinking (Jul 2025)": { "GPQA diamond": 0.734006734006734, "OTIS Mock AIME 2024-2025": 0.8665331998665332, "WeirdML": 0.4104, "FrontierMath-2025-02-28-Private": 0.0848056537102473, "SimpleQA Verified": 0.501002004008016, "Lech Mazur Writing": 0.8494999999999999, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "Fiction.LiveBench": 0.75, "Chess Puzzles": 0.1224489795918367 }, "Qwen3-Coder-480B-A35B": { "WeirdML": 0.4117, "GSO-Bench": 0.049, "SWE-Bench Verified (Bash Only)": 0.554, "Terminal Bench": 0.254 }, "Qwen3-Max": { "GPQA diamond": 0.6346801346801346, "MATH level 5": 0.9712990936555892, "OTIS Mock AIME 2024-2025": 0.7330663997330663, "SimpleQA Verified": 0.6746746746746747, "Lech Mazur Writing": 0.8711000000000001, "Fiction.LiveBench": 0.667, "Chess Puzzles": 0.04 }, "Stable Beluga 2": { "ARC AI2": 0.8146666666666667, "BBH": 0.5906666666666666, "GSM8K": 0.696, "HellaSwag": 0.7879999999999999, "LAMBADA": 0.713, "MMLU": 0.5813333333333334, "PIQA": 0.6659999999999999 }, "StarCoder 2 15B": { "ARC AI2": 0.296, "GSM8K": 0.577, "MMLU": 0.5213333333333333, "Winogrande": 0.286 }, "StarCoder 2 3B": { "ARC AI2": 0.1226666666666667, "GSM8K": 0.216, "MMLU": 0.1546666666666666, "Winogrande": 0.1419999999999999 }, "StarCoder 2 7B": { "ARC AI2": 0.1826666666666666, "GSM8K": 0.327, "MMLU": 0.184, "Winogrande": 0.1419999999999999 }, "XGen-7B": { "ARC AI2": 0.2159999999999999, "HellaSwag": 0.656, "MMLU": 0.1506666666666666, "PIQA": 0.51, "OpenBookQA": 0.2026666666666667, "Winogrande": 0.298 }, "Claude 3.7 Sonnet": { "GPQA diamond": 0.7297979797979798, "MATH level 5": 0.9116314199395772, "OTIS Mock AIME 2024-2025": 0.5773551329106884, "CadEval": 0.54, "Cybench": 0.2, "SimpleBench": 0.3568, "FrontierMath-2025-02-28-Private": 0.0413793103448275, "Aider polyglot": 0.649, "GeoBench": 0.68, "Lech Mazur Writing": 0.8109999999999999, "VPCT": 0.39, "GSO-Bench": 0.038, "The Agent Company": 0.309, "ARC-AGI": 0.286, "DeepResearch Bench": 0.436, "Fiction.LiveBench": 0.833, "OSWorld": 0.358, "SWE-Bench Verified (Bash Only)": 0.528 }, "Yi 6B": { "ARC AI2": 0.3373333333333333, "BBH": 0.296, "GSM8K": 0.449, "HellaSwag": 0.6586666666666666, "MMLU": 0.52, "Winogrande": 0.4259999999999999 }, "Yi-34B": { "MATH level 5": 0.0514539274924471, "BBH": 0.6226666666666666, "GSM8K": 0.76, "MMLU": 0.684 }, "gpt-oss-120b": { "GPQA diamond": 0.6767676767676768, "OTIS Mock AIME 2024-2025": 0.8887776665554443, "WeirdML": 0.4817, "SimpleBench": 0.0652, "SimpleQA Verified": 0.139, "Aider polyglot": 0.418, "Lech Mazur Writing": 0.7726000000000001, "Fiction.LiveBench": 0.444, "SWE-Bench Verified (Bash Only)": 0.26, "Terminal Bench": 0.187, "Chess Puzzles": 0.2 }, "o1": { "GPQA diamond": 0.6902356902356902, "MATH level 5": 0.947129909365559, "OTIS Mock AIME 2024-2025": 0.7330663997330663, "WeirdML": 0.4382, "CadEval": 0.56, "SimpleBench": 0.2812, "FrontierMath-2025-02-28-Private": 0.093103448275862, "Aider polyglot": 0.617, "GeoBench": 0.8, "Lech Mazur Writing": 0.702, "VPCT": 0.37, "ARC-AGI": 0.307, "Fiction.LiveBench": 0.833 }, "o1-mini": { "GPQA diamond": 0.4983164983164982, "MATH level 5": 0.8918051359516617, "OTIS Mock AIME 2024-2025": 0.4689133578022466, "WeirdML": 0.3632, "Cybench": 0.1, "SimpleBench": 0.0172, "FrontierMath-2025-02-28-Private": 0.0172413793103448, "Lech Mazur Writing": 0.649, "ARC-AGI": 0.14 }, "o1-preview": { "GPQA diamond": 0.3375420875420875, "MATH level 5": 0.8164652567975831, "OTIS Mock AIME 2024-2025": 0.3104215326437549, "WeirdML": 0.4756, "Cybench": 0.1, "SimpleBench": 0.3003999999999999, "ARC-AGI": 0.18 }, "o3": { "GPQA diamond": 0.7575757575757577, "MATH level 5": 0.9777190332326284, "OTIS Mock AIME 2024-2025": 0.8387276165053943, "WeirdML": 0.5242, "CadEval": 0.74, "SimpleBench": 0.4372, "FrontierMath-2025-02-28-Private": 0.1868512110726643, "SimpleQA Verified": 0.53, "Aider polyglot": 0.813, "GeoBench": 0.74, "Lech Mazur Writing": 0.8390000000000001, "FrontierMath-Tier-4-2025-07-01-Private": 0.0208333333333333, "VPCT": 0.52, "GSO-Bench": 0.088, "ARC-AGI": 0.608, "DeepResearch Bench": 0.466, "Fiction.LiveBench": 0.889, "OSWorld": 0.23, "SWE-Bench Verified (Bash Only)": 0.584 }, "o3-mini": { "GPQA diamond": 0.6936026936026937, "MATH level 5": 0.9648791540785498, "OTIS Mock AIME 2024-2025": 0.769213658102547, "WeirdML": 0.437, "CadEval": 0.54, "Cybench": 0.225, "SimpleBench": 0.0736, "FrontierMath-2025-02-28-Private": 0.1241379310344827, "Aider polyglot": 0.604, "Lech Mazur Writing": 0.617, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "GSO-Bench": 0.013, "ARC-AGI": 0.345, "Fiction.LiveBench": 0.5, "Chess Puzzles": 0.17 }, "o3-pro": { "WeirdML": 0.5821, "Aider polyglot": 0.8490000000000001, "Lech Mazur Writing": 0.8628, "ARC-AGI": 0.593, "Fiction.LiveBench": 0.972 }, "o4-mini": { "GPQA diamond": 0.728114478114478, "MATH level 5": 0.978285498489426, "OTIS Mock AIME 2024-2025": 0.8164831498164832, "WeirdML": 0.5256, "CadEval": 0.62, "SimpleBench": 0.2644, "FrontierMath-2025-02-28-Private": 0.2482758620689655, "SimpleQA Verified": 0.239, "Aider polyglot": 0.72, "GeoBench": 0.64, "Lech Mazur Writing": 0.75, "FrontierMath-Tier-4-2025-07-01-Private": 0.0625, "VPCT": 0.575, "GSO-Bench": 0.036, "ARC-AGI": 0.587, "Fiction.LiveBench": 0.778, "SWE-Bench Verified (Bash Only)": 0.45, "Chess Puzzles": 0.26 }, "Claude Haiku 4.5": { "GPQA diamond": 0.6161616161616162, "MATH level 5": 0.9636087945413192, "OTIS Mock AIME 2024-2025": 0.666332999666333, "WeirdML": 0.454, "FrontierMath-2025-02-28-Private": 0.0590277777777777, "SimpleQA Verified": 0.059, "FrontierMath-Tier-4-2025-07-01-Private": 0.0208333333333333, "Terminal Bench": 0.298 }, "phi-3-medium 14B": { "ARC AI2": 0.888, "TriviaQA": 0.739, "GPQA diamond": 0.0345117845117845, "MATH level 5": 0.1756042296072507, "BBH": 0.7519999999999999, "ANLI": 0.3370000000000001, "HellaSwag": 0.7653333333333333, "MMLU": 0.7066666666666667, "OpenBookQA": 0.832, "Winogrande": 0.6299999999999999 }, "phi-3-mini 3.8B": { "ARC AI2": 0.7986666666666666, "TriviaQA": 0.64, "BBH": 0.6226666666666666, "ANLI": 0.292, "HellaSwag": 0.6893333333333334, "MMLU": 0.584, "OpenBookQA": 0.84, "Winogrande": 0.4159999999999999 }, "phi-3-small 7.4B": { "ARC AI2": 0.876, "TriviaQA": 0.581, "BBH": 0.7213333333333334, "ANLI": 0.3714999999999999, "HellaSwag": 0.6933333333333334, "MMLU": 0.676, "OpenBookQA": 0.84, "Winogrande": 0.6299999999999999 }, "Claude Instant": { "ARC AI2": 0.8173333333333334, "TriviaQA": 0.789, "GSM8K": 0.867, "MMLU": 0.6453333333333333 }, "Claude Opus 4": { "GPQA diamond": 0.6835016835016835, "MATH level 5": 0.850453172205438, "OTIS Mock AIME 2024-2025": 0.6440885329774219, "WeirdML": 0.434, "Cybench": 0.38, "SimpleBench": 0.5055999999999999, "FrontierMath-2025-02-28-Private": 0.0448275862068965, "Aider polyglot": 0.72, "GeoBench": 0.49, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.38, "GSO-Bench": 0.069, "ARC-AGI": 0.357, "DeepResearch Bench": 0.49, "Fiction.LiveBench": 0.611, "SWE-Bench Verified (Bash Only)": 0.676 }, "Claude Opus 4.1": { "GPQA diamond": 0.6969696969696969, "OTIS Mock AIME 2024-2025": 0.6885774663552441, "WeirdML": 0.4276, "Cybench": 0.38, "SimpleBench": 0.52, "FrontierMath-2025-02-28-Private": 0.0724137931034482, "SimpleQA Verified": 0.348, "Lech Mazur Writing": 0.8538000000000001, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.35, "DeepResearch Bench": 0.497, "Terminal Bench": 0.38 }, "Claude Opus 4.5": { "GPQA diamond": 0.813973063973064, "OTIS Mock AIME 2024-2025": 0.8609720831943055, "WeirdML": 0.637, "FrontierMath-2025-02-28-Private": 0.2068965517241379, "SimpleQA Verified": 0.418, "GeoBench": 0.75, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.4, "GSO-Bench": 0.265, "ARC-AGI": 0.8, "OSWorld": 0.663, "SWE-Bench Verified (Bash Only)": 0.744, "Terminal Bench": 0.631, "Chess Puzzles": 0.12 }, "Baichuan1-7B": { "BBH": 0.0997333333333333, "GSM8K": 0.092, "MMLU": 0.2306666666666666, "PIQA": 0.524 }, "Claude Sonnet 4": { "GPQA diamond": 0.7225042301184433, "MATH level 5": 0.8436555891238671, "OTIS Mock AIME 2024-2025": 0.7108219330441553, "WeirdML": 0.4611, "Cybench": 0.35, "SimpleBench": 0.346, "FrontierMath-2025-02-28-Private": 0.0413793103448275, "Aider polyglot": 0.613, "GeoBench": 0.37, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "VPCT": 0.34, "GSO-Bench": 0.049, "The Agent Company": 0.331, "ARC-AGI": 0.4, "DeepResearch Bench": 0.478, "Fiction.LiveBench": 0.469, "OSWorld": 0.439, "SWE-Bench Verified (Bash Only)": 0.6493 }, "Claude Sonnet 4.5": { "GPQA diamond": 0.7643097643097643, "MATH level 5": 0.9773413897280968, "OTIS Mock AIME 2024-2025": 0.7775553331108886, "WeirdML": 0.4771, "Cybench": 0.55, "SimpleBench": 0.4516, "FrontierMath-2025-02-28-Private": 0.1522491349480969, "SimpleQA Verified": 0.236, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.398, "GSO-Bench": 0.147, "DeepResearch Bench": 0.526, "OSWorld": 0.629, "SWE-Bench Verified (Bash Only)": 0.706, "Terminal Bench": 0.428, "Chess Puzzles": 0.12 }, "DeepSeek Coder 1.3B": { "ARC AI2": 0.0053333333333333, "GSM8K": 0.044, "MMLU": 0.0106666666666666, "Winogrande": 0.066 }, "DeepSeek Coder 33B": { "ARC AI2": 0.2293333333333333, "GSM8K": 0.354, "MMLU": 0.192, "Winogrande": 0.24 }, "DeepSeek Coder 6.7B": { "ARC AI2": 0.152, "GSM8K": 0.213, "MMLU": 0.152, "Winogrande": 0.1519999999999999 }, "DeepSeek-R1": { "GPQA diamond": 0.6228956228956228, "MATH level 5": 0.9305135951661632, "OTIS Mock AIME 2024-2025": 0.5328661995328662, "WeirdML": 0.3649, "SimpleBench": 0.1708, "Aider polyglot": 0.569, "Balrog": 0.349, "Lech Mazur Writing": 0.8300000000000001, "ARC-AGI": 0.158, "Fiction.LiveBench": 0.694 }, "DeepSeek-R1 (May 2025)": { "GPQA diamond": 0.6843434343434344, "MATH level 5": 0.9663897280966768, "OTIS Mock AIME 2024-2025": 0.6635524413302191, "WeirdML": 0.4163, "SimpleBench": 0.2895999999999999, "SimpleQA Verified": 0.274, "Aider polyglot": 0.7140000000000001, "ARC-AGI": 0.212, "DeepResearch Bench": 0.351, "Fiction.LiveBench": 0.75 }, "DeepSeek-V2 (MoE-236B)": { "ARC AI2": 0.896, "TriviaQA": 0.8, "BBH": 0.7173333333333334, "HellaSwag": 0.828, "MMLU": 0.7120000000000001, "PIQA": 0.6779999999999999, "Winogrande": 0.726 }, "DeepSeek-V3": { "ARC AI2": 0.9373333333333332, "TriviaQA": 0.829, "GPQA diamond": 0.5681818181818182, "MATH level 5": 0.75547583081571, "OTIS Mock AIME 2024-2025": 0.3771549327104882, "WeirdML": 0.3608, "SimpleBench": 0.1264, "FrontierMath-2025-02-28-Private": 0.0172413793103448, "BBH": 0.8333333333333334, "Aider polyglot": 0.551, "Lech Mazur Writing": 0.77, "Fiction.LiveBench": 0.5, "HellaSwag": 0.852, "MMLU": 0.8293333333333334, "PIQA": 0.694, "Winogrande": 0.704 }, "DeepSeek-V3.1": { "WeirdML": 0.3836, "SimpleBench": 0.28, "Lech Mazur Writing": 0.8517, "Fiction.LiveBench": 0.528 }, "Baichuan2-13B": { "ARC AI2": 0.1733333333333333, "BBH": 0.32, "GSM8K": 0.528, "HellaSwag": 0.6106666666666666, "LAMBADA": 0.74, "MMLU": 0.4559999999999999, "PIQA": 0.562 }, "DeepSeek-V3.2": { "GPQA diamond": 0.7789802789802791, "OTIS Mock AIME 2024-2025": 0.8780526558304335, "FrontierMath-2025-02-28-Private": 0.221, "SimpleQA Verified": 0.275, "FrontierMath-Tier-4-2025-07-01-Private": 0.021, "Chess Puzzles": 0.14 }, "DeepSeek-V3.2-Exp": { "WeirdML": 0.3948, "Aider polyglot": 0.742, "The Agent Company": 0.429, "Fiction.LiveBench": 0.833 }, "Dolly 2.0-12b": { "ARC AI2": 0.1946666666666666, "HellaSwag": 0.6106666666666666, "MMLU": 0.016, "PIQA": 0.508, "OpenBookQA": 0.1893333333333333, "Winogrande": 0.236 }, "Falcon 2 11B": { "GSM8K": 0.5383, "HellaSwag": 0.7721333333333332, "MMLU": 0.4453333333333333, "Winogrande": 0.5660000000000001 }, "Falcon-180B": { "ARC AI2": 0.5706666666666668, "GSM8K": 0.544, "HellaSwag": 0.8533333333333334, "LAMBADA": 0.798, "MMLU": 0.608, "PIQA": 0.698, "OpenBookQA": 0.5226666666666667, "Winogrande": 0.742 }, "Falcon-40B": { "ARC AI2": 0.4914666666666667, "TriviaQA": 0.799, "BBH": 0.1613333333333333, "GSM8K": 0.338, "HellaSwag": 0.8037333333333333, "LAMBADA": 0.773, "MMLU": 0.4253333333333333, "PIQA": 0.6599999999999999, "OpenBookQA": 0.4213333333333333, "Winogrande": 0.538 }, "Falcon-7B": { "ARC AI2": 0.3048, "TriviaQA": 0.646, "BBH": 0.0502666666666666, "GSM8K": 0.068, "HellaSwag": 0.7080000000000001, "LAMBADA": 0.749, "MMLU": 0.1333333333333333, "PIQA": 0.6060000000000001, "OpenBookQA": 0.3546666666666667, "Winogrande": 0.3440000000000001 }, "Cerebras-GPT-13B": { "ARC AI2": 0.0986666666666666, "HellaSwag": 0.4586666666666666, "MMLU": 0.016, "PIQA": 0.47, "OpenBookQA": 0.144, "Winogrande": 0.2159999999999999 }, "GPT-3.5 Turbo": { "ARC AI2": 0.832, "TriviaQA": 0.858, "GPQA diamond": 0.0404040404040403, "MATH level 5": 0.158893504531722, "WeirdML": 0.0348, "BBH": 0.4878666666666666, "GSM8K": 0.5777, "ANLI": 0.3714999999999999, "MMLU": 0.6186666666666666, "OpenBookQA": 0.8133333333333334, "Winogrande": 0.6319999999999999 }, "GPT-4 (Jun 2023)": { "TriviaQA": 0.848, "GPQA diamond": 0.0753367003367002, "MATH level 5": 0.2297016616314199, "OTIS Mock AIME 2024-2025": 0.0101212323434545, "WeirdML": 0.1244, "BBH": 0.6682666666666667, "GSM8K": 0.8999, "MMLU": 0.7653333333333333 }, "GPT-4 (Mar 2023)": { "GPQA diamond": 0.143097643097643, "OTIS Mock AIME 2024-2025": 0.0045601156712267, "GSM8K": 0.92, "HellaSwag": 0.9373333333333332, "MMLU": 0.8186666666666667, "Winogrande": 0.75 }, "GPT-4 Turbo (Apr 2024)": { "GPQA diamond": 0.2878787878787878, "MATH level 5": 0.467333836858006, "OTIS Mock AIME 2024-2025": 0.0657323990657323, "WeirdML": 0.1801, "SimpleBench": 0.1012, "MMLU": 0.7506666666666666 }, "GPT-4.1": { "GPQA diamond": 0.5589225589225589, "MATH level 5": 0.8300604229607251, "OTIS Mock AIME 2024-2025": 0.382716049382716, "WeirdML": 0.3904, "CadEval": 0.42, "SimpleBench": 0.124, "FrontierMath-2025-02-28-Private": 0.0551724137931034, "Aider polyglot": 0.524, "GeoBench": 0.72, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "ARC-AGI": 0.055, "Fiction.LiveBench": 0.639, "SWE-Bench Verified (Bash Only)": 0.3958 }, "GPT-4.1 mini": { "GPQA diamond": 0.5446127946127945, "MATH level 5": 0.8729229607250756, "OTIS Mock AIME 2024-2025": 0.4466688911133355, "WeirdML": 0.3761, "CadEval": 0.16, "FrontierMath-2025-02-28-Private": 0.0448275862068965, "Aider polyglot": 0.324, "ARC-AGI": 0.035, "Fiction.LiveBench": 0.444, "SWE-Bench Verified (Bash Only)": 0.2394 }, "GPT-4.1 nano": { "GPQA diamond": 0.3190235690235689, "MATH level 5": 0.6999622356495468, "OTIS Mock AIME 2024-2025": 0.2881770659548436, "WeirdML": 0.1898, "FrontierMath-2025-02-28-Private": 0.0103448275862068, "Aider polyglot": 0.089, "ARC-AGI": 0.0, "Fiction.LiveBench": 0.25 }, "GPT-4.5": { "GPQA diamond": 0.5824915824915825, "MATH level 5": 0.7862537764350453, "OTIS Mock AIME 2024-2025": 0.3771549327104882, "WeirdML": 0.3937, "Cybench": 0.175, "SimpleBench": 0.2139999999999999, "Aider polyglot": 0.449, "Lech Mazur Writing": 0.756, "VPCT": 0.45, "ARC-AGI": 0.103, "Fiction.LiveBench": 0.639 }, "GPT-4o (Aug 2024)": { "GPQA diamond": 0.3228114478114477, "MATH level 5": 0.5327605740181269, "OTIS Mock AIME 2024-2025": 0.0629518407296184, "CadEval": 0.26, "SimpleBench": 0.0136, "FrontierMath-2025-02-28-Private": 0.0034482758620689, "Aider polyglot": 0.231, "VideoMME": 0.6253333333333333, "MMLU": 0.7906666666666666 }, "GPT-4o (May 2024)": { "GPQA diamond": 0.3186026936026936, "MATH level 5": 0.5104796072507553, "OTIS Mock AIME 2024-2025": 0.0615615615615615, "ScienceQA": 0.8466666666666667, "Balrog": 0.323, "MMLU": 0.7893333333333333 }, "GPT-4o (Nov 2024)": { "GPQA diamond": 0.3051346801346801, "MATH level 5": 0.4977341389728096, "OTIS Mock AIME 2024-2025": 0.0615615615615615, "WeirdML": 0.2512, "Cybench": 0.125, "FrontierMath-2025-02-28-Private": 0.0034482758620689, "Aider polyglot": 0.182, "GeoBench": 0.71, "Lech Mazur Writing": 0.8180000000000001, "VPCT": 0.4, "GSO-Bench": 0.0, "The Agent Company": 0.086, "ARC-AGI": 0.045, "SWE-Bench Verified (Bash Only)": 0.2162, "MMLU": 0.8413333333333334 }, "GPT-4o mini": { "GPQA diamond": 0.1696127946127945, "MATH level 5": 0.5263406344410876, "OTIS Mock AIME 2024-2025": 0.0685129574018462, "WeirdML": 0.1176, "Aider polyglot": 0.036, "Balrog": 0.174, "GeoBench": 0.64, "Lech Mazur Writing": 0.672, "VideoMME": 0.5306666666666667, "VPCT": 0.34, "GSM8K": 0.913, "MMLU": 0.7573333333333333, "PIQA": 0.774 }, "GPT-5": { "GPQA diamond": 0.8156565656565656, "MATH level 5": 0.9813066465256798, "OTIS Mock AIME 2024-2025": 0.9138026915804692, "WeirdML": 0.607, "SimpleBench": 0.4803999999999999, "FrontierMath-2025-02-28-Private": 0.3241379310344827, "SimpleQA Verified": 0.506, "Aider polyglot": 0.88, "Balrog": 0.328, "GeoBench": 0.81, "Lech Mazur Writing": 0.8723000000000001, "FrontierMath-Tier-4-2025-07-01-Private": 0.125, "VPCT": 0.66, "GSO-Bench": 0.069, "ARC-AGI": 0.657, "DeepResearch Bench": 0.51, "Fiction.LiveBench": 0.972, "SWE-Bench Verified (Bash Only)": 0.65, "Terminal Bench": 0.496, "Chess Puzzles": 0.37 }, "GPT-5 Pro": { "WeirdML": 0.6039, "SimpleBench": 0.5392, "FrontierMath-Tier-4-2025-07-01-Private": 0.125, "ARC-AGI": 0.702 }, "GPT-5 mini": { "GPQA diamond": 0.6666666666666666, "MATH level 5": 0.978474320241692, "OTIS Mock AIME 2024-2025": 0.8665331998665332, "WeirdML": 0.5267, "FrontierMath-2025-02-28-Private": 0.2724137931034482, "SimpleQA Verified": 0.21, "FrontierMath-Tier-4-2025-07-01-Private": 0.0625, "VPCT": 0.402, "Fiction.LiveBench": 0.694, "SWE-Bench Verified (Bash Only)": 0.598, "Terminal Bench": 0.319 }, "GPT-5 nano": { "GPQA diamond": 0.5925925925925926, "MATH level 5": 0.952416918429003, "OTIS Mock AIME 2024-2025": 0.8109220331442554, "WeirdML": 0.3806, "FrontierMath-2025-02-28-Private": 0.0827586206896551, "SimpleQA Verified": 0.122, "FrontierMath-Tier-4-2025-07-01-Private": 0.0208333333333333, "VPCT": 0.372, "Fiction.LiveBench": 0.444, "SWE-Bench Verified (Bash Only)": 0.348, "Terminal Bench": 0.115 }, "GPT-5.1": { "GPQA diamond": 0.8350168350168351, "OTIS Mock AIME 2024-2025": 0.8859971082193304, "WeirdML": 0.6077, "FrontierMath-2025-02-28-Private": 0.3103448275862069, "SimpleQA Verified": 0.489, "FrontierMath-Tier-4-2025-07-01-Private": 0.125, "VPCT": 0.587, "ARC-AGI": 0.728, "Terminal Bench": 0.476, "Chess Puzzles": 0.32 }, "GPT-5.2": { "GPQA diamond": 0.8853333333333334, "OTIS Mock AIME 2024-2025": 0.9610721832944056, "WeirdML": 0.722, "SimpleBench": 0.3495999999999999, "FrontierMath-2025-02-28-Private": 0.407, "SimpleQA Verified": 0.389, "FrontierMath-Tier-4-2025-07-01-Private": 0.292, "VPCT": 0.84, "ARC-AGI": 0.862, "SWE-Bench Verified (Bash Only)": 0.718, "Chess Puzzles": 0.49 }, "Claude 2": { "TriviaQA": 0.875, "GPQA diamond": 0.1287878787878788, "MATH level 5": 0.1172583081570997, "OTIS Mock AIME 2024-2025": 0.024024024024024, "MMLU": 0.7133333333333334 }, "Gemini 1.0 Pro": { "GPQA diamond": 0.1195286195286194, "MATH level 5": 0.1124433534743202, "OTIS Mock AIME 2024-2025": 0.0101212323434545, "MMLU": 0.6 }, "Gemini 1.5 Flash (May 2024)": { "GPQA diamond": 0.2049663299663298, "MATH level 5": 0.2512273413897281, "OTIS Mock AIME 2024-2025": 0.0379268157045933, "VideoMME": 0.604, "GSM8K": 0.824, "MMLU": 0.7053333333333334 }, "Gemini 1.5 Flash (Sep 2024)": { "GPQA diamond": 0.2975589225589225, "MATH level 5": 0.6186744712990937, "OTIS Mock AIME 2024-2025": 0.1616616616616616, "WeirdML": 0.2487, "FrontierMath-2025-02-28-Private": 0.0, "Balrog": 0.146, "GeoBench": 0.76, "MMLU": 0.652, "PIQA": 0.75 }, "Gemini 1.5 Pro": { "GPQA diamond": 0.4297138047138046, "MATH level 5": 0.7039274924471299, "OTIS Mock AIME 2024-2025": 0.2297853408964519, "WeirdML": 0.222, "CadEval": 0.34, "Cybench": 0.075, "SimpleBench": 0.1252, "Balrog": 0.21, "VideoMME": 0.6666666666666666, "The Agent Company": 0.034, "MMLU": 0.8253333333333334 }, "Gemini 2.0 Flash": { "GPQA diamond": 0.521885521885522, "MATH level 5": 0.8216578549848943, "OTIS Mock AIME 2024-2025": 0.3104215326437549, "WeirdML": 0.2577, "CadEval": 0.3, "SimpleBench": 0.1732, "FrontierMath-2025-02-28-Private": 0.0172413793103448, "Aider polyglot": 0.382, "GeoBench": 0.77, "Lech Mazur Writing": 0.7150000000000001, "The Agent Company": 0.114, "Fiction.LiveBench": 0.611, "SWE-Bench Verified (Bash Only)": 0.1352, "MMLU": 0.7293333333333334 }, "Gemini 2.0 Flash Thinking (Jan 2025)": { "GPQA diamond": 0.4276094276094276, "OTIS Mock AIME 2024-2025": 0.5773551329106884, "SimpleBench": 0.1684, "Aider polyglot": 0.182, "Lech Mazur Writing": 0.738, "Fiction.LiveBench": 0.528 }, "Gemini 2.0 Pro": { "GPQA diamond": 0.5420875420875421, "MATH level 5": 0.8345921450151057, "Aider polyglot": 0.356, "Fiction.LiveBench": 0.417 }, "Gemini 2.5 Flash (Apr 2025)": { "OTIS Mock AIME 2024-2025": 0.7302858413969525, "Aider polyglot": 0.471, "GeoBench": 0.73, "Lech Mazur Writing": 0.7650000000000001, "VPCT": 0.38, "ARC-AGI": 0.323, "Fiction.LiveBench": 0.472, "SWE-Bench Verified (Bash Only)": 0.2873 }, "Gemini 2.5 Flash (Jun 2025)": { "SimpleBench": 0.2944, "FrontierMath-2025-02-28-Private": 0.0484429065743944, "Balrog": 0.335, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666 }, "Gemini 2.5 Flash (May 2025)": { "OTIS Mock AIME 2024-2025": 0.7080413747080414, "WeirdML": 0.4095, "Aider polyglot": 0.551, "GeoBench": 0.76, "ARC-AGI": 0.333, "Fiction.LiveBench": 0.778 }, "Claude 2.1": { "GPQA diamond": 0.1060606060606059, "OTIS Mock AIME 2024-2025": 0.0184629073517961, "WeirdML": 0.0706, "MMLU": 0.6466666666666666 }, "Gemini 2.5 Flash (Sep 2025)": { "WeirdML": 0.4191, "VPCT": 0.462, "The Agent Company": 0.411, "Terminal Bench": 0.171 }, "Gemini 2.5 Pro (Jun 2025)": { "GPQA diamond": 0.803872053872054, "OTIS Mock AIME 2024-2025": 0.847069291513736, "WeirdML": 0.5403, "SimpleBench": 0.5488000000000001, "FrontierMath-2025-02-28-Private": 0.1413793103448276, "SimpleQA Verified": 0.56, "Aider polyglot": 0.831, "Lech Mazur Writing": 0.8602000000000001, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.464, "GSO-Bench": 0.039, "ARC-AGI": 0.313, "DeepResearch Bench": 0.428, "Fiction.LiveBench": 0.917, "Terminal Bench": 0.326, "Chess Puzzles": 0.2 }, "Gemini 2.5 Pro (Mar 2025)": { "GPQA diamond": 0.7845117845117845, "MATH level 5": 0.9556268882175226, "CadEval": 0.64, "SimpleBench": 0.4192, "Aider polyglot": 0.7290000000000001, "Balrog": 0.433, "GeoBench": 0.81, "Lech Mazur Writing": 0.8050000000000002, "VPCT": 0.48, "ARC-AGI": 0.33, "Fiction.LiveBench": 0.667 }, "Gemini 2.5 Pro (May 2025)": { "GPQA diamond": 0.5555555555555555, "MATH level 5": 0.959025679758308, "Aider polyglot": 0.7690000000000001, "GeoBench": 0.86, "VPCT": 0.405, "The Agent Company": 0.303, "Fiction.LiveBench": 0.667, "SWE-Bench Verified (Bash Only)": 0.536 }, "Gemini 3 Flash": { "GPQA diamond": 0.7760942760942761, "OTIS Mock AIME 2024-2025": 0.9277054832610389, "FrontierMath-2025-02-28-Private": 0.356401384083045, "SimpleQA Verified": 0.674, "FrontierMath-Tier-4-2025-07-01-Private": 0.0416666666666666, "VPCT": 0.726, "Chess Puzzles": 0.38 }, "Gemini 3 Pro": { "GPQA diamond": 0.9015151515151516, "OTIS Mock AIME 2024-2025": 0.9138026915804692, "WeirdML": 0.6993, "SimpleBench": 0.7168, "FrontierMath-2025-02-28-Private": 0.376, "SimpleQA Verified": 0.729, "GeoBench": 0.84, "FrontierMath-Tier-4-2025-07-01-Private": 0.1875, "VPCT": 0.91, "GSO-Bench": 0.186, "ARC-AGI": 0.75, "SWE-Bench Verified (Bash Only)": 0.742, "Terminal Bench": 0.542, "Chess Puzzles": 0.31 }, "Gemma 2 27B": { "GPQA diamond": 0.1531986531986532, "MATH level 5": 0.2788897280966767, "OTIS Mock AIME 2024-2025": 0.0129017906795683, "MMLU": 0.676 }, "Gemma 2 9B": { "GPQA diamond": 0.0328282828282828, "MATH level 5": 0.2100641993957704, "OTIS Mock AIME 2024-2025": 0.0045601156712267, "GSM8K": 0.849, "MMLU": 0.628, "PIQA": 0.6739999999999999 }, "Gemma 2B": { "ARC AI2": 0.2279999999999999, "TriviaQA": 0.532, "BBH": 0.1359999999999999, "GSM8K": 0.177, "HellaSwag": 0.6186666666666666, "MMLU": 0.2306666666666666, "PIQA": 0.546, "Winogrande": 0.308 }, "Gemma 3 27B": { "GPQA diamond": 0.3181818181818181, "MATH level 5": 0.740370090634441, "OTIS Mock AIME 2024-2025": 0.1964186408630852, "Aider polyglot": 0.049, "GeoBench": 0.52, "Lech Mazur Writing": 0.799, "Fiction.LiveBench": 0.333 }, "Claude 3 Haiku": { "GPQA diamond": 0.1506734006734006, "MATH level 5": 0.1487915407854985, "OTIS Mock AIME 2024-2025": 0.0170726281837392, "WeirdML": 0.0984, "CadEval": 0.12, "ScienceQA": 0.6266666666666666, "MMLU": 0.6506666666666666, "Winogrande": 0.484 }, "Gemma 7B": { "ARC AI2": 0.7106666666666667, "TriviaQA": 0.723, "BBH": 0.4013333333333334, "GSM8K": 0.464, "ANLI": 0.2304999999999999, "HellaSwag": 0.7626666666666666, "MMLU": 0.548, "PIQA": 0.6240000000000001, "OpenBookQA": 0.7146666666666667, "Winogrande": 0.5800000000000001 }, "Grok 3": { "GPQA diamond": 0.6767676767676768, "MATH level 5": 0.8874622356495468, "OTIS Mock AIME 2024-2025": 0.5551106662217774, "WeirdML": 0.3724, "SimpleBench": 0.2332, "FrontierMath-2025-02-28-Private": 0.0379310344827586, "Aider polyglot": 0.533, "Balrog": 0.295, "Lech Mazur Writing": 0.764, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "ARC-AGI": 0.055, "Fiction.LiveBench": 0.583 }, "Grok 4": { "GPQA diamond": 0.8266666666666667, "OTIS Mock AIME 2024-2025": 0.8398398398398398, "WeirdML": 0.4573, "SimpleBench": 0.526, "FrontierMath-2025-02-28-Private": 0.196551724137931, "SimpleQA Verified": 0.479, "Aider polyglot": 0.7959999999999999, "Balrog": 0.436, "GeoBench": 0.45, "Lech Mazur Writing": 0.8068, "FrontierMath-Tier-4-2025-07-01-Private": 0.0208333333333333, "DeepResearch Bench": 0.479, "Fiction.LiveBench": 0.944, "Terminal Bench": 0.272, "Chess Puzzles": 0.3506493506493506 }, "Grok-2": { "GPQA diamond": 0.3838383838383838, "MATH level 5": 0.6351963746223565, "OTIS Mock AIME 2024-2025": 0.1143921699477254, "WeirdML": 0.2224, "SimpleBench": 0.0724, "FrontierMath-2025-02-28-Private": 0.0068965517241379, "Lech Mazur Writing": 0.6360000000000001 }, "Grok-3 mini": { "GPQA diamond": 0.6835016835016835, "MATH level 5": 0.9093655589123868, "OTIS Mock AIME 2024-2025": 0.7775553331108886, "WeirdML": 0.4258, "FrontierMath-2025-02-28-Private": 0.0586206896551724, "SimpleQA Verified": 0.211, "Aider polyglot": 0.493, "Lech Mazur Writing": 0.735, "ARC-AGI": 0.165, "Fiction.LiveBench": 0.667 }, "INTELLECT-1": { "ARC AI2": 0.3936, "BBH": 0.1313333333333333, "GSM8K": 0.3858, "HellaSwag": 0.6189333333333332, "MMLU": 0.3318666666666667, "Winogrande": 0.3164 }, "Kimi K2": { "WeirdML": 0.3936, "SimpleBench": 0.1156, "Aider polyglot": 0.5910000000000001, "Lech Mazur Writing": 0.8729, "GSO-Bench": 0.049, "Fiction.LiveBench": 0.667, "SWE-Bench Verified (Bash Only)": 0.438, "Terminal Bench": 0.278 }, "Kimi K2 Thinking": { "GPQA diamond": 0.7895622895622895, "OTIS Mock AIME 2024-2025": 0.8303859414970527, "WeirdML": 0.4279, "FrontierMath-2025-02-28-Private": 0.2140350877192982, "SimpleQA Verified": 0.316, "FrontierMath-Tier-4-2025-07-01-Private": 0.0, "Terminal Bench": 0.357, "Chess Puzzles": 0.2 }, "Claude 3 Opus": { "GPQA diamond": 0.2954545454545454, "MATH level 5": 0.3748111782477341, "OTIS Mock AIME 2024-2025": 0.0462684907129351, "WeirdML": 0.2318, "Cybench": 0.1, "SimpleBench": 0.0819999999999999, "MMLU": 0.7946666666666666, "Winogrande": 0.77 }, "LLaMA-13B": { "ARC AI2": 0.3693333333333333, "TriviaQA": 0.779, "ScienceQA": 0.2444, "BBH": 0.172, "GSM8K": 0.2055, "HellaSwag": 0.7226666666666667, "LAMBADA": 0.752, "MMLU": 0.3026666666666666, "PIQA": 0.6020000000000001, "OpenBookQA": 0.4186666666666666, "Winogrande": 0.4599999999999999 }, "LLaMA-33B": { "ARC AI2": 0.5666666666666668, "TriviaQA": 0.838, "BBH": 0.3333333333333333, "GSM8K": 0.441, "HellaSwag": 0.7706666666666666, "LAMBADA": 0.772, "MMLU": 0.4493333333333333, "PIQA": 0.6459999999999999, "OpenBookQA": 0.4479999999999999, "Winogrande": 0.52 }, "LLaMA-65B": { "ARC AI2": 0.5933333333333333, "TriviaQA": 0.86, "BBH": 0.4453333333333333, "GSM8K": 0.544, "HellaSwag": 0.7893333333333333, "LAMBADA": 0.777, "MMLU": 0.512, "PIQA": 0.6559999999999999, "OpenBookQA": 0.4693333333333333, "Winogrande": 0.54 }, "LLaMA-7B": { "ARC AI2": 0.3013333333333333, "TriviaQA": 0.71, "ScienceQA": 0.1492, "BBH": 0.1133333333333333, "GSM8K": 0.11, "HellaSwag": 0.6826666666666666, "LAMBADA": 0.733, "MMLU": 0.1413333333333333, "PIQA": 0.5960000000000001, "OpenBookQA": 0.4293333333333333, "Winogrande": 0.4019999999999999 }, "Llama 2-13B": { "ARC AI2": 0.4706666666666666, "TriviaQA": 0.796, "ScienceQA": 0.4103999999999999, "BBH": 0.4426666666666666, "GSM8K": 0.369, "HellaSwag": 0.7426666666666667, "LAMBADA": 0.765, "MMLU": 0.4080000000000001, "PIQA": 0.6160000000000001, "OpenBookQA": 0.4266666666666666, "Winogrande": 0.4559999999999999 }, "Llama 2-34B": { "ARC AI2": 0.3933333333333333, "TriviaQA": 0.846, "BBH": 0.2546666666666666, "GSM8K": 0.422, "MMLU": 0.5013333333333333, "PIQA": 0.6379999999999999, "OpenBookQA": 0.4426666666666666, "Winogrande": 0.534 }, "Llama 2-70B": { "ARC AI2": 0.7106666666666667, "TriviaQA": 0.876, "GPQA diamond": 0.0176767676767675, "MATH level 5": 0.0328549848942598, "BBH": 0.532, "GSM8K": 0.696, "HellaSwag": 0.8039999999999999, "LAMBADA": 0.789, "MMLU": 0.5986666666666666, "PIQA": 0.6559999999999999, "OpenBookQA": 0.4693333333333333, "Winogrande": 0.6040000000000001 }, "Llama 2-7B": { "ARC AI2": 0.2786666666666667, "TriviaQA": 0.737, "ScienceQA": 0.2410666666666666, "BBH": 0.1888, "GSM8K": 0.167, "HellaSwag": 0.6960000000000001, "LAMBADA": 0.733, "MMLU": 0.2773333333333334, "PIQA": 0.5760000000000001, "OpenBookQA": 0.4479999999999999, "Winogrande": 0.3839999999999999 }, "Llama 3-70B": { "GPQA diamond": 0.2074915824915824, "MATH level 5": 0.225547583081571, "OTIS Mock AIME 2024-2025": 0.0420976532087642, "Cybench": 0.05, "MMLU": 0.7240000000000001, "OpenBookQA": 0.3013333333333333, "Winogrande": 0.6699999999999999 }, "Llama 3-8B": { "ARC AI2": 0.7706666666666666, "TriviaQA": 0.677, "GPQA diamond": 0.0143097643097642, "MATH level 5": 0.0612726586102719, "OTIS Mock AIME 2024-2025": 0.0073406740073406, "ANLI": 0.3594999999999999, "MMLU": 0.584, "OpenBookQA": 0.7679999999999999, "Winogrande": 0.514 } } };
    </script>
    <script>
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            const status = document.getElementById('status-text');
            if (status) {
                status.innerText = `Error: ${msg} at line ${lineNo}`;
                status.classList.add('text-red-600', 'font-bold');
            }
            alert(`Application Error: ${msg}\nLine: ${lineNo}`);
            return false;
        };

        if (typeof RAW_DATA === 'undefined') {
            document.write('<div class="p-4 bg-red-100 text-red-700 font-bold">FATAL ERROR: Data failed to load. Check RAW_DATA syntax.</div>');
            throw new Error("RAW_DATA is missing");
        }
    </script>

    <!-- App Logic -->
    <script>
        const CONFIG = {
            anchor_eci_low: 130,
            anchor_eci_high: 150,
            anchor_model_low: "Claude 3.5 Sonnet",
            anchor_model_high: "GPT-5"
        };

        // State
        const state = {
            selectedBenchmarks: new Set(),
            viewedDomain: 'All',
            searchTerm: '',
            mode: 'fixed', // 'fixed', 'refit', 'compare'
            view: 'chart', // 'chart', 'table'
            models: [], // Computed capabilities
            cachedRefit: null,
            minBenchmarks: 2,
            showCI: false,
            showBreakpoint: false,
            useStdScale: false
        };

        const DOMAIN_MAP = {
            "ARC AI2": "Reasoning", "BBH": "Reasoning", "GSM8K": "Math", "HellaSwag": "Reasoning",
            "LAMBADA": "Other", "MMLU": "Knowledge", "GPQA diamond": "Knowledge", "MATH level 5": "Math",
            "OTIS Mock AIME 2024-2025": "Math", "WeirdML": "Coding", "Winogrande": "Reasoning",
            "TriviaQA": "Knowledge", "Cybench": "Cyber", "SimpleBench": "Reasoning", "The Agent Company": "Agent",
            "PIQA": "Reasoning", "OpenBookQA": "Reasoning", "Balrog": "Agent", "GeoBench": "Vision",
            "Fiction.LiveBench": "Writing", "FrontierMath-2025-02-28-Private": "Math", "Aider polyglot": "Coding",
            "Lech Mazur Writing": "Writing", "ARC-AGI": "Reasoning", "SWE-Bench Verified (Bash Only)": "Coding",
            "CadEval": "Coding", "SimpleQA Verified": "Knowledge", "ANLI": "Reasoning",
            "FrontierMath-Tier-4-2025-07-01-Private": "Math", "VideoMME": "Vision", "VPCT": "Vision",
            "OSWorld": "Agent", "GSO-Bench": "Coding", "Chess Puzzles": "Reasoning",
            "Terminal Bench": "Agent", "DeepResearch Bench": "Agent", "ScienceQA": "Knowledge"
        };

        const DOMAIN_COLORS = {
            "Reasoning": "blue", "Math": "amber", "Knowledge": "purple", "Coding": "emerald",
            "Agent": "rose", "Writing": "indigo", "Cyber": "slate", "Vision": "orange", "Other": "gray"
        };

        const ORG_COLORS = {
            'OpenAI': '#10a37f',
            'Anthropic': '#d97757',
            'Google': '#4285F4',
            'Meta': '#0668E1',
            'Microsoft': '#F25022',
            'Mistral': '#f59e0b',
            'DeepSeek': '#0ea5e9',
            'Alibaba': '#8b5cf6',
            'xAI': '#111827',
            '01.AI': '#059669',
            'TII': '#57534e',
            'Baichuan': '#db2777',
            'NVIDIA': '#76b900',
            'Other': '#9ca3af'
        };

        function getOrganization(name) {
            const n = name.toLowerCase();
            if (n.includes('gpt') || n.includes('o1') || n.includes('o3') || n.includes('o4')) return 'OpenAI';
            if (n.includes('claude')) return 'Anthropic';
            if (n.includes('gemini') || n.includes('gemma')) return 'Google';
            if (n.includes('llama')) return 'Meta';
            if (n.includes('mistral') || n.includes('mixtral')) return 'Mistral';
            if (n.includes('qwen')) return 'Alibaba';
            if (n.includes('deepseek')) return 'DeepSeek';
            if (n.includes('yi ')) return '01.AI';
            if (n.includes('phi')) return 'Microsoft';
            if (n.includes('grok')) return 'xAI';
            if (n.includes('nemotron')) return 'NVIDIA';
            if (n.includes('falcon')) return 'TII';
            if (n.includes('baichuan')) return 'Baichuan';
            return 'Other';
        }

        // Inject domain data into RAW_DATA
        if (typeof RAW_DATA !== 'undefined' && RAW_DATA.benchmarks) {
            Object.keys(RAW_DATA.benchmarks).forEach(id => {
                RAW_DATA.benchmarks[id].domain = DOMAIN_MAP[id] || "Other";
            });
        }

        function calculateBootstrapCI(performances, diffs, discs, scaling = { a: 0, b: 1 }, n_boot = 1000) {
            if (performances.length < 2) return { low: null, high: null };

            const thetas = [];
            // Optimization: Use a simpler solver or initial guess for speed? 
            // For now, use standard solveFixed but maybe with fewer steps or robust logic.

            for (let i = 0; i < n_boot; i++) {
                const res_perfs = [];
                const res_diffs = [];
                const res_discs = [];
                for (let j = 0; j < performances.length; j++) {
                    const idx = Math.floor(Math.random() * performances.length);
                    res_perfs.push(performances[idx]);
                    res_diffs.push(diffs[idx]);
                    res_discs.push(discs[idx]);
                }

                // Add jitter to avoid identical resamples collapsing in rare cases (optional but good for stability)
                let theta = solveFixed(res_perfs, res_diffs, res_discs);

                // Apply scaling if provided (Refit mode) is typically A + B*theta
                // For Fixed mode, scaling is A=0, B=1 (no-op)
                theta = scaling.a + scaling.b * theta;

                thetas.push(theta);
            }

            thetas.sort((a, b) => a - b);
            const low = thetas[Math.floor(n_boot * 0.05)];
            const high = thetas[Math.floor(n_boot * 0.95)];

            return { low, high };
        }

        // --- Core Math: Sigmoid ---
        function sigmoid(x) {
            // Clip to avoid overflow/underflow
            const xc = Math.max(-100, Math.min(100, x));
            return 1.0 / (1.0 + Math.exp(-xc));
        }

        // --- IRT: Fixed Parameters Solver ---
        function solveFixed(performances, diffs, discs) {
            // Objective: Minimize sum((pred - obs)^2)
            // Using Coarse-to-Fine Grid Search for absolute stability (1D optimization)

            function getLoss(t) {
                let loss = 0;
                for (let j = 0; j < performances.length; j++) {
                    const logit = discs[j] * (t - diffs[j]);
                    const pred = sigmoid(logit);
                    const err = pred - performances[j];
                    loss += err * err;
                }
                return loss;
            }

            // 1. Coarse Search (50 to 200, step 5)
            let bestTheta = 100;
            let minLoss = Infinity;

            for (let t = 50; t <= 200; t += 5) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 2. Fine Search (5, step 0.5)
            let start = Math.max(50, bestTheta - 5);
            let end = Math.min(200, bestTheta + 5);
            for (let t = start; t <= end; t += 0.5) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 3. Super Fine Search (0.5, step 0.05)
            start = Math.max(50, bestTheta - 0.5);
            end = Math.min(200, bestTheta + 0.5);
            for (let t = start; t <= end; t += 0.05) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 4. Ultra Fine (Gradient Descent refinement)
            // Just a few steps to polish the float value
            let theta = bestTheta;
            for (let k = 0; k < 5; k++) {
                let grad = 0;
                for (let j = 0; j < performances.length; j++) {
                    const logit = discs[j] * (theta - diffs[j]);
                    const pred = sigmoid(logit);
                    grad += 2 * (pred - performances[j]) * pred * (1 - pred) * discs[j];
                }
                theta -= 0.1 * grad; // Small cautious steps
            }

            return theta;
        }

        // --- IRT: Refit Solver (JMLE) ---
        async function solveJMLE(activeBenchmarkIds, minBenchmarks) {
            // Prepare data structure: sparse matrix logic
            // We need: for each model, list of (benchmark_idx, score)
            //          for each benchmark, list of (model_idx, score)

            const allModels = Object.keys(RAW_DATA.models);
            const benchmarks = Array.from(activeBenchmarkIds);

            if (benchmarks.length === 0) return {};

            // Pre-process links for fast iteration
            const modelData = {}; // model -> [{b_id, p}]
            allModels.forEach(m => modelData[m] = []);

            const benchData = {}; // bench -> [{m_id, p}]
            benchmarks.forEach(b => benchData[b] = []);

            let totalObsCount = 0;
            allModels.forEach(m => {
                if (RAW_DATA.performances[m]) {
                    benchmarks.forEach(b => {
                        if (RAW_DATA.performances[m][b] !== undefined) {
                            const p = RAW_DATA.performances[m][b];
                            modelData[m].push({ b, p });
                            benchData[b].push({ m, p });
                            totalObsCount++;
                        }
                    });
                }
            });

            // Filter models by minimum benchmarks
            console.log("Filtering: Total Models:", allModels.length, "MinBenchmarks:", minBenchmarks);
            // Debug how many benchmarks each model has
            // const debug counts = allModels.map(m => modelData[m].length);
            // console.log("Distribution:", counts.slice(0, 20));

            const models = allModels.filter(m => modelData[m].length >= (minBenchmarks || 1));
            console.log("Models after filtering:", models.length);

            if (models.length === 0) return {};

            try {
                // Init parameters
                const SHIFT = 100.0;
                let ability = {};
                models.forEach(m => ability[m] = 0.0);

                let difficulty = {};
                let discriminability = {};

                benchmarks.forEach(b => {
                    difficulty[b] = 0.0;
                    discriminability[b] = 1.0;
                });

                console.log(`Fitting JMLE on ${models.length} filtered models...`);

                const iterations = 100;
                const lr = 2.0;
                const nParams = models.length + benchmarks.length + benchmarks.length;
                const regStrength = 0.1;
                const regLambda = regStrength / nParams;

                for (let iter = 0; iter < iterations; iter++) {
                    // 1. Optimize Abilities
                    models.forEach(m => {
                        const obs = modelData[m];
                        if (obs.length === 0) return;

                        let theta = ability[m];
                        for (let k = 0; k < 5; k++) {
                            let grad = 0;
                            let w_sum = 0;
                            obs.forEach(o => {
                                const d = difficulty[o.b];
                                const a = discriminability[o.b];
                                const logit = a * (theta - d);
                                const pred = sigmoid(logit);
                                const w = pred * (1 - pred);
                                grad += 2 * (pred - o.p) * w * a;
                                w_sum += 2 * w * a * a;
                            });
                            grad += 2 * regLambda * theta;
                            w_sum += 2 * regLambda;
                            if (w_sum > 1e-9) theta -= grad / (w_sum + 1e-9);
                            else theta -= lr * grad;
                        }
                        ability[m] = Math.max(-100, Math.min(100, theta));
                    });

                    // 2. Optimize Item Params
                    benchmarks.forEach(b => {
                        const obs = benchData[b];
                        if (obs.length === 0) return;
                        let d = difficulty[b];
                        let a = discriminability[b];
                        for (let k = 0; k < 5; k++) {
                            let d_grad = 0, d_hess = 0, a_grad = 0, a_hess = 0;
                            obs.forEach(o => {
                                if (ability[o.m] === undefined) return;
                                const theta = ability[o.m];
                                const logit = a * (theta - d);
                                const pred = sigmoid(logit);
                                const err = pred - o.p;
                                const w = pred * (1 - pred);
                                d_grad += 2 * err * w * (-a);
                                d_hess += 2 * w * a * a;
                                const term = (theta - d);
                                a_grad += 2 * err * w * term;
                                a_hess += 2 * w * term * term;
                            });
                            d_grad += 2 * regLambda * d;
                            d_hess += 2 * regLambda;
                            a_grad += 2 * regLambda * a;
                            a_hess += 2 * regLambda;
                            if (d_hess > 1e-9) d -= d_grad / (d_hess + 1e-9); else d -= lr * d_grad;
                            if (a_hess > 1e-9) a -= a_grad / (a_hess + 1e-9); else a -= (lr * 0.1) * a_grad;
                            a = Math.max(0.1, Math.min(5.0, a));
                        }
                        difficulty[b] = Math.max(-100, Math.min(100, d));
                        discriminability[b] = a;
                    });

                    if (iter % 20 === 0) await new Promise(r => setTimeout(r, 0));
                }

                // UN-SHIFT parameters
                models.forEach(m => ability[m] += SHIFT);
                benchmarks.forEach(b => difficulty[b] += SHIFT);

                // --- Final Scale Alignment (Anchor Method) ---
                // Hardcoded to avoid ReferenceErrors
                const ANCHOR_LOW_ID = "Claude 3.5 Sonnet";
                const ANCHOR_HIGH_ID = "GPT-5";
                const TARGET_LOW = 130.0;
                const TARGET_HIGH = 150.0;

                let finalA = 0;
                let finalB = 1;

                function performPopulationNorm() {
                    let sum = 0, sqSum = 0, n = 0;
                    models.forEach(m => {
                        const val = ability[m];
                        if (val !== undefined) { sum += val; sqSum += val * val; n++; }
                    });
                    if (n < 2) return;
                    const mean = sum / n;
                    const std = Math.sqrt(sqSum / n - mean * mean);
                    // Target Mean=100, SD=15
                    finalB = 15.0 / (std + 1e-9);
                    finalA = 100.0 - finalB * mean;
                    console.log(`Fallback: Pop Norm Mean=${mean.toFixed(2)} SD=${std.toFixed(2)}`);
                }

                if (state.useStdScale) {
                    if (ability[ANCHOR_LOW_ID] !== undefined && ability[ANCHOR_HIGH_ID] !== undefined) {
                        const tLow = ability[ANCHOR_LOW_ID];
                        const tHigh = ability[ANCHOR_HIGH_ID];
                        const rawDiff = tHigh - tLow;
                        const targetDiff = TARGET_HIGH - TARGET_LOW;

                        // Compute slope
                        finalB = targetDiff / rawDiff;
                        // Compute intercept: Target = A + B * Raw
                        // A = Target - B * Raw
                        finalA = TARGET_LOW - finalB * tLow;

                        console.log(`Anchors: Low(${tLow.toFixed(2)}->${TARGET_LOW}), High(${tHigh.toFixed(2)}->${TARGET_HIGH})`);
                        console.log(`Params: A=${finalA.toFixed(2)}, B=${finalB.toFixed(2)}`);

                        if (Math.abs(rawDiff) < 1.0 || finalB < 0) {
                            console.warn("Anchors degenerate. Fallback.");
                            performPopulationNorm();
                        }
                    } else {
                        console.warn("Anchors missing. Fallback.");
                        performPopulationNorm();
                    }
                } else {
                    // Default behavior: Population Norm
                    performPopulationNorm();
                }

                // Apply Match
                models.forEach(m => {
                    if (ability[m] !== undefined) ability[m] = finalA + finalB * ability[m];
                });

                return { ability, difficulty, discriminability, scaling: { a: finalA, b: finalB } };

            } catch (e) {
                console.error("JMLE Failed:", e);
                // Return empty to avoid crash
                return {};
            }
        }

        // --- Breakpoint Analysis Logic ---

        function linearRegression(points) {
            const n = points.length;
            if (n < 2) return null;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumXY += p.x * p.y;
                sumXX += p.x * p.x;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            let rss = 0;
            points.forEach(p => {
                const pred = slope * p.x + intercept;
                rss += (p.y - pred) ** 2;
            });

            return { slope, intercept, rss, n, k: 2 };
        }

        function calculateBIC(n, k, rss) {
            if (rss <= 0) return -Infinity;
            return n * Math.log(rss / n) + k * Math.log(n);
        }

        function solveConstrained(points, x_bp) {
            const n = points.length;
            let s_u = 0, s_v = 0, s_y = 0;
            let s_uu = 0, s_uv = 0, s_uy = 0;
            let s_vv = 0, s_vy = 0;

            for (let i = 0; i < n; i++) {
                const u = points[i].x - x_bp;
                const v = Math.max(0, u);
                const y = points[i].y;

                s_u += u; s_v += v; s_y += y;
                s_uu += u * u; s_uv += u * v; s_uy += u * y;
                s_vv += v * v; s_vy += v * y;
            }

            // Normal Equations for 3 variables: y = A + B*u + C*v
            // Matrix M
            const M00 = n, M01 = s_u, M02 = s_v;
            const M10 = s_u, M11 = s_uu, M12 = s_uv;
            const M20 = s_v, M21 = s_uv, M22 = s_vv;

            const R0 = s_y, R1 = s_uy, R2 = s_vy;

            const det = M00 * (M11 * M22 - M12 * M21) -
                        M01 * (M10 * M22 - M12 * M20) +
                        M02 * (M10 * M21 - M11 * M20);

            if (Math.abs(det) < 1e-9) return null;

            const invDet = 1.0 / det;

            const A = invDet * (R0 * (M11 * M22 - M12 * M21) + R1 * (M02 * M21 - M01 * M22) + R2 * (M01 * M12 - M02 * M11));
            const B = invDet * (R0 * (M12 * M20 - M10 * M22) + R1 * (M00 * M22 - M02 * M20) + R2 * (M10 * M02 - M00 * M12));
            const C = invDet * (R0 * (M10 * M21 - M11 * M20) + R1 * (M01 * M20 - M00 * M21) + R2 * (M00 * M11 - M01 * M10));

            // Parameters
            const slope1 = B;
            const slope2 = B + C;
            const intercept1 = A - B * x_bp;
            const intercept2 = A - (B + C) * x_bp;

            let rss = 0;
            for (let i = 0; i < n; i++) {
                const u = points[i].x - x_bp;
                const v = Math.max(0, u);
                const pred = A + B * u + C * v;
                rss += (points[i].y - pred) ** 2;
            }

            return {
                intercept1, slope1,
                intercept2, slope2,
                rss,
                k: 4 // 3 coeffs + 1 breakpoint parameter
            };
        }

        function breakpointRegression(points) {
            const n = points.length;
            if (n < 6) return null;

            points.sort((a, b) => a.x - b.x);
            let best = { rss: Infinity };
            const minPoints = 3;

            for (let i = minPoints; i < n - minPoints; i++) {
                const candidateX = points[i].x;
                const fit = solveConstrained(points, candidateX);
                if (fit && fit.rss < best.rss) {
                    best = { ...fit, splitX: candidateX, splitIndex: i };
                }
            }
            return best.rss === Infinity ? null : best;
        }

        function getFrontier(points) {
            if (points.length === 0) return [];
            // Sort by x (date)
            // Shallow copy to avoid mutating original if needed, though sort is in-place
            const sorted = [...points].sort((a, b) => a.x - b.x);

            const frontier = [];
            let maxVal = -Infinity;

            sorted.forEach(p => {
                if (p.y > maxVal) {
                    frontier.push(p);
                    maxVal = p.y;
                }
            });
            return frontier;
        }

        function bootstrapFrontier(allPoints, n_boot = 1000) {
            const splitDates = [];

            for (let b = 0; b < n_boot; b++) {
                // Pairs Bootstrap: Resample full dataset
                const sample = [];
                for(let i=0; i<allPoints.length; i++) {
                    sample.push(allPoints[Math.floor(Math.random() * allPoints.length)]);
                }

                // Compute Frontier of Sample
                const frontier = getFrontier(sample);

                // Ensure enough points on frontier to fit
                if (frontier.length >= 6) {
                    const res = breakpointRegression(frontier);
                    if (res) splitDates.push(res.splitX);
                }
            }

            if (splitDates.length === 0) return null;
            splitDates.sort((a, b) => a - b);
            const low = splitDates[Math.floor(splitDates.length * 0.05)];
            const high = splitDates[Math.floor(splitDates.length * 0.95)];

            return { low, high, median: splitDates[Math.floor(splitDates.length * 0.5)] };
        }

        // --- UI Rendering ---

        function renderBenchmarkList() {
            const list = document.getElementById('benchmark-list');
            const term = state.searchTerm.toLowerCase();
            const viewed = state.viewedDomain;

            const filtered = Object.entries(RAW_DATA.benchmarks).filter(([id, b]) => {
                const matchesSearch = b.name.toLowerCase().includes(term);
                const matchesDomain = (viewed === 'All' || b.domain === viewed);
                return matchesSearch && matchesDomain;
            }).sort((a, b) => a[1].name.localeCompare(b[1].name));

            list.innerHTML = '';
            filtered.forEach(([id, meta]) => {
                const isSelected = state.selectedBenchmarks.has(id);
                const color = DOMAIN_COLORS[meta.domain] || 'gray';

                const div = document.createElement('div');
                div.className = `group flex items-center p-2.5 rounded-xl border filter-transition cursor-pointer ${isSelected ? 'border-indigo-200 bg-indigo-50/50 shadow-sm' : 'border-transparent hover:border-gray-100 hover:bg-gray-50'}`;
                div.innerHTML = `
                    <div class="flex-shrink-0 mr-3">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} class="w-4 h-4 rounded text-indigo-600 focus:ring-indigo-500 border-gray-300 pointer-events-none transition-all">
                    </div>
                    <div class="min-w-0 flex-1">
                        <div class="text-sm font-medium ${isSelected ? 'text-indigo-900' : 'text-gray-700'} truncate">${meta.name}</div>
                        <div class="flex items-center gap-2 mt-0.5">
                            <span class="text-[9px] font-bold uppercase tracking-wider text-${color}-600 bg-${color}-50 px-1.5 py-0.5 rounded-md border border-${color}-100">${meta.domain}</span>
                        </div>
                    </div>
                `;

                div.addEventListener('click', () => {
                    if (state.selectedBenchmarks.has(id)) state.selectedBenchmarks.delete(id);
                    else state.selectedBenchmarks.add(id);
                    renderSelectedBenchmarkTags();
                    renderBenchmarkList();
                    updateChart();
                });

                list.appendChild(div);
            });

            updateCount();
        }

        function renderDomainFilters() {
            const selector = document.getElementById('domain-selector');
            if (!selector) return;

            if (typeof RAW_DATA === 'undefined' || !RAW_DATA.benchmarks) {
                selector.innerHTML = '<option>Data Error</option>';
                return;
            }

            const domains = ['All', ...[...new Set(Object.values(DOMAIN_MAP))].sort()];

            selector.innerHTML = '';
            domains.forEach(domain => {
                const count = domain === 'All'
                    ? Object.keys(RAW_DATA.benchmarks).length
                    : Object.values(RAW_DATA.benchmarks).filter(b => b.domain === domain).length;

                const option = document.createElement('option');
                option.value = domain;
                option.text = `${domain} (${count})`;
                option.selected = state.viewedDomain === domain;
                selector.appendChild(option);
            });
        }

        function renderSelectedBenchmarkTags() {
            const container = document.getElementById('active-filters-container');
            const tagArea = document.getElementById('active-filters');
            const resetBtn = document.getElementById('clear-domains');

            if (state.selectedBenchmarks.size === 0) {
                container.classList.add('hidden');
                resetBtn.classList.add('hidden');
                return;
            }

            container.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
            resetBtn.innerText = "CLEAR ALL";

            tagArea.innerHTML = '';

            const selectedIds = Array.from(state.selectedBenchmarks).sort((a, b) => {
                return RAW_DATA.benchmarks[a].name.localeCompare(RAW_DATA.benchmarks[b].name);
            });

            selectedIds.forEach(id => {
                const meta = RAW_DATA.benchmarks[id];
                const domainColor = DOMAIN_COLORS[meta.domain] || 'gray';

                const tag = document.createElement('div');
                tag.className = `flex items-center px-2 py-0.5 rounded-md bg-${domainColor}-100 text-${domainColor}-700 text-[10px] font-bold border border-${domainColor}-200 transition-all hover:bg-${domainColor}-200 cursor-pointer shadow-sm mb-1`;
                tag.innerHTML = `
                    <span class="truncate max-w-[120px]">${meta.name}</span>
                    <svg class="w-3 h-3 ml-1 opacity-60 hover:opacity-100 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                `;

                tag.onclick = (e) => {
                    e.stopPropagation();
                    state.selectedBenchmarks.delete(id);
                    renderSelectedBenchmarkTags();
                    renderBenchmarkList();
                    updateChart();
                };
                tagArea.appendChild(tag);
            });
        }

        function updateCount() {
            const activeBenchmarksCount = state.selectedBenchmarks.size;
            const countEl = document.getElementById('benchmark-count');
            if (countEl) countEl.innerText = `${activeBenchmarksCount}/${Object.keys(RAW_DATA.benchmarks).length}`;
        }

        // --- Smart Label Placement ---
        function selectNonOverlappingLabels(points, xDomain, yDomain, isMobile) {
            // points: Array of { id, x, y, count, name }
            // xDomain: [min, max]
            // yDomain: [min, max]

            const xSpan = xDomain[1] - xDomain[0] || 1;
            const ySpan = yDomain[1] - yDomain[0] || 1;

            const norm = p => ({
                ...p,
                nx: (p.x - xDomain[0]) / xSpan,
                ny: (p.y - yDomain[0]) / ySpan,
                charLen: (p.name || '').length
            });

            // Priorities: High benchmark count first
            const normPoints = points.map(norm).sort((a, b) => b.count - a.count);

            const placedLabels = []; // {l, r, t, b}
            const results = new Map(); // id -> textposition

            // Heuristic dimensions in normalized coordinates (0..1)
            // Point radius (approximate circular dominance)
            const pr = 0.01;
            const pointBoxes = normPoints.map(p => ({
                l: p.nx - pr, r: p.nx + pr,
                b: p.ny - pr, t: p.ny + pr
            }));

            // Label dimensions
            const charWidth = isMobile ? 0.02 : 0.007; // Approx width per char normalized
            const labelHeight = isMobile ? 0.06 : 0.04;
            const offset = 0.015;

            // Positions to try in order of preference
            const positions = [
                { name: 'top center', dx: 0, dy: 1 },
                { name: 'bottom center', dx: 0, dy: -1 },
                { name: 'middle right', dx: 1, dy: 0 },
                { name: 'middle left', dx: -1, dy: 0 },
                { name: 'top right', dx: 1, dy: 1 },
                { name: 'top left', dx: -1, dy: 1 },
                { name: 'bottom right', dx: 1, dy: -1 },
                { name: 'bottom left', dx: -1, dy: -1 }
            ];

            const intersect = (r1, r2) => {
                return !(r2.l > r1.r || r2.r < r1.l || r2.t < r1.b || r2.b > r1.t);
            };

            for (const p of normPoints) {
                // Estimate label width based on char length
                // Min width 0.04 to avoid tiny boxes for short names
                const w = Math.max(0.04, p.charLen * charWidth);
                const h = labelHeight;

                for (const pos of positions) {
                    let l, r, b, t;

                    // Calculate box based on position relative to point (nx, ny)
                    if (pos.name.includes('top')) {
                        b = p.ny + offset;
                        t = b + h;
                    } else if (pos.name.includes('bottom')) {
                        t = p.ny - offset;
                        b = t - h;
                    } else {
                        // middle
                        b = p.ny - h / 2;
                        t = p.ny + h / 2;
                    }

                    if (pos.name.includes('right')) {
                        l = p.nx + offset;
                        r = l + w;
                    } else if (pos.name.includes('left')) {
                        r = p.nx - offset;
                        l = r - w;
                    } else {
                        // center
                        l = p.nx - w / 2;
                        r = p.nx + w / 2;
                    }

                    const box = { l, r, b, t };

                    // Collision Check
                    let collision = false;

                    // 0. Boundary Check
                    // If label goes outside the chart area (0-1), discard this position.
                    // If all positions fail, the label is not placed (hidden).
                    if (box.l < 0 || box.r > 1 || box.b < 0 || box.t > 1) {
                        collision = true;
                        // Do not continue inner loop here, checking bounds is fatal for this position
                    }

                    if (!collision) {
                        // 1. Check against accepted labels
                        for (const other of placedLabels) {
                            if (intersect(box, other)) { collision = true; break; }
                        }
                    }

                    if (!collision) {
                        // 2. Check against ALL points
                        // We must avoid covering any point, including our own (though offsets usually handle own)
                        for (const pb of pointBoxes) {
                            if (intersect(box, pb)) { collision = true; break; }
                        }
                    }

                    if (collision) continue;

                    // Accepted
                    placedLabels.push(box);
                    results.set(p.id, pos.name);
                    break; // Stop trying positions for this point
                }
            }

            return results;
        }

        // --- Processing & Rendering ---

        function renderTable(points, mode) {
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            const isMobile = window.innerWidth < 1024;

            tableBody.innerHTML = '';
            tableHeader.innerHTML = '';

            let headers = [];
            if (mode === 'compare') {
                headers = ['Model', 'Date', 'Fixed ECI', 'Refit ECI', 'Benchmarks Count'];
            } else if (mode === 'rank-compare') {
                headers = ['Model', 'Date', 'Fixed Rank', 'Refit Rank', 'Benchmarks Count'];
            } else {
                headers = ['Model', 'Date', 'ECI', 'Benchmarks Count'];
            }

            const cellPadding = isMobile ? "px-2 py-2" : "px-6 py-4";
            const headerPadding = isMobile ? "px-2 py-3" : "px-6 py-3";
            const fontSize = isMobile ? "text-xs" : "text-sm";

            headers.forEach(h => {
                if (isMobile) {
                    if (h === 'Benchmarks Count') h = 'Count';
                    if (h === 'Fixed ECI') h = 'Fixed';
                    if (h === 'Refit ECI') h = 'Refit';
                }
                const th = document.createElement('th');
                th.className = `${headerPadding} text-left text-xs font-bold text-gray-500 uppercase tracking-wider`;
                th.innerText = h;
                tableHeader.appendChild(th);
            });

            // Helper to format CI
            const fmtCI = (val, ci) => {
                if (val === undefined || val === null) return '-';
                let s = val.toFixed(2);
                if (ci && ci.low !== null && ci.high !== null) {
                    s += ` <span class="text-[10px] text-gray-400">[${ci.low.toFixed(2)}, ${ci.high.toFixed(2)}]</span>`;
                }
                return s;
            };

            // Sort by Date descending (newest first) usually better for table?
            const pointsWithDate = points.map(p => {
                 const m = RAW_DATA.models[p.id];
                 return { ...p, dateStr: m ? m.date : (p.dateStr || '-') };
            });

            pointsWithDate.sort((a, b) => new Date(b.dateStr) - new Date(a.dateStr));

            pointsWithDate.forEach(p => {
                const tr = document.createElement('tr');
                tr.className = `hover:bg-gray-50 transition-colors ${fontSize}`;

                const modelClass = isMobile
                    ? `${cellPadding} font-medium text-gray-900 max-w-[120px] truncate cursor-pointer`
                    : `${cellPadding} whitespace-nowrap font-medium text-gray-900`;

                const modelClick = isMobile ? 'onclick="this.classList.toggle(\'truncate\')"' : '';

                let rowHTML = `
                    <td class="${modelClass}" ${modelClick}>${p.name}</td>
                    <td class="${cellPadding} whitespace-nowrap text-gray-500">${p.dateStr}</td>
                `;

                if (mode === 'compare') {
                    // p.x is Fixed, p.y is Refit
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.x, p.ciFixed)}</td>
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.y, p.ciRefit)}</td>
                    `;
                } else if (mode === 'rank-compare') {
                    // p.x is Fixed Rank, p.y is Refit Rank
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${p.x}</td>
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${p.y}</td>
                    `;
                } else {
                    // p.y is ECI
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.y, p.ci)}</td>
                    `;
                }

                rowHTML += `<td class="${cellPadding} whitespace-nowrap text-gray-500 text-center">${p.count}</td>`;
                tr.innerHTML = rowHTML;
                tableBody.appendChild(tr);
            });
        }

        async function updateChart() {
            const status = document.getElementById('status-text');
            const loader = document.getElementById('loading-overlay');
            const activeBenchmarks = Array.from(state.selectedBenchmarks);

            updateCount();

            if (activeBenchmarks.length === 0) {
                Plotly.purge('chart-container');
                if (state.view === 'table') {
                    renderTable([], state.mode);
                }
                status.innerText = "Select at least one benchmark.";
                return;
            }

            try {
                const plotData = [];
                const isMobile = window.innerWidth < 1024;
                let layout = {
                    title: {
                        text: isMobile ? undefined : 'Model Capability (ECI) over Time',
                        font: { family: 'Inter', size: 22, weight: 900, color: '#111827' }
                    },
                    xaxis: { title: { text: 'Release Date', font: { weight: 600 } }, gridcolor: '#f3f4f6', zeroline: false, automargin: true, fixedrange: isMobile },
                    yaxis: { title: { text: 'Domain-specific ECI', font: { weight: 600 } }, gridcolor: '#f3f4f6', zeroline: false, automargin: true, fixedrange: isMobile },
                    hovermode: 'closest',
                    template: 'plotly_white',
                    margin: isMobile ? { t: 20, r: 40, l: 40, b: 40 } : { t: 90, r: 50, l: 80, b: 100 },
                    showlegend: !isMobile,
                    legend: {
                        orientation: 'h',
                        y: -0.15,
                        x: 0.5,
                        xanchor: 'center',
                        font: { size: 13, weight: 500 }
                    },
                    font: { family: 'Inter, sans-serif' }
                };

                // Helper to get top models for labeling (prioritize models with data)
                const getTopModelIds = (limit = 20) => {
                    return Object.keys(RAW_DATA.models)
                        .map(id => ({
                            id,
                            count: Object.keys(RAW_DATA.performances[id] || {}).filter(b => activeBenchmarks.includes(b)).length
                        }))
                        .filter(x => x.count >= state.minBenchmarks)
                        .sort((a, b) => b.count - a.count)
                        .slice(0, limit)
                        .map(x => x.id);
                };

                if (state.mode === 'compare' || state.mode === 'rank-compare') {
                    loader.classList.remove('hidden');
                    status.innerText = "Computing comparison...";

                    // Hide Breakpoint Stats by default in Compare mode
                    document.getElementById('breakpoint-stats').classList.add('hidden');

                    await new Promise(r => setTimeout(r, 50));

                    // 1. Calculate Scores
                    const fixedScores = {};
                    Object.keys(RAW_DATA.models).forEach(modelId => {
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[modelId][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });
                        if (perfs.length >= state.minBenchmarks) {
                            fixedScores[modelId] = solveFixed(perfs, diffs, discs);
                        }
                    });
                    const refitResult = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                    const refitScores = refitResult.ability || {};
                    const refitDiffs = refitResult.difficulty || {};
                    const refitDiscs = refitResult.discriminability || {};
                    const refitScaling = refitResult.scaling || { a: 0, b: 1 };

                    // 2. Filter & Collect
                    const rawPoints = []; // {id, x, y, count}

                    Object.keys(refitScores).forEach(modelId => {
                        if (fixedScores[modelId] !== undefined) {
                            const m = RAW_DATA.models[modelId];
                            const cx = fixedScores[modelId];
                            const cy = refitScores[modelId];
                            const count = Object.keys(RAW_DATA.performances[modelId] || {}).filter(b => activeBenchmarks.includes(b)).length;

                            let ciFixed = { low: null, high: null };
                            let ciRefit = { low: null, high: null };

                            if (state.showCI && state.mode === 'compare') { // Only calculate CI for standard compare
                                // Calc Fixed CI
                                const perfs = [], diffs = [], discs = [];
                                activeBenchmarks.forEach(bId => {
                                    if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                        perfs.push(RAW_DATA.performances[modelId][bId]);
                                        diffs.push(RAW_DATA.benchmarks[bId].diff);
                                        discs.push(RAW_DATA.benchmarks[bId].disc);
                                    }
                                });
                                ciFixed = calculateBootstrapCI(perfs, diffs, discs);

                                // Calc Refit CI (using Bootstrapped Ability on Fixed Refit Item Params)
                                const rPerfs = [], rDiffs = [], rDiscs = [];
                                activeBenchmarks.forEach(bId => {
                                    if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                        rPerfs.push(RAW_DATA.performances[modelId][bId]);
                                        // Use the difficulty/disc from the JMLE result
                                        const d = refitDiffs[bId];
                                        const a = refitDiscs[bId];
                                        if (d !== undefined && a !== undefined) {
                                            rDiffs.push(d);
                                            rDiscs.push(a);
                                        }
                                    }
                                });
                                if (rDiffs.length === rPerfs.length) {
                                    ciRefit = calculateBootstrapCI(rPerfs, rDiffs, rDiscs, refitScaling);
                                }
                            }

                            rawPoints.push({
                                id: modelId,
                                x: cx, // Store raw scores initially
                                y: cy,
                                count,
                                name: m.name,
                                ciFixed,
                                ciRefit
                            });
                        }
                    });

                    // Rank Compare Logic Transformation
                    if (state.mode === 'rank-compare') {
                        // Sort by Fixed (descending) -> Assign Rank
                        const sortedByFixed = [...rawPoints].sort((a, b) => b.x - a.x);
                        sortedByFixed.forEach((p, i) => p.fixedRank = i + 1);

                        // Sort by Refit (descending) -> Assign Rank
                        const sortedByRefit = [...rawPoints].sort((a, b) => b.y - a.y);
                        sortedByRefit.forEach((p, i) => p.refitRank = i + 1);

                        // Update x, y to Ranks
                        rawPoints.forEach(p => {
                            p.x = p.fixedRank;
                            p.y = p.refitRank;
                        });

                        // Calculate Spearman Correlation
                        // rho = 1 - (6 * sum(d^2)) / (n * (n^2 - 1))
                        const n = rawPoints.length;
                        if (n > 1) {
                            let sumD2 = 0;
                            rawPoints.forEach(p => {
                                const d = p.fixedRank - p.refitRank;
                                sumD2 += d * d;
                            });
                            const rho = 1 - (6 * sumD2) / (n * (n * n - 1));
                            status.innerText = `Spearman Correlation: ${rho.toFixed(4)} (${n} models)`;
                        } else {
                            status.innerText = "Not enough models for correlation.";
                        }

                        // Display Largest Deviations
                        const deviations = [...rawPoints];
                        deviations.forEach(p => p.delta = p.fixedRank - p.refitRank); // Positive = Improved in Refit (Lower Rank Number)

                        deviations.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));
                        const topDeviations = deviations.slice(0, 5);

                        const bpStatsDiv = document.getElementById('breakpoint-stats');
                        const bpContentDiv = document.getElementById('breakpoint-content');

                        if (topDeviations.length > 0) {
                            bpStatsDiv.classList.remove('hidden');

                            // Update Title
                            const titleEl = document.getElementById('stats-title');
                            if (titleEl) titleEl.innerText = "Rank Deviations";

                            let html = `<div class="flex flex-wrap gap-2 items-center">`;

                            topDeviations.forEach(d => {
                                const valStr = d.delta > 0 ? ` ${d.delta}` : ` ${Math.abs(d.delta)}`;
                                const colClass = d.delta > 0 ? 'text-green-700 bg-green-50 border-green-200' : (d.delta < 0 ? 'text-red-700 bg-red-50 border-red-200' : 'text-gray-500 bg-gray-50');
                                html += `<div class="flex items-center gap-2 px-2 py-1 rounded-md border ${colClass}">
                                            <span class="font-medium text-gray-800 text-[10px] truncate max-w-[100px]" title="${d.name}">${d.name}</span>
                                            <span class="font-mono font-bold text-[10px]">${valStr}</span>
                                         </div>`;
                            });
                            html += `</div>`;

                            html += `<div class="mt-2 text-[10px] text-gray-400 flex flex-wrap items-center gap-x-3 gap-y-1 border-t pt-1">
                                        <span>Comparison: Fixed Rank vs Refit Rank</span>
                                        <span class="px-1.5 py-0.5 bg-green-50 text-green-700 rounded text-[9px] border border-green-100"> Better in Refit</span>
                                        <span class="px-1.5 py-0.5 bg-red-50 text-red-700 rounded text-[9px] border border-red-100"> Worse in Refit</span>
                                     </div>`;

                            bpContentDiv.innerHTML = html;
                        } else {
                            bpStatsDiv.classList.add('hidden');
                        }
                    } else {
                        // In standard compare mode, ensure statistics box is hidden
                        const bpStatsDiv = document.getElementById('breakpoint-stats');
                        if (bpStatsDiv) bpStatsDiv.classList.add('hidden');
                    }

                    // 3. Axis Scaling
                    let xRange = [0, 1], yRange = [0, 1];
                    if (rawPoints.length > 0) {
                        const xs = rawPoints.map(p => p.x);
                        const ys = rawPoints.map(p => p.y);
                        const xMin = Math.min(...xs), xMax = Math.max(...xs);
                        const yMin = Math.min(...ys), yMax = Math.max(...ys);
                        const xPad = (xMax - xMin || 1) * 0.08;
                        const yPad = (yMax - yMin || 1) * 0.08;

                        // For ranks, we want 1 to be "top", so we might want to reverse ranges?
                        // But standard plot is (0,0) at bottom-left.
                        // If we want 1 at top-right (best-best), we need 1 to be high value.
                        // But rank 1 is numerically low.
                        // Let's reverse axes for Rank mode so 1 is at top/right if desired,
                        // OR just plot numerically 1..N (1 is bottom-left).
                        // Usually, rank plots have 1 at top-left or top-right.
                        // Let's stick to standard numerical for now (1 is bottom-left).
                        // Actually, reversing axis is better for "performance" intuition.
                        if (state.mode === 'rank-compare') {
                             xRange = [xMax + xPad, Math.max(0, xMin - xPad)]; // Reversed: N -> 1
                             yRange = [yMax + yPad, Math.max(0, yMin - yPad)]; // Reversed: N -> 1
                        } else {
                             xRange = [xMin - xPad, xMax + xPad];
                             yRange = [yMin - yPad, yMax + yPad];
                        }

                        layout.xaxis.range = xRange;
                        layout.yaxis.range = yRange;

                        // Trend Line (Diagonal for Rank Compare means perfect agreement)
                        plotData.push({
                            x: xRange, y: xRange, // Diagonal y=x
                            mode: 'lines', type: 'scatter', name: 'Agreement',
                            line: { dash: 'dash', color: 'rgba(0,0,0,0.15)', width: 1.5 }, showlegend: false, hoverinfo: 'none'
                        });
                    }

                    if (state.view === 'table') {
                        document.getElementById('chart-wrapper').classList.add('hidden');
                        document.getElementById('table-container').classList.remove('hidden');
                        renderTable(rawPoints, state.mode);
                        if (state.mode !== 'rank-compare') status.innerText = `Showing ${rawPoints.length} models in table.`;
                        loader.classList.add('hidden');
                        return;
                    }

                    document.getElementById('table-container').classList.add('hidden');
                    document.getElementById('chart-wrapper').classList.remove('hidden');

                    // Smart Labeling
                    const labelPositions = selectNonOverlappingLabels(rawPoints, xRange, yRange, isMobile);

                    // Deconstruct for Plotly
                    // Group by Organization
                    const orgGroups = {};
                    rawPoints.forEach(p => {
                        const org = getOrganization(p.name);
                        if (!orgGroups[org]) orgGroups[org] = [];
                        orgGroups[org].push(p);
                    });

                    // Create Traces for each organization
                    Object.keys(orgGroups).sort().forEach(org => {
                        const points = orgGroups[org];
                        const x = [], y = [], hovertext = [], displayLabels = [], textPositions = [];

                        points.forEach(p => {
                            x.push(p.x);
                            y.push(p.y);
                            hovertext.push(p.name);
                            const pos = labelPositions.get(p.id);
                            displayLabels.push(pos ? p.name : '');
                            textPositions.push(pos || 'top center');
                        });

                        let hoverTemplate = '';
                        let customData = [];

                        if (state.mode === 'rank-compare') {
                             hoverTemplate = '<b>%{hovertext}</b><br>Fixed Rank: %{x}<br>Refit Rank: %{y}<br>Change: %{customdata}<extra></extra>';
                             customData = points.map(p => {
                                 const d = p.fixedRank - p.refitRank;
                                 return d > 0 ? `+${d}` : `${d}`;
                             });
                        } else {
                             hoverTemplate = '<b>%{hovertext}</b><br>Fixed: %{x:.1f} %{customdata[0]}<br>Refit: %{y:.1f} %{customdata[1]}<extra></extra>';
                             customData = points.map(p => [
                                p.ciFixed.low ? `[${p.ciFixed.low.toFixed(1)}, ${p.ciFixed.high.toFixed(1)}]` : '',
                                p.ciRefit.low ? `[${p.ciRefit.low.toFixed(1)}, ${p.ciRefit.high.toFixed(1)}]` : ''
                            ]);
                        }

                        plotData.push({
                            x, y,
                            hovertext: hovertext,
                            text: displayLabels,
                            mode: 'markers+text',
                            type: 'scatter',
                            name: org,
                            textposition: textPositions,
                            textfont: { size: 10, color: '#4b5563', weight: 600 },
                            marker: {
                                color: ORG_COLORS[org] || ORG_COLORS['Other'],
                                size: 9,
                                line: { width: 1, color: 'white' },
                                opacity: 0.85
                            },
                            error_x: (state.showCI && state.mode === 'compare') ? {
                                type: 'data',
                                array: points.map(p => (p.ciFixed.high !== null ? p.ciFixed.high - p.x : null)),
                                arrayminus: points.map(p => (p.ciFixed.low !== null ? p.x - p.ciFixed.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            error_y: (state.showCI && state.mode === 'compare') ? {
                                type: 'data',
                                array: points.map(p => (p.ciRefit.high !== null ? p.ciRefit.high - p.y : null)),
                                arrayminus: points.map(p => (p.ciRefit.low !== null ? p.y - p.ciRefit.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            hovertemplate: hoverTemplate,
                            customdata: customData
                        });
                    });

                    if (state.mode === 'rank-compare') {
                        if (!isMobile) layout.title.text = 'Comparison: Fixed vs. Refit Ranks';
                        layout.xaxis.title.text = 'Fixed Parameters Rank (1=Best)';
                        layout.yaxis.title.text = 'Refit (JMLE) Rank (1=Best)';
                    } else {
                        if (!isMobile) layout.title.text = 'Comparison: Fixed vs. Refit ECI';
                        layout.xaxis.title.text = 'Fixed Parameters ECI';
                        layout.yaxis.title.text = 'Refit (JMLE) ECI';
                        status.innerText = `Comparing ${rawPoints.length} models.`;
                    }

                } else {
                    const rawPoints = []; // {id, x (time), y, count, name}
                    const isFixed = state.mode === 'fixed';

                    if (state.mode === 'fixed') {
                        Object.keys(RAW_DATA.models).forEach(modelId => {
                            const m = RAW_DATA.models[modelId];
                            if (!m.date) return;
                            const perfs = [], diffs = [], discs = [];
                            activeBenchmarks.forEach(bId => {
                                if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                    perfs.push(RAW_DATA.performances[modelId][bId]);
                                    diffs.push(RAW_DATA.benchmarks[bId].diff);
                                    discs.push(RAW_DATA.benchmarks[bId].disc);
                                }
                            });
                            if (perfs.length >= state.minBenchmarks) {
                                const theta = solveFixed(perfs, diffs, discs);
                                // Store x as numeric timestamp for collision logic
                                const ci = state.showCI ? calculateBootstrapCI(perfs, diffs, discs) : { low: null, high: null };
                                // Store x as numeric timestamp for collision logic
                                rawPoints.push({
                                    id: modelId,
                                    x: new Date(m.date).getTime(),
                                    dateStr: m.date,
                                    y: theta,
                                    ci,
                                    count: perfs.length,
                                    name: m.name
                                });
                            }
                        });
                    }

                    if (state.mode === 'refit') {
                        loader.classList.remove('hidden');
                        status.innerText = "Refitting model...";
                        await new Promise(r => setTimeout(r, 50));
                        try {
                            const refitResult = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                            const refitScores = refitResult.ability || {};
                            const refitDiffs = refitResult.difficulty || {};
                            const refitDiscs = refitResult.discriminability || {};
                            const refitScaling = refitResult.scaling || { a: 0, b: 1 };

                            Object.keys(refitScores).forEach(modelId => {
                                const m = RAW_DATA.models[modelId];
                                if (m && m.date) {
                                    const count = Object.keys(RAW_DATA.performances[modelId] || {}).filter(b => activeBenchmarks.includes(b)).length;
                                    rawPoints.push({
                                        id: modelId,
                                        x: new Date(m.date).getTime(),
                                        dateStr: m.date,
                                        y: refitScores[modelId],
                                        count: count,
                                        name: m.name
                                    });

                                    if (state.showCI) {
                                        // Calc Refit CI
                                        const rPerfs = [], rDiffs = [], rDiscs = [];
                                        activeBenchmarks.forEach(bId => {
                                            if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                                rPerfs.push(RAW_DATA.performances[modelId][bId]);
                                                const d = refitDiffs[bId];
                                                const a = refitDiscs[bId];
                                                if (d !== undefined && a !== undefined) {
                                                    rDiffs.push(d);
                                                    rDiscs.push(a);
                                                }
                                            }
                                        });
                                        if (rDiffs.length === rPerfs.length) {
                                            rawPoints[rawPoints.length - 1].ci = calculateBootstrapCI(rPerfs, rDiffs, rDiscs, refitScaling);
                                        } else {
                                            rawPoints[rawPoints.length - 1].ci = { low: null, high: null };
                                        }
                                    } else {
                                        rawPoints[rawPoints.length - 1].ci = { low: null, high: null };
                                    }
                                }
                            });
                        } catch (e) { console.error(e); }
                    }

                    if (state.view === 'table') {
                        document.getElementById('chart-wrapper').classList.add('hidden');
                        document.getElementById('table-container').classList.remove('hidden');
                        renderTable(rawPoints, state.mode);
                        status.innerText = `Showing ${rawPoints.length} models in table.`;
                        loader.classList.add('hidden');
                        return;
                    }

                    document.getElementById('table-container').classList.add('hidden');
                    document.getElementById('chart-wrapper').classList.remove('hidden');

                    // Smart Labels
                    let xRange = [0, 1], yRange = [0, 1];
                    if (rawPoints.length > 0) {
                        const xs = rawPoints.map(p => p.x);
                        const ys = rawPoints.map(p => p.y);
                        // Add some padding to date range (approx 1 month in ms)
                        const month = 1000 * 60 * 60 * 24 * 30;
                        xRange = [Math.min(...xs) - month, Math.max(...xs) + month];
                        const yMin = Math.min(...ys), yMax = Math.max(...ys);
                        const yPad = (yMax - yMin || 1) * 0.1;
                        yRange = [yMin - yPad, yMax + yPad];
                        layout.xaxis.range = xRange;
                        layout.yaxis.range = yRange;
                    }

                    const labelPositions = selectNonOverlappingLabels(rawPoints, xRange, yRange, isMobile);

                    //Sort by date for line connection if we wanted lines (here strictly markers)
                    rawPoints.sort((a, b) => a.x - b.x);

                    // Breakpoint Analysis Overlay
                    const bpStatsDiv = document.getElementById('breakpoint-stats');
                    const bpContentDiv = document.getElementById('breakpoint-content');

                    if (state.showBreakpoint && rawPoints.length > 5) {
                        bpStatsDiv.classList.remove('hidden');
                        const titleEl = document.getElementById('stats-title');
                        if (titleEl) titleEl.innerText = "Frontier Breakpoint Analysis";
                        status.innerText = "Running statistical analysis...";

                        await new Promise(r => setTimeout(r, 10));

                        // Use Frontier for Analysis
                        const frontierPoints = getFrontier(rawPoints);

                        if (frontierPoints.length < 6) {
                             bpContentDiv.innerText = "Insufficient frontier points for analysis.";
                             status.innerText = "Analysis skipped.";
                             return;
                        }

                        const lin = linearRegression(frontierPoints);
                        const bp = breakpointRegression(frontierPoints);

                        if (lin && bp) {
                            const bicLin = calculateBIC(lin.n, lin.k, lin.rss);
                            const bicBp = calculateBIC(frontierPoints.length, bp.k, bp.rss);

                            let ciText = "";
                            let ci = null;
                            // Bootstrap using FULL data (rawPoints)
                            // We always calculate CI if we are showing breakpoint analysis, per user request
                            ci = bootstrapFrontier(rawPoints, 1000);

                            if (ci) {
                                const dLow = new Date(ci.low).toISOString().split('T')[0];
                                const dHigh = new Date(ci.high).toISOString().split('T')[0];
                                ciText = `90% CI: ${dLow} to ${dHigh}`;
                            }

                            // Use median split if available
                            const splitX = ci ? ci.median : bp.splitX;
                            const dSplit = new Date(splitX).toISOString().split('T')[0];

                            const diff = bicLin - bicBp; // Positive means Breakpoint better
                            let evidence = "Weak/Inconclusive";
                            if (diff < -10) evidence = "Very Strong (Linear)";
                            else if (diff < -6) evidence = "Strong (Linear)";
                            else if (diff < -2) evidence = "Positive (Linear)";
                            else if (diff > 10) evidence = "Very Strong (Breakpoint)";
                            else if (diff > 6) evidence = "Strong (Breakpoint)";
                            else if (diff > 2) evidence = "Positive (Breakpoint)";

                            // Growth Factors
                            const msPerYear = 1000 * 60 * 60 * 24 * 365.25;
                            // Additive growth: slope (points/ms) * msPerYear = points/year
                            const calcGrowth = (slope) => (slope * msPerYear).toFixed(2) + " ECI points / year";

                            const linearGrowth = calcGrowth(lin.slope);

                            let preGrowth = "-", postGrowth = "-";
                            let constrainedBp = null;

                            // Re-fit constrained with the chosen split point
                            constrainedBp = solveConstrained(frontierPoints, splitX);
                            if (constrainedBp) {
                                preGrowth = calcGrowth(constrainedBp.slope1);
                                postGrowth = calcGrowth(constrainedBp.slope2);
                            }

                            let speedup = null;
                            if (constrainedBp && constrainedBp.slope1 !== 0) {
                                speedup = ((constrainedBp.slope2 - constrainedBp.slope1) / constrainedBp.slope1 * 100);
                            }

                            bpContentDiv.innerHTML = `
                                <div class="flex flex-wrap gap-x-6 gap-y-2 items-center">
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Linear BIC:</span>
                                        <span class="font-mono font-bold">${bicLin.toFixed(1)}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Break BIC:</span>
                                        <span class="font-mono font-bold text-indigo-600">${bicBp.toFixed(1)}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Evidence:</span>
                                        <span class="font-medium">${evidence}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Split:</span>
                                        <span class="font-bold text-gray-900">${dSplit}</span>
                                    </div>
                                </div>
                                <div class="flex flex-wrap gap-x-6 gap-y-2 items-center mt-2 pt-2 border-t border-gray-100">
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500 font-bold">Growth:</span>
                                        <span class="font-mono text-gray-700">${linearGrowth}</span>
                                    </div>
                                    ${constrainedBp ? `
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Pre:</span>
                                        <span class="font-mono text-indigo-600 font-bold">${preGrowth}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Post:</span>
                                        <span class="font-mono text-pink-600 font-bold">${postGrowth}</span>
                                    </div>
                                    ${speedup !== null ? `
                                    <div class="flex items-center gap-2 bg-green-50 px-2 py-0.5 rounded border border-green-100">
                                        <span class="text-green-700 font-bold"> ${speedup > 0 ? '+' : ''}${speedup.toFixed(0)}% Speedup</span>
                                    </div>
                                    ` : ''}
                                    ` : ''}
                                </div>
                                ${ciText ? `<div class="mt-1 text-gray-400 text-[10px]">${ciText}</div>` : ''}
                            `;

                            // Helper to generate dense points for hover
                            const generateLinePoints = (startT, endT, slope, intercept) => {
                                const pointsX = [];
                                const pointsY = [];
                                const step = 1000 * 60 * 60 * 24 * 15; // 15 days
                                for (let t = startT; t <= endT; t += step) {
                                    pointsX.push(new Date(t).toISOString());
                                    pointsY.push(slope * t + intercept);
                                }
                                // Ensure end point is included
                                if (pointsX[pointsX.length-1] !== new Date(endT).toISOString()) {
                                    pointsX.push(new Date(endT).toISOString());
                                    pointsY.push(slope * endT + intercept);
                                }
                                return { x: pointsX, y: pointsY };
                            };

                            const xMin = xRange[0], xMax = xRange[1];

                            // 1. Linear Fit
                            const linPts = generateLinePoints(xMin, xMax, lin.slope, lin.intercept);
                            plotData.push({
                                x: linPts.x,
                                y: linPts.y,
                                mode: 'lines', type: 'scatter', name: 'Linear Fit',
                                line: { dash: 'dot', color: '#9ca3af', width: 2 },
                                hovertemplate: `<b>Linear Trend</b><br>Growth: ${linearGrowth}<extra></extra>`
                            });

                            // 2. Constrained Breakpoint Fit
                            if (constrainedBp) {
                                const splitX = ci ? ci.median : bp.splitX;

                                const prePts = generateLinePoints(xMin, splitX, constrainedBp.slope1, constrainedBp.intercept1);
                                plotData.push({
                                    x: prePts.x,
                                    y: prePts.y,
                                    mode: 'lines', type: 'scatter', name: 'Pre-Break',
                                    line: { color: '#4f46e5', width: 3 },
                                    hovertemplate: `<b>Pre-Break Trend</b><br>Growth: ${preGrowth}<extra></extra>`
                                });

                                const postPts = generateLinePoints(splitX, xMax, constrainedBp.slope2, constrainedBp.intercept2);
                                plotData.push({
                                    x: postPts.x,
                                    y: postPts.y,
                                    mode: 'lines', type: 'scatter', name: 'Post-Break',
                                    line: { color: '#ec4899', width: 3 },
                                    hovertemplate: `<b>Post-Break Trend</b><br>Growth: ${postGrowth}<extra></extra>`
                                });

                                if (ci) {
                                     layout.shapes = [
                                        {
                                            type: 'rect',
                                            xref: 'x', yref: 'paper',
                                            x0: new Date(ci.low).toISOString(),
                                            x1: new Date(ci.high).toISOString(),
                                            y0: 0, y1: 1,
                                            fillcolor: '#4f46e5',
                                            opacity: 0.1,
                                            line: { width: 0 }
                                        },
                                        {
                                            type: 'line',
                                            xref: 'x', yref: 'paper',
                                            x0: new Date(splitX).toISOString(),
                                            x1: new Date(splitX).toISOString(),
                                            y0: 0, y1: 1,
                                            line: { color: '#4f46e5', width: 1, dash: 'dash' }
                                        }
                                     ];
                                }
                            }
                        } else {
                            bpContentDiv.innerText = "Insufficient data.";
                        }
                        status.innerText = "Analysis complete.";
                    } else {
                        bpStatsDiv.classList.add('hidden');
                    }

                    // Group by Organization
                    const orgGroups = {};
                    rawPoints.forEach(p => {
                        const org = getOrganization(p.name);
                        if (!orgGroups[org]) orgGroups[org] = [];
                        orgGroups[org].push(p);
                    });

                    // Render Custom Legend for Mobile
                    const mobileLegend = document.getElementById('mobile-chart-legend');
                    if (isMobile && mobileLegend) {
                        mobileLegend.innerHTML = '';
                        Object.keys(orgGroups).sort().forEach(org => {
                            const color = ORG_COLORS[org] || ORG_COLORS['Other'];
                            const item = document.createElement('div');
                            item.className = "flex items-center gap-1.5 flex-shrink-0";
                            item.innerHTML = `
                                <span class="w-2.5 h-2.5 rounded-full" style="background-color: ${color}"></span>
                                <span class="text-xs font-semibold text-gray-700">${org}</span>
                            `;
                            mobileLegend.appendChild(item);
                        });
                        mobileLegend.classList.remove('hidden');
                    } else if (mobileLegend) {
                        mobileLegend.classList.add('hidden');
                    }

                    // Create Traces
                    Object.keys(orgGroups).sort().forEach(org => {
                        const points = orgGroups[org];
                        const x = [], y = [], hovertext = [], displayLabels = [], textPositions = [];

                        points.forEach(p => {
                            x.push(p.dateStr);
                            y.push(p.y);
                            hovertext.push(p.name);
                            const pos = labelPositions.get(p.id);
                            displayLabels.push(pos ? p.name : '');
                            textPositions.push(pos || 'top center');
                        });

                        plotData.push({
                            x, y,
                            hovertext: hovertext,
                            text: displayLabels,
                            mode: 'markers+text',
                            type: 'scatter',
                            name: org,
                            textposition: textPositions,
                            textfont: { size: 10, color: isFixed ? '#4b5563' : '#4b5563', weight: 600 },
                            marker: {
                                color: ORG_COLORS[org] || ORG_COLORS['Other'],
                                size: 10,
                                line: { width: 1.5, color: 'white' },
                                opacity: 0.9
                            },
                            error_y: state.showCI ? {
                                type: 'data',
                                array: points.map(p => (p.ci.high !== null ? p.ci.high - p.y : null)),
                                arrayminus: points.map(p => (p.ci.low !== null ? p.y - p.ci.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            hovertemplate: '<b>%{hovertext}</b><br>Date: %{x}<br>ECI: %{y:.2f} %{customdata}<extra></extra>',
                            customdata: points.map(p => p.ci.low ? `[${p.ci.low.toFixed(1)}, ${p.ci.high.toFixed(1)}]` : '')
                        });
                    });

                }

                Plotly.newPlot('chart-container', plotData, layout, { responsive: true, displayModeBar: false });

            } catch (err) {
                console.error("UpdateChart Error:", err);
                status.innerText = "An error occurred while updating the chart.";
            } finally {
                loader.classList.add('hidden');
            }
        }

        async function exportData() {
            const status = document.getElementById('status-text');
            if (status) status.innerText = "Preparing export...";

            try {
                const activeBenchmarks = Array.from(state.selectedBenchmarks);
                const modelIds = Object.keys(RAW_DATA.models);
                const rows = [];

                // Define extraction logic based on mode
                let header = [];
                if (state.mode === 'fixed') header = ['Model', 'Date', 'Fixed_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'refit') header = ['Model', 'Date', 'Refit_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'compare') header = ['Model', 'Date', 'Fixed_ECI', 'Refit_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'rank-compare') header = ['Model', 'Date', 'Fixed_Rank', 'Refit_Rank', 'Included_Benchmarks'];

                rows.push(header);

                // Pre-calc JMLE if needed
                let refitScores = {};
                if (state.mode === 'refit' || state.mode === 'compare' || state.mode === 'rank-compare') {
                    const res = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                    refitScores = res.ability || {};
                }

                modelIds.forEach(id => {
                    const m = RAW_DATA.models[id];
                    let fixedVal = null;
                    let refitVal = null;
                    let employedBenchmarks = [];

                    // Identify utilized benchmarks
                    activeBenchmarks.forEach(bId => {
                        if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                            employedBenchmarks.push(RAW_DATA.benchmarks[bId].name);
                        }
                    });

                    // Calc fixed if needed
                    if (state.mode === 'fixed' || state.mode === 'compare' || state.mode === 'rank-compare') {
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[id][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });

                        if (perfs.length >= state.minBenchmarks) {
                            fixedVal = solveFixed(perfs, diffs, discs);
                        }
                    }

                    if (state.mode === 'refit' || state.mode === 'compare' || state.mode === 'rank-compare') {
                        refitVal = refitScores[id];
                    }

                    const benchString = `"${employedBenchmarks.join('; ')}"`;

                    // Construct Row
                    if (state.mode === 'fixed') {
                        if (fixedVal !== null) rows.push([`"${m.name}"`, m.date, fixedVal.toFixed(2), benchString]);
                    } else if (state.mode === 'refit') {
                        if (refitVal !== undefined) rows.push([`"${m.name}"`, m.date, refitVal.toFixed(2), benchString]);
                    } else if (state.mode === 'compare') {
                        if (fixedVal !== null && refitVal !== undefined) {
                            rows.push([`"${m.name}"`, m.date, fixedVal.toFixed(2), refitVal.toFixed(2), benchString]);
                        }
                    } else if (state.mode === 'rank-compare') {
                        // We need to re-compute ranks globally for export, but this function iterates per model.
                        // Better approach: collect all valid pairs first, sort, rank, then export.
                        // For simplicity in this patch, we skip complex re-ranking inside the export loop
                        // or assume the user just wants the filtered data.
                        // Actually, without sorting the whole set, we can't export ranks easily here efficiently without refactoring.
                        // Let's just export the scores for now or do a quick re-calculation.
                        // Since exportData is async, we can do it properly.
                    }
                });

                if (state.mode === 'rank-compare') {
                    // Post-process for Rank Compare Export
                    // Gather all valid models
                    const validModels = [];
                     modelIds.forEach(id => {
                        const m = RAW_DATA.models[id];
                        let f = null;
                        // ... (re-calc fixed) - wait, this is inefficient to duplicate code.
                        // Given the architecture, let's just piggyback on what we have.
                        // Let's restart the loop properly for Rank Compare.
                     });

                     // Actually, let's just simplify and export the table data if possible?
                     // But table data is not stored in state.

                     // Re-implement simplified rank logic for export
                     const data = [];
                     modelIds.forEach(id => {
                        // ... calc fixedVal and refitVal ...
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[id][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });
                        let f = null;
                        if (perfs.length >= state.minBenchmarks) f = solveFixed(perfs, diffs, discs);
                        let r = refitScores[id];

                        if (f !== null && r !== undefined) {
                            data.push({ id, name: RAW_DATA.models[id].name, date: RAW_DATA.models[id].date, f, r,
                                benches: activeBenchmarks.filter(b => RAW_DATA.performances[id][b] !== undefined).map(b => RAW_DATA.benchmarks[b].name).join('; ')
                            });
                        }
                     });

                     data.sort((a,b) => b.f - a.f).forEach((d,i) => d.fRank = i+1);
                     data.sort((a,b) => b.r - a.r).forEach((d,i) => d.rRank = i+1);

                     data.forEach(d => {
                         rows.push([`"${d.name}"`, d.date, d.fRank, d.rRank, `"${d.benches}"`]);
                     });
                }

                // Generate CSV
                const csvContent = rows.map(r => r.join(",")).join("\n");

                // Standard Download Method (Hidden Anchor)
                // We use a Data URI here because Blob URLs on file:// protocol often ignore the 'download' attribute (filename).
                // Browsers may still override the filename on local files depending on security settings, but this is the best standard approach.
                const BOM = "\uFEFF";
                const uri = 'data:text/csv;charset=utf-8,' + encodeURIComponent(BOM + csvContent);

                const link = document.createElement("a");
                link.setAttribute("href", uri);
                link.setAttribute("download", `eci_export_${state.mode}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                if (status) status.innerText = "Export complete.";

            } catch (e) {
                console.error("Export Error:", e);
                alert("Failed to export data: " + e.message);
            }
        }

        // --- State Serialization ---
        function serializeState() {
            const params = new URLSearchParams();

            // Compress benchmarks using index mapping
            if (state.selectedBenchmarks.size > 0) {
                const sortedKeys = Object.keys(RAW_DATA.benchmarks).sort();
                const indices = [];
                state.selectedBenchmarks.forEach(id => {
                    const idx = sortedKeys.indexOf(id);
                    if (idx !== -1) indices.push(idx);
                });
                indices.sort((a, b) => a - b);
                params.set('s', indices.join('~'));
            }

            // Only include essential state as per request
            if (state.minBenchmarks !== 2) params.set('min', state.minBenchmarks);
            if (state.useStdScale) params.set('std', '1');

            return window.location.protocol + "//" + window.location.host + window.location.pathname + "?" + params.toString();
        }

        function deserializeState() {
            const params = new URLSearchParams(window.location.search);
            let hasState = false;

            // Handle legacy 'b' param (full names)
            if (params.has('b')) {
                const benches = params.get('b').split(',');
                state.selectedBenchmarks.clear();
                benches.forEach(id => {
                    if (RAW_DATA.benchmarks[id]) {
                        state.selectedBenchmarks.add(id);
                    }
                });
                hasState = true;
            }

            // Handle new 's' param (indices)
            if (params.has('s')) {
                const indices = params.get('s').split('~').map(i => parseInt(i, 10));
                const sortedKeys = Object.keys(RAW_DATA.benchmarks).sort();
                state.selectedBenchmarks.clear();
                indices.forEach(idx => {
                    if (sortedKeys[idx]) {
                        state.selectedBenchmarks.add(sortedKeys[idx]);
                    }
                });
                hasState = true;
            }

            if (params.has('m')) { state.mode = params.get('m'); hasState = true; }
            if (params.has('v')) { state.view = params.get('v'); hasState = true; }
            if (params.has('min')) { state.minBenchmarks = parseInt(params.get('min'), 10); hasState = true; }
            if (params.has('ci')) { state.showCI = params.get('ci') === '1'; hasState = true; }
            if (params.has('bp')) { state.showBreakpoint = params.get('bp') === '1'; hasState = true; }
            if (params.has('d')) { state.viewedDomain = params.get('d'); hasState = true; }
            if (params.has('std')) { state.useStdScale = params.get('std') === '1'; hasState = true; }

            return hasState;
        }

        // --- UI Setup ---
        async function init() {
            try {
                const status = document.getElementById('status-text');
                if (status) status.innerText = "Initializing...";

                if (typeof RAW_DATA === 'undefined' || !RAW_DATA.benchmarks) {
                    throw new Error("Data not loaded correctly");
                }

                // Restore state from URL or load defaults
                const restored = deserializeState();

                // Default selection (Math) if no benchmarks provided in URL
                if (state.selectedBenchmarks.size === 0 && !restored) {
                    Object.keys(RAW_DATA.benchmarks).forEach(id => {
                        if (RAW_DATA.benchmarks[id].domain === 'Math') {
                            state.selectedBenchmarks.add(id);
                        }
                    });
                }

                // Category filter
                const domainSelector = document.getElementById('domain-selector');
                if (domainSelector) {
                    domainSelector.addEventListener('change', (e) => {
                        state.viewedDomain = e.target.value;
                        renderBenchmarkList();
                    });
                }

                // Search filter
                const searchInput = document.getElementById('search-benchmarks');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        state.searchTerm = e.target.value;
                        renderBenchmarkList();
                    });
                }

                const clearBtn = document.getElementById('clear-domains');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        state.selectedBenchmarks.clear();
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                // Share functionality
                const handleShare = async (e) => {
                    const url = serializeState();
                    const btn = e.currentTarget;
                    const originalHTML = btn.innerHTML;

                    try {
                        await navigator.clipboard.writeText(url);

                        // Button feedback
                        btn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg> Copied!`;
                        btn.classList.replace('bg-indigo-600', 'bg-green-600');
                        btn.classList.replace('hover:bg-indigo-700', 'hover:bg-green-700');

                        // Status feedback
                        const status = document.getElementById('status-text');
                        const originalText = status.innerText;
                        status.innerText = "Link copied to clipboard!";
                        status.classList.add('text-indigo-600', 'font-bold');

                        setTimeout(() => {
                            btn.innerHTML = originalHTML;
                            btn.classList.replace('bg-green-600', 'bg-indigo-600');
                            btn.classList.replace('hover:bg-green-700', 'hover:bg-indigo-700');

                            status.innerText = originalText;
                            status.classList.remove('text-indigo-600', 'font-bold');
                        }, 2000);

                        // Push history state so the URL bar updates without reload
                        window.history.pushState({}, '', url);

                    } catch (err) {
                        console.error('Failed to copy: ', err);
                        alert('Failed to copy link to clipboard.\nURL: ' + url);
                    }
                };
                ['share-btn', 'mobile-share-btn'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('click', handleShare);
                });

                // Export functionality
                const handleExport = () => exportData();
                ['download-btn', 'mobile-download-btn'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('click', handleExport);
                });

                // Mode switching
                const modes = ['fixed', 'refit', 'compare', 'rank-compare'];

                function updateModeUI(selectedMode) {
                    modes.forEach(m => {
                        // Desktop
                        const dBtn = document.getElementById(`mode-${m}`);
                        if (dBtn) {
                             if (m === selectedMode) {
                                dBtn.className = "px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200";
                             } else {
                                dBtn.className = "px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all";
                             }
                        }
                        // Mobile
                        const mBtn = document.getElementById(`mobile-mode-${m}`);
                        if (mBtn) {
                            if (m === selectedMode) {
                                mBtn.className = "px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-indigo-50 text-indigo-700 border border-indigo-200";
                            } else {
                                mBtn.className = "px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50";
                            }
                        }
                    });

                    // Hide Breakpoint Toggle in Rank Compare mode
                    const bpToggle = document.getElementById('show-breakpoint-toggle');
                    const mobBpToggle = document.getElementById('mobile-show-breakpoint-toggle');
                    const bpContainer = bpToggle ? bpToggle.parentElement : null;
                    const mobBpContainer = mobBpToggle ? mobBpToggle.parentElement : null;

                    if (selectedMode === 'rank-compare') {
                        if (bpContainer) bpContainer.classList.add('hidden');
                        if (mobBpContainer) mobBpContainer.classList.add('hidden');
                    } else {
                        if (bpContainer) bpContainer.classList.remove('hidden');
                        if (mobBpContainer) mobBpContainer.classList.remove('hidden');
                    }
                }

                modes.forEach(m => {
                    ['mode-', 'mobile-mode-'].forEach(prefix => {
                        const el = document.getElementById(prefix + m);
                        if (el) {
                            el.addEventListener('click', () => {
                                state.mode = m;
                                updateModeUI(m);
                                updateChart();
                                if (window.innerWidth < 1024) toggleSidebar(false); // Close sidebar on mobile selection
                            });
                        }
                    });
                });

                // View Switching
                function updateViewUI(selectedView) {
                    // Desktop
                    ['view-chart', 'view-table'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            if (id === `view-${selectedView}`) {
                                el.className = "px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200";
                            } else {
                                el.className = "px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all";
                            }
                        }
                    });

                    // Mobile
                    ['mobile-view-chart', 'mobile-view-table'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            if (id === `mobile-view-${selectedView}`) {
                                el.className = "px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900";
                            } else {
                                el.className = "px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50";
                            }
                        }
                    });
                }

                ['view-chart', 'view-table', 'mobile-view-chart', 'mobile-view-table'].forEach(bid => {
                    const el = document.getElementById(bid);
                    if (el) {
                        el.addEventListener('click', () => {
                            const view = bid.includes('mobile-') ? bid.replace('mobile-view-', '') : bid.replace('view-', '');
                            state.view = view;
                            updateViewUI(view);
                            updateChart();
                            if (window.innerWidth < 1024 && bid.includes('mobile-')) toggleSidebar(false);
                        });
                    }
                });

                // Initialize UI state
                updateModeUI(state.mode);
                updateViewUI(state.view);

                // Sync controls with state
                if (state.minBenchmarks) {
                     const s = document.getElementById('min-benchmarks');
                     const sv = document.getElementById('min-benchmarks-val');
                     if (s) s.value = state.minBenchmarks;
                     if (sv) sv.innerText = state.minBenchmarks;
                }
                const bpT = document.getElementById('show-breakpoint-toggle');
                const mBpT = document.getElementById('mobile-show-breakpoint-toggle');
                if (bpT) bpT.checked = state.showBreakpoint;
                if (mBpT) mBpT.checked = state.showBreakpoint;

                const ciT = document.getElementById('show-ci-toggle');
                const mCiT = document.getElementById('mobile-show-ci-toggle');
                if (ciT) ciT.checked = state.showCI;
                if (mCiT) mCiT.checked = state.showCI;

                // Bulk actions
                const selectAll = document.getElementById('select-all');
                if (selectAll) {
                    selectAll.addEventListener('click', () => {
                        const term = state.searchTerm.toLowerCase();
                        const viewed = state.viewedDomain;
                        Object.entries(RAW_DATA.benchmarks).forEach(([id, b]) => {
                            const matchesSearch = b.name.toLowerCase().includes(term);
                            const matchesDomain = (viewed === 'All' || b.domain === viewed);
                            if (matchesSearch && matchesDomain) state.selectedBenchmarks.add(id);
                        });
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                const deselectAll = document.getElementById('deselect-all');
                if (deselectAll) {
                    deselectAll.addEventListener('click', () => {
                        state.selectedBenchmarks.clear();
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                // Min Benchmarks selector
                const slider = document.getElementById('min-benchmarks');
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        const val = parseInt(e.target.value);
                        const display = document.getElementById('min-benchmarks-val');
                        if (display) display.innerText = val;
                        state.minBenchmarks = val;
                        updateChart();
                    });
                }

                // Show Breakpoint toggle
                function toggleBreakpoint(checked) {
                    state.showBreakpoint = checked;
                    const dToggle = document.getElementById('show-breakpoint-toggle');
                    if (dToggle) dToggle.checked = checked;
                    const mToggle = document.getElementById('mobile-show-breakpoint-toggle');
                    if (mToggle) mToggle.checked = checked;
                    updateChart();
                }

                const bpToggle = document.getElementById('show-breakpoint-toggle');
                if (bpToggle) bpToggle.addEventListener('change', (e) => toggleBreakpoint(e.target.checked));

                const mobBpToggle = document.getElementById('mobile-show-breakpoint-toggle');
                if (mobBpToggle) mobBpToggle.addEventListener('change', (e) => toggleBreakpoint(e.target.checked));

                // Show CI toggle
                function toggleCI(checked) {
                    state.showCI = checked;
                    const dToggle = document.getElementById('show-ci-toggle');
                    if (dToggle) dToggle.checked = checked;
                    const mToggle = document.getElementById('mobile-show-ci-toggle');
                    if (mToggle) mToggle.checked = checked;
                    updateChart();
                }

                const ciToggle = document.getElementById('show-ci-toggle');
                if (ciToggle) ciToggle.addEventListener('change', (e) => toggleCI(e.target.checked));

                const mobCiToggle = document.getElementById('mobile-show-ci-toggle');
                if (mobCiToggle) mobCiToggle.addEventListener('change', (e) => toggleCI(e.target.checked));

                // Std Scale Toggle
                function toggleStdScale(checked) {
                    state.useStdScale = checked;
                    const dToggle = document.getElementById('std-scale-toggle');
                    if (dToggle) dToggle.checked = checked;
                    const mToggle = document.getElementById('mobile-std-scale-toggle');
                    if (mToggle) mToggle.checked = checked;
                    updateChart();
                }

                const stdScaleToggle = document.getElementById('std-scale-toggle');
                if (stdScaleToggle) stdScaleToggle.addEventListener('change', (e) => toggleStdScale(e.target.checked));

                const mobStdScaleToggle = document.getElementById('mobile-std-scale-toggle');
                if (mobStdScaleToggle) mobStdScaleToggle.addEventListener('change', (e) => toggleStdScale(e.target.checked));

                // Mobile Sidebar Logic
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const menuBtn = document.getElementById('mobile-menu-btn');
                const closeBtn = document.getElementById('sidebar-close-btn');

                function toggleSidebar(show) {
                    if (show) {
                        sidebar.classList.remove('-translate-x-full');
                        overlay.classList.remove('hidden');
                        // Small delay for opacity transition
                        setTimeout(() => overlay.classList.remove('opacity-0'), 10);
                    } else {
                        sidebar.classList.add('-translate-x-full');
                        overlay.classList.add('opacity-0');
                        setTimeout(() => overlay.classList.add('hidden'), 300);
                    }
                }

                if (menuBtn) menuBtn.addEventListener('click', () => toggleSidebar(true));
                if (closeBtn) closeBtn.addEventListener('click', () => toggleSidebar(false));
                if (overlay) overlay.addEventListener('click', () => toggleSidebar(false));

                // Resize listener
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => updateChart(), 200);
                });

                // Initial Render
                if (status) status.innerText = "Rendering filters...";
                renderDomainFilters();
                renderSelectedBenchmarkTags();
                renderBenchmarkList();

                if (status) status.innerText = "Updating chart...";
                await updateChart();

            } catch (err) {
                console.error("Init Error:", err);
                const status = document.getElementById('status-text');
                if (status) {
                    status.innerText = "Initialization Failed: " + err.message;
                    status.classList.add('text-red-600', 'font-bold');
                }
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>

</html>