<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Domain-ECI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #d1d5db;
        }

        .filter-transition {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            /* Hides the slider so that custom slider can be made */
            width: 100%;
            background: transparent;
            /* Otherwise white in Chrome */
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -6px;
            /* You need to specify a margin in Chrome, but in Firefox and IE it is automatic */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 2px solid white;
            position: relative;
            z-index: 10;
        }

        input[type=range]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 2px solid white;
            position: relative;
            z-index: 10;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 999px;
        }

        input[type=range]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 999px;
        }

        input[type=range]:focus {
            outline: none;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900 h-dvh flex flex-col">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 px-4 lg:px-6 py-4 flex justify-between items-center shadow-sm z-10 relative">
        <div class="flex items-center gap-3">
            <button id="mobile-menu-btn" class="lg:hidden p-2 -ml-2 text-gray-600 hover:bg-gray-100 rounded-md">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
            <div>
                <h1 class="text-lg lg:text-xl font-bold text-gray-800">Domain-ECI Explorer</h1>
                <p class="hidden lg:block text-sm text-gray-500">Select benchmarks to estimate capability over time</p>
            </div>
        </div>

        <!-- Desktop Controls -->
        <div class="hidden lg:flex items-center gap-4">
            <div class="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                <button id="view-chart"
                    class="px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200">
                    Chart
                </button>
                <button id="view-table"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Table
                </button>
            </div>
            <div class="w-px h-8 bg-gray-200"></div>
            <div class="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                <button id="mode-fixed"
                    class="px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200">
                    Fixed Parameters
                </button>
                <button id="mode-refit"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Refit (JMLE)
                </button>
                <button id="mode-compare"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Compare
                </button>
                <button id="mode-rank-compare"
                    class="px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all">
                    Rank Comparison
                </button>
            </div>
            <label
                class="flex items-center gap-2 cursor-pointer select-none bg-gray-50 px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm hover:bg-gray-100 transition-colors">
                <input type="checkbox" id="show-breakpoint-toggle"
                    class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="text-sm font-medium text-gray-700">Breakpoint Analysis</span>
            </label>
            <label
                class="flex items-center gap-2 cursor-pointer select-none bg-gray-50 px-3 py-1.5 rounded-lg border border-gray-200 shadow-sm hover:bg-gray-100 transition-colors">
                <input type="checkbox" id="show-ci-toggle"
                    class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                <span class="text-sm font-medium text-gray-700">Show 90% CI</span>
            </label>
            <button id="download-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                Export Data
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden relative">

        <!-- Mobile Overlay -->
        <div id="sidebar-overlay" class="absolute inset-0 bg-gray-900/50 z-20 hidden lg:hidden backdrop-blur-sm transition-opacity opacity-0"></div>

        <!-- Sidebar: Search & Filter -->
        <aside id="sidebar"
            class="fixed inset-y-0 left-0 w-80 bg-white border-r border-gray-200 flex flex-col z-30 transition-transform duration-300 transform -translate-x-full lg:relative lg:translate-x-0 shadow-[4px_0_24px_-12px_rgba(0,0,0,0.1)] lg:shadow-none">

            <!-- Mobile Close Button (Fixed at Top) -->
            <div class="lg:hidden flex-none border-b border-gray-100 px-5 py-4 flex justify-between items-center bg-white z-20">
                <h2 class="font-bold text-gray-800">Settings</h2>
                <button id="sidebar-close-btn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- Scrollable Content Container -->
            <div class="flex-1 overflow-y-auto lg:overflow-hidden lg:flex lg:flex-col">

                <!-- Mobile Controls (Scrollable) -->
                <div class="lg:hidden p-4 space-y-4 border-b border-gray-200 bg-gray-50">
                     <div class="flex flex-col space-y-1 bg-white p-1 rounded-lg border border-gray-200">
                        <button id="mobile-view-chart" class="px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900">Chart</button>
                        <button id="mobile-view-table" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Table</button>
                     </div>

                     <div class="flex flex-col space-y-1 bg-white p-1 rounded-lg border border-gray-200">
                        <button id="mobile-mode-fixed" class="px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900">Fixed Parameters</button>
                        <button id="mobile-mode-refit" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Refit (JMLE)</button>
                        <button id="mobile-mode-compare" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Compare</button>
                        <button id="mobile-mode-rank-compare" class="px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50">Rank Comparison</button>
                      </div>

                      <div class="flex items-center justify-between">
                          <span class="text-sm font-medium text-gray-700">Breakpoint Analysis</span>
                          <input type="checkbox" id="mobile-show-breakpoint-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                     </div>

                     <div class="flex items-center justify-between">
                         <span class="text-sm font-medium text-gray-700">Show 90% CI</span>
                         <input type="checkbox" id="mobile-show-ci-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500 border-gray-300">
                     </div>

                     <button id="mobile-download-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                        Export Data
                     </button>
                </div>

                <!-- Filters (Static on Desktop, Scrollable on Mobile) -->
                <div class="flex-none">
                    <div class="px-5 py-4 border-b border-gray-100 flex justify-between items-center bg-gray-50/30">
                        <h2 class="font-black text-gray-800 tracking-tight text-base">Filters</h2>
                        <span id="benchmark-count" class="bg-indigo-50 text-indigo-600 text-[10px] font-bold px-2 py-0.5 rounded-full ring-1 ring-indigo-100/50">0/0</span>
                    </div>

                    <!-- Min Scores Selector -->
                    <div class="px-5 py-3 border-b border-gray-100 bg-gray-50/30">
                        <div class="flex justify-between items-center mb-2">
                            <label for="min-benchmarks" class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Min Scores</label>
                            <span id="min-benchmarks-val" class="text-[10px] font-bold text-indigo-600 bg-white px-2 py-0.5 rounded shadow-sm ring-1 ring-gray-100">2</span>
                        </div>
                        <div class="relative w-full h-6 flex items-center">
                            <!-- Custom Ticks (Dots) on Track -->
                            <div class="absolute w-full h-1 top-1/2 -translate-y-1/2 pointer-events-none px-[8px]">
                                <div class="absolute left-[0%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[6.66%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[20%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[46.66%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                                <div class="absolute left-[100%] top-1/2 -translate-x-1/2 -translate-y-[2px] w-1 h-1 bg-gray-400 rounded-full"></div>
                            </div>
                            <input type="range" id="min-benchmarks" min="1" max="16" value="2" step="1" class="w-full relative z-20 bg-transparent">
                        </div>
                        <div class="relative w-full h-2 mt-1 px-[8px] pointer-events-none">
                            <div class="absolute left-[0%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[6.66%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[20%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[46.66%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                            <div class="absolute left-[100%] -translate-x-1/2 w-0.5 h-1.5 bg-gray-300 rounded-full"></div>
                        </div>
                    </div>

                    <!-- Domain Selection Dropdown -->
                    <div class="px-5 py-3 border-b border-gray-100">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Category</h3>
                            <button id="clear-domains" class="text-[10px] text-indigo-600 font-bold hover:text-indigo-700 transition-colors hidden">CLEAR</button>
                        </div>
                        <div class="relative">
                            <select id="domain-selector" class="w-full pl-3 pr-10 py-2 bg-gray-50 border border-gray-200 rounded-lg text-xs font-medium appearance-none focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all cursor-pointer">
                                <!-- Options will be injected here -->
                            </select>
                            <div class="absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none text-gray-400">
                                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path d="M19 9l-7 7-7-7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                </svg>
                            </div>
                        </div>
                    </div>

                    <!-- Search Section -->
                    <div class="px-5 py-3 border-b border-gray-100">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Search Benchmarks</h3>
                        </div>
                        <div class="relative group">
                            <span class="absolute inset-y-0 left-0 pl-3 flex items-center text-gray-400 group-focus-within:text-indigo-500 transition-colors">
                                <svg class="h-3.5 w-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </span>
                            <input type="text" id="search-benchmarks" placeholder="Find benchmarks..." class="w-full pl-9 pr-3 py-2 bg-gray-100 border border-gray-200 rounded-lg text-xs font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 focus:bg-white transition-all">
                        </div>
                    </div>

                    <!-- Active Labels/Filters Area -->
                    <div id="active-filters-container" class="px-5 py-3 border-b border-gray-100 hidden bg-indigo-50/10">
                        <h3 class="text-[10px] font-bold text-indigo-400 uppercase tracking-wider mb-2 font-black">Selection</h3>
                        <div class="flex flex-wrap gap-1.5 max-h-32 overflow-y-auto custom-scrollbar" id="active-filters">
                            <!-- Filter tags will be injected here -->
                        </div>
                    </div>

                    <div class="px-5 py-3 border-b border-gray-100 bg-gray-50/50 flex justify-between items-center sticky top-0 backdrop-blur-sm z-10">
                        <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Benchmarks</h2>
                        <div class="flex gap-2">
                            <button id="select-all" class="text-indigo-600 text-[10px] font-bold hover:text-indigo-800 transition-colors tracking-tight">ALL</button>
                            <span class="text-gray-300 text-[10px]">|</span>
                            <button id="deselect-all" class="text-gray-400 text-[10px] font-bold hover:text-gray-600 transition-colors tracking-tight">NONE</button>
                        </div>
                    </div>
                </div>

                <!-- Benchmark List (Scrollable on Desktop independently) -->
                <div class="lg:flex-1 lg:overflow-y-auto px-5 py-2 space-y-1 bg-white custom-scrollbar pb-8" id="benchmark-list">
                    <!-- Benchmarks list will be injected here -->
                </div>
            </div>
        </aside>

        <!-- Visualization Area -->
        <main class="flex-1 flex flex-col bg-white overflow-hidden relative">
            <div id="loading-overlay"
                class="absolute inset-0 bg-white/80 z-50 flex items-center justify-center hidden backdrop-blur-sm">
                <div class="flex flex-col items-center">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-3"></div>
                    <span class="text-gray-600 font-medium">Refitting Model...</span>
                </div>
            </div>

            <div class="flex-1 flex flex-col relative overflow-hidden" id="chart-wrapper">
                <!-- Plotly Chart -->
                <div class="flex-1 p-2 lg:p-6 relative min-h-0">
                    <div id="chart-container" class="w-full h-full"></div>
                </div>
                <div id="breakpoint-stats" class="w-full bg-white border-t border-gray-200 p-4 text-xs hidden z-10 shadow-[0_-4px_12px_rgba(0,0,0,0.05)]">
                    <h3 id="stats-title" class="font-bold text-gray-800 mb-2 border-b pb-1 inline-block mr-4">Breakpoint Analysis</h3>
                    <div id="breakpoint-content" class="text-gray-600 inline-block"></div>
                </div>
            </div>
            <div class="flex-1 px-2 lg:px-6 pb-2 lg:pb-6 pt-0 hidden overflow-auto custom-scrollbar" id="table-container">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                    <thead class="bg-gray-50 sticky top-0 z-10">
                        <tr id="table-header">
                            <!-- Headers injected via JS -->
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200" id="table-body">
                        <!-- Rows injected via JS -->
                    </tbody>
                </table>
            </div>

            <div class="px-4 lg:px-6 py-4 border-t border-gray-100 bg-gray-50 text-xs text-gray-500 flex justify-between">
                <span id="status-text">Ready.</span>
                <span>Select benchmarks to update the graph.</span>
            </div>
        </main>
    </div>

    <!-- Data Injection -->
    <script>

const RAW_DATA = {
    models: {},
    benchmarks: { 'LinearBench': { name: 'LinearBench', domain: 'Test', diff: 100, disc: 1 } },
    performances: {}
};
for(let i=0; i<20; i++) {
    const mId = 'Model' + i;
    const date = new Date(1700000000000 + i * 2592000000).toISOString().split('T')[0];
    RAW_DATA.models[mId] = { name: mId, date: date };
    RAW_DATA.performances[mId] = { 'LinearBench': 0.1 + (i/20)*0.8 };
}

    </script>
    <script>
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            const status = document.getElementById('status-text');
            if (status) {
                status.innerText = `Error: ${msg} at line ${lineNo}`;
                status.classList.add('text-red-600', 'font-bold');
            }
            alert(`Application Error: ${msg}\nLine: ${lineNo}`);
            return false;
        };

        if (typeof RAW_DATA === 'undefined') {
            document.write('<div class="p-4 bg-red-100 text-red-700 font-bold">FATAL ERROR: Data failed to load. Check RAW_DATA syntax.</div>');
            throw new Error("RAW_DATA is missing");
        }
    </script>

    <!-- App Logic -->
    <script>
        const CONFIG = {
            anchor_eci_low: 130,
            anchor_eci_high: 150,
            anchor_model_low: "Claude 3.5 Sonnet",
            anchor_model_high: "GPT-5"
        };

        // State
        const state = {
            selectedBenchmarks: new Set(["LinearBench"]),
            viewedDomain: 'All',
            searchTerm: '',
            mode: 'fixed', // 'fixed', 'refit', 'compare'
            view: 'chart', // 'chart', 'table'
            models: [], // Computed capabilities
            cachedRefit: null,
            minBenchmarks: 1,
            showCI: false,
            showBreakpoint: true
        };

        const DOMAIN_MAP = {
            "ARC AI2": "Reasoning", "BBH": "Reasoning", "GSM8K": "Math", "HellaSwag": "Reasoning",
            "LAMBADA": "Other", "MMLU": "Knowledge", "GPQA diamond": "Knowledge", "MATH level 5": "Math",
            "OTIS Mock AIME 2024-2025": "Math", "WeirdML": "Other", "Winogrande": "Reasoning",
            "TriviaQA": "Knowledge", "Cybench": "Cyber", "SimpleBench": "Other", "The Agent Company": "Agent",
            "PIQA": "Reasoning", "OpenBookQA": "Reasoning", "Balrog": "Agent", "GeoBench": "Other",
            "Fiction.LiveBench": "Writing", "FrontierMath-2025-02-28-Private": "Math", "Aider polyglot": "Coding",
            "Lech Mazur Writing": "Writing", "ARC-AGI": "Reasoning", "SWE-Bench Verified (Bash Only)": "Coding",
            "CadEval": "Coding", "SimpleQA Verified": "Knowledge", "ANLI": "Reasoning",
            "FrontierMath-Tier-4-2025-07-01-Private": "Math", "VideoMME": "Vision", "VPCT": "Other",
            "OSWorld": "Agent", "GSO-Bench": "Knowledge", "Chess Puzzles": "Other",
            "Terminal Bench": "Agent", "DeepResearch Bench": "Agent", "ScienceQA": "Knowledge"
        };

        const DOMAIN_COLORS = {
            "Reasoning": "blue", "Math": "amber", "Knowledge": "purple", "Coding": "emerald",
            "Agent": "rose", "Writing": "indigo", "Cyber": "slate", "Vision": "orange", "Other": "gray"
        };

        const ORG_COLORS = {
            'OpenAI': '#10a37f',
            'Anthropic': '#d97757',
            'Google': '#4285F4',
            'Meta': '#0668E1',
            'Microsoft': '#F25022',
            'Mistral': '#f59e0b',
            'DeepSeek': '#0ea5e9',
            'Alibaba': '#8b5cf6',
            'xAI': '#111827',
            '01.AI': '#059669',
            'TII': '#57534e',
            'Baichuan': '#db2777',
            'NVIDIA': '#76b900',
            'Other': '#9ca3af'
        };

        function getOrganization(name) {
            const n = name.toLowerCase();
            if (n.includes('gpt') || n.includes('o1') || n.includes('o3') || n.includes('o4')) return 'OpenAI';
            if (n.includes('claude')) return 'Anthropic';
            if (n.includes('gemini') || n.includes('gemma')) return 'Google';
            if (n.includes('llama')) return 'Meta';
            if (n.includes('mistral') || n.includes('mixtral')) return 'Mistral';
            if (n.includes('qwen')) return 'Alibaba';
            if (n.includes('deepseek')) return 'DeepSeek';
            if (n.includes('yi ')) return '01.AI';
            if (n.includes('phi')) return 'Microsoft';
            if (n.includes('grok')) return 'xAI';
            if (n.includes('nemotron')) return 'NVIDIA';
            if (n.includes('falcon')) return 'TII';
            if (n.includes('baichuan')) return 'Baichuan';
            return 'Other';
        }

        // Inject domain data into RAW_DATA
        if (typeof RAW_DATA !== 'undefined' && RAW_DATA.benchmarks) {
            Object.keys(RAW_DATA.benchmarks).forEach(id => {
                RAW_DATA.benchmarks[id].domain = DOMAIN_MAP[id] || "Other";
            });
        }

        function calculateBootstrapCI(performances, diffs, discs, scaling = { a: 0, b: 1 }, n_boot = 1000) {
            if (performances.length < 2) return { low: null, high: null };

            const thetas = [];
            // Optimization: Use a simpler solver or initial guess for speed?
            // For now, use standard solveFixed but maybe with fewer steps or robust logic.

            for (let i = 0; i < n_boot; i++) {
                const res_perfs = [];
                const res_diffs = [];
                const res_discs = [];
                for (let j = 0; j < performances.length; j++) {
                    const idx = Math.floor(Math.random() * performances.length);
                    res_perfs.push(performances[idx]);
                    res_diffs.push(diffs[idx]);
                    res_discs.push(discs[idx]);
                }

                // Add jitter to avoid identical resamples collapsing in rare cases (optional but good for stability)
                let theta = solveFixed(res_perfs, res_diffs, res_discs);

                // Apply scaling if provided (Refit mode) is typically A + B*theta
                // For Fixed mode, scaling is A=0, B=1 (no-op)
                theta = scaling.a + scaling.b * theta;

                thetas.push(theta);
            }

            thetas.sort((a, b) => a - b);
            const low = thetas[Math.floor(n_boot * 0.05)];
            const high = thetas[Math.floor(n_boot * 0.95)];

            return { low, high };
        }

        // --- Core Math: Sigmoid ---
        function sigmoid(x) {
            // Clip to avoid overflow/underflow
            const xc = Math.max(-100, Math.min(100, x));
            return 1.0 / (1.0 + Math.exp(-xc));
        }

        // --- IRT: Fixed Parameters Solver ---
        function solveFixed(performances, diffs, discs) {
            // Objective: Minimize sum((pred - obs)^2)
            // Using Coarse-to-Fine Grid Search for absolute stability (1D optimization)

            function getLoss(t) {
                let loss = 0;
                for (let j = 0; j < performances.length; j++) {
                    const logit = discs[j] * (t - diffs[j]);
                    const pred = sigmoid(logit);
                    const err = pred - performances[j];
                    loss += err * err;
                }
                return loss;
            }

            // 1. Coarse Search (50 to 200, step 5)
            let bestTheta = 100;
            let minLoss = Infinity;

            for (let t = 50; t <= 200; t += 5) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 2. Fine Search (±5, step 0.5)
            let start = Math.max(50, bestTheta - 5);
            let end = Math.min(200, bestTheta + 5);
            for (let t = start; t <= end; t += 0.5) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 3. Super Fine Search (±0.5, step 0.05)
            start = Math.max(50, bestTheta - 0.5);
            end = Math.min(200, bestTheta + 0.5);
            for (let t = start; t <= end; t += 0.05) {
                const l = getLoss(t);
                if (l < minLoss) { minLoss = l; bestTheta = t; }
            }

            // 4. Ultra Fine (Gradient Descent refinement)
            // Just a few steps to polish the float value
            let theta = bestTheta;
            for (let k = 0; k < 5; k++) {
                let grad = 0;
                for (let j = 0; j < performances.length; j++) {
                    const logit = discs[j] * (theta - diffs[j]);
                    const pred = sigmoid(logit);
                    grad += 2 * (pred - performances[j]) * pred * (1 - pred) * discs[j];
                }
                theta -= 0.1 * grad; // Small cautious steps
            }

            return theta;
        }

        // --- IRT: Refit Solver (JMLE) ---
        async function solveJMLE(activeBenchmarkIds, minBenchmarks) {
            // Prepare data structure: sparse matrix logic
            // We need: for each model, list of (benchmark_idx, score)
            //          for each benchmark, list of (model_idx, score)

            const allModels = Object.keys(RAW_DATA.models);
            const benchmarks = Array.from(activeBenchmarkIds);

            if (benchmarks.length === 0) return {};

            // Pre-process links for fast iteration
            const modelData = {}; // model -> [{b_id, p}]
            allModels.forEach(m => modelData[m] = []);

            const benchData = {}; // bench -> [{m_id, p}]
            benchmarks.forEach(b => benchData[b] = []);

            let totalObsCount = 0;
            allModels.forEach(m => {
                if (RAW_DATA.performances[m]) {
                    benchmarks.forEach(b => {
                        if (RAW_DATA.performances[m][b] !== undefined) {
                            const p = RAW_DATA.performances[m][b];
                            modelData[m].push({ b, p });
                            benchData[b].push({ m, p });
                            totalObsCount++;
                        }
                    });
                }
            });

            // Filter models by minimum benchmarks
            console.log("Filtering: Total Models:", allModels.length, "MinBenchmarks:", minBenchmarks);
            // Debug how many benchmarks each model has
            // const debug counts = allModels.map(m => modelData[m].length);
            // console.log("Distribution:", counts.slice(0, 20));

            const models = allModels.filter(m => modelData[m].length >= (minBenchmarks || 1));
            console.log("Models after filtering:", models.length);

            if (models.length === 0) return {};

            try {
                // Init parameters
                const SHIFT = 100.0;
                let ability = {};
                models.forEach(m => ability[m] = 0.0);

                let difficulty = {};
                let discriminability = {};

                benchmarks.forEach(b => {
                    difficulty[b] = 0.0;
                    discriminability[b] = 1.0;
                });

                console.log(`Fitting JMLE on ${models.length} filtered models...`);

                const iterations = 100;
                const lr = 2.0;
                const nParams = models.length + benchmarks.length + benchmarks.length;
                const regStrength = 0.1;
                const regLambda = regStrength / nParams;

                for (let iter = 0; iter < iterations; iter++) {
                    // 1. Optimize Abilities
                    models.forEach(m => {
                        const obs = modelData[m];
                        if (obs.length === 0) return;

                        let theta = ability[m];
                        for (let k = 0; k < 5; k++) {
                            let grad = 0;
                            let w_sum = 0;
                            obs.forEach(o => {
                                const d = difficulty[o.b];
                                const a = discriminability[o.b];
                                const logit = a * (theta - d);
                                const pred = sigmoid(logit);
                                const w = pred * (1 - pred);
                                grad += 2 * (pred - o.p) * w * a;
                                w_sum += 2 * w * a * a;
                            });
                            grad += 2 * regLambda * theta;
                            w_sum += 2 * regLambda;
                            if (w_sum > 1e-9) theta -= grad / (w_sum + 1e-9);
                            else theta -= lr * grad;
                        }
                        ability[m] = Math.max(-100, Math.min(100, theta));
                    });

                    // 2. Optimize Item Params
                    benchmarks.forEach(b => {
                        const obs = benchData[b];
                        if (obs.length === 0) return;
                        let d = difficulty[b];
                        let a = discriminability[b];
                        for (let k = 0; k < 5; k++) {
                            let d_grad = 0, d_hess = 0, a_grad = 0, a_hess = 0;
                            obs.forEach(o => {
                                if (ability[o.m] === undefined) return;
                                const theta = ability[o.m];
                                const logit = a * (theta - d);
                                const pred = sigmoid(logit);
                                const err = pred - o.p;
                                const w = pred * (1 - pred);
                                d_grad += 2 * err * w * (-a);
                                d_hess += 2 * w * a * a;
                                const term = (theta - d);
                                a_grad += 2 * err * w * term;
                                a_hess += 2 * w * term * term;
                            });
                            d_grad += 2 * regLambda * d;
                            d_hess += 2 * regLambda;
                            a_grad += 2 * regLambda * a;
                            a_hess += 2 * regLambda;
                            if (d_hess > 1e-9) d -= d_grad / (d_hess + 1e-9); else d -= lr * d_grad;
                            if (a_hess > 1e-9) a -= a_grad / (a_hess + 1e-9); else a -= (lr * 0.1) * a_grad;
                            a = Math.max(0.1, Math.min(5.0, a));
                        }
                        difficulty[b] = Math.max(-100, Math.min(100, d));
                        discriminability[b] = a;
                    });

                    if (iter % 20 === 0) await new Promise(r => setTimeout(r, 0));
                }

                // UN-SHIFT parameters
                models.forEach(m => ability[m] += SHIFT);
                benchmarks.forEach(b => difficulty[b] += SHIFT);

                // --- Final Scale Alignment (Anchor Method) ---
                // Hardcoded to avoid ReferenceErrors
                const ANCHOR_LOW_ID = "Claude 3.5 Sonnet";
                const ANCHOR_HIGH_ID = "GPT-5";
                const TARGET_LOW = 130.0;
                const TARGET_HIGH = 150.0;

                let finalA = 0;
                let finalB = 1;

                function performPopulationNorm() {
                    let sum = 0, sqSum = 0, n = 0;
                    models.forEach(m => {
                        const val = ability[m];
                        if (val !== undefined) { sum += val; sqSum += val * val; n++; }
                    });
                    if (n < 2) return;
                    const mean = sum / n;
                    const std = Math.sqrt(sqSum / n - mean * mean);
                    // Target Mean=100, SD=15
                    finalB = 15.0 / (std + 1e-9);
                    finalA = 100.0 - finalB * mean;
                    console.log(`Fallback: Pop Norm Mean=${mean.toFixed(2)} SD=${std.toFixed(2)}`);
                }

                if (ability[ANCHOR_LOW_ID] !== undefined && ability[ANCHOR_HIGH_ID] !== undefined) {
                    const tLow = ability[ANCHOR_LOW_ID];
                    const tHigh = ability[ANCHOR_HIGH_ID];
                    const rawDiff = tHigh - tLow;
                    const targetDiff = TARGET_HIGH - TARGET_LOW;

                    // Compute slope
                    finalB = targetDiff / rawDiff;
                    // Compute intercept: Target = A + B * Raw
                    // A = Target - B * Raw
                    finalA = TARGET_LOW - finalB * tLow;

                    console.log(`Anchors: Low(${tLow.toFixed(2)}->${TARGET_LOW}), High(${tHigh.toFixed(2)}->${TARGET_HIGH})`);
                    console.log(`Params: A=${finalA.toFixed(2)}, B=${finalB.toFixed(2)}`);

                    if (Math.abs(rawDiff) < 1.0 || finalB < 0) {
                        console.warn("Anchors degenerate. Fallback.");
                        performPopulationNorm();
                    }
                } else {
                    console.warn("Anchors missing. Fallback.");
                    performPopulationNorm();
                }

                // Apply Match
                models.forEach(m => {
                    if (ability[m] !== undefined) ability[m] = finalA + finalB * ability[m];
                });

                return { ability, difficulty, discriminability, scaling: { a: finalA, b: finalB } };

            } catch (e) {
                console.error("JMLE Failed:", e);
                // Return empty to avoid crash
                return {};
            }
        }

        // --- Breakpoint Analysis Logic ---

        function linearRegression(points) {
            const n = points.length;
            if (n < 2) return null;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumXY += p.x * p.y;
                sumXX += p.x * p.x;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            let rss = 0;
            points.forEach(p => {
                const pred = slope * p.x + intercept;
                rss += (p.y - pred) ** 2;
            });

            return { slope, intercept, rss, n, k: 2 };
        }

        function calculateBIC(n, k, rss) {
            if (rss <= 0) return -Infinity;
            return n * Math.log(rss / n) + k * Math.log(n);
        }

        function solveConstrained(points, x_bp) {
            const n = points.length;
            let s_u = 0, s_v = 0, s_y = 0;
            let s_uu = 0, s_uv = 0, s_uy = 0;
            let s_vv = 0, s_vy = 0;

            for (let i = 0; i < n; i++) {
                const u = points[i].x - x_bp;
                const v = Math.max(0, u);
                const y = points[i].y;

                s_u += u; s_v += v; s_y += y;
                s_uu += u * u; s_uv += u * v; s_uy += u * y;
                s_vv += v * v; s_vy += v * y;
            }

            // Normal Equations for 3 variables: y = A + B*u + C*v
            // Matrix M
            const M00 = n, M01 = s_u, M02 = s_v;
            const M10 = s_u, M11 = s_uu, M12 = s_uv;
            const M20 = s_v, M21 = s_uv, M22 = s_vv;

            const R0 = s_y, R1 = s_uy, R2 = s_vy;

            const det = M00 * (M11 * M22 - M12 * M21) -
                        M01 * (M10 * M22 - M12 * M20) +
                        M02 * (M10 * M21 - M11 * M20);

            if (Math.abs(det) < 1e-9) return null;

            const invDet = 1.0 / det;

            const A = invDet * (R0 * (M11 * M22 - M12 * M21) + R1 * (M02 * M21 - M01 * M22) + R2 * (M01 * M12 - M02 * M11));
            const B = invDet * (R0 * (M12 * M20 - M10 * M22) + R1 * (M00 * M22 - M02 * M20) + R2 * (M10 * M02 - M00 * M12));
            const C = invDet * (R0 * (M10 * M21 - M11 * M20) + R1 * (M01 * M20 - M00 * M21) + R2 * (M00 * M11 - M01 * M10));

            // Parameters
            const slope1 = B;
            const slope2 = B + C;
            const intercept1 = A - B * x_bp;
            const intercept2 = A - (B + C) * x_bp;

            let rss = 0;
            for (let i = 0; i < n; i++) {
                const u = points[i].x - x_bp;
                const v = Math.max(0, u);
                const pred = A + B * u + C * v;
                rss += (points[i].y - pred) ** 2;
            }

            return {
                intercept1, slope1,
                intercept2, slope2,
                rss,
                k: 4 // 3 coeffs + 1 breakpoint parameter
            };
        }

        function breakpointRegression(points) {
            const n = points.length;
            if (n < 6) return null;

            points.sort((a, b) => a.x - b.x);
            let best = { rss: Infinity };
            const minPoints = 3;

            for (let i = minPoints; i < n - minPoints; i++) {
                const candidateX = points[i].x;
                const fit = solveConstrained(points, candidateX);
                if (fit && fit.rss < best.rss) {
                    best = { ...fit, splitX: candidateX, splitIndex: i };
                }
            }
            return best.rss === Infinity ? null : best;
        }

        function getFrontier(points) {
            if (points.length === 0) return [];
            // Sort by x (date)
            // Shallow copy to avoid mutating original if needed, though sort is in-place
            const sorted = [...points].sort((a, b) => a.x - b.x);

            const frontier = [];
            let maxVal = -Infinity;

            sorted.forEach(p => {
                if (p.y > maxVal) {
                    frontier.push(p);
                    maxVal = p.y;
                }
            });
            return frontier;
        }

        function bootstrapFrontier(allPoints, n_boot = 1000) {
            const splitDates = [];

            for (let b = 0; b < n_boot; b++) {
                // Pairs Bootstrap: Resample full dataset
                const sample = [];
                for(let i=0; i<allPoints.length; i++) {
                    sample.push(allPoints[Math.floor(Math.random() * allPoints.length)]);
                }

                // Compute Frontier of Sample
                const frontier = getFrontier(sample);

                // Ensure enough points on frontier to fit
                if (frontier.length >= 6) {
                    const res = breakpointRegression(frontier);
                    if (res) splitDates.push(res.splitX);
                }
            }

            if (splitDates.length === 0) return null;
            splitDates.sort((a, b) => a - b);
            const low = splitDates[Math.floor(splitDates.length * 0.05)];
            const high = splitDates[Math.floor(splitDates.length * 0.95)];

            return { low, high, median: splitDates[Math.floor(splitDates.length * 0.5)] };
        }

        // --- UI Rendering ---

        function renderBenchmarkList() {
            const list = document.getElementById('benchmark-list');
            const term = state.searchTerm.toLowerCase();
            const viewed = state.viewedDomain;

            const filtered = Object.entries(RAW_DATA.benchmarks).filter(([id, b]) => {
                const matchesSearch = b.name.toLowerCase().includes(term);
                const matchesDomain = (viewed === 'All' || b.domain === viewed);
                return matchesSearch && matchesDomain;
            }).sort((a, b) => a[1].name.localeCompare(b[1].name));

            list.innerHTML = '';
            filtered.forEach(([id, meta]) => {
                const isSelected = state.selectedBenchmarks.has(id);
                const color = DOMAIN_COLORS[meta.domain] || 'gray';

                const div = document.createElement('div');
                div.className = `group flex items-center p-2.5 rounded-xl border filter-transition cursor-pointer ${isSelected ? 'border-indigo-200 bg-indigo-50/50 shadow-sm' : 'border-transparent hover:border-gray-100 hover:bg-gray-50'}`;
                div.innerHTML = `
                    <div class="flex-shrink-0 mr-3">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} class="w-4 h-4 rounded text-indigo-600 focus:ring-indigo-500 border-gray-300 pointer-events-none transition-all">
                    </div>
                    <div class="min-w-0 flex-1">
                        <div class="text-sm font-medium ${isSelected ? 'text-indigo-900' : 'text-gray-700'} truncate">${meta.name}</div>
                        <div class="flex items-center gap-2 mt-0.5">
                            <span class="text-[9px] font-bold uppercase tracking-wider text-${color}-600 bg-${color}-50 px-1.5 py-0.5 rounded-md border border-${color}-100">${meta.domain}</span>
                        </div>
                    </div>
                `;

                div.addEventListener('click', () => {
                    if (state.selectedBenchmarks.has(id)) state.selectedBenchmarks.delete(id);
                    else state.selectedBenchmarks.add(id);
                    renderSelectedBenchmarkTags();
                    renderBenchmarkList();
                    updateChart();
                });

                list.appendChild(div);
            });

            updateCount();
        }

        function renderDomainFilters() {
            const selector = document.getElementById('domain-selector');
            if (!selector) return;

            if (typeof RAW_DATA === 'undefined' || !RAW_DATA.benchmarks) {
                selector.innerHTML = '<option>Data Error</option>';
                return;
            }

            const domains = ['All', ...[...new Set(Object.values(DOMAIN_MAP))].sort()];

            selector.innerHTML = '';
            domains.forEach(domain => {
                const count = domain === 'All'
                    ? Object.keys(RAW_DATA.benchmarks).length
                    : Object.values(RAW_DATA.benchmarks).filter(b => b.domain === domain).length;

                const option = document.createElement('option');
                option.value = domain;
                option.text = `${domain} (${count})`;
                option.selected = state.viewedDomain === domain;
                selector.appendChild(option);
            });
        }

        function renderSelectedBenchmarkTags() {
            const container = document.getElementById('active-filters-container');
            const tagArea = document.getElementById('active-filters');
            const resetBtn = document.getElementById('clear-domains');

            if (state.selectedBenchmarks.size === 0) {
                container.classList.add('hidden');
                resetBtn.classList.add('hidden');
                return;
            }

            container.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
            resetBtn.innerText = "CLEAR ALL";

            tagArea.innerHTML = '';

            const selectedIds = Array.from(state.selectedBenchmarks).sort((a, b) => {
                return RAW_DATA.benchmarks[a].name.localeCompare(RAW_DATA.benchmarks[b].name);
            });

            selectedIds.forEach(id => {
                const meta = RAW_DATA.benchmarks[id];
                const domainColor = DOMAIN_COLORS[meta.domain] || 'gray';

                const tag = document.createElement('div');
                tag.className = `flex items-center px-2 py-0.5 rounded-md bg-${domainColor}-100 text-${domainColor}-700 text-[10px] font-bold border border-${domainColor}-200 transition-all hover:bg-${domainColor}-200 cursor-pointer shadow-sm mb-1`;
                tag.innerHTML = `
                    <span class="truncate max-w-[120px]">${meta.name}</span>
                    <svg class="w-3 h-3 ml-1 opacity-60 hover:opacity-100 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                `;

                tag.onclick = (e) => {
                    e.stopPropagation();
                    state.selectedBenchmarks.delete(id);
                    renderSelectedBenchmarkTags();
                    renderBenchmarkList();
                    updateChart();
                };
                tagArea.appendChild(tag);
            });
        }

        function updateCount() {
            const activeBenchmarksCount = state.selectedBenchmarks.size;
            const countEl = document.getElementById('benchmark-count');
            if (countEl) countEl.innerText = `${activeBenchmarksCount}/${Object.keys(RAW_DATA.benchmarks).length}`;
        }

        // --- Smart Label Placement ---
        function selectNonOverlappingLabels(points, xDomain, yDomain, isMobile) {
            // points: Array of { id, x, y, count, name }
            // xDomain: [min, max]
            // yDomain: [min, max]

            const xSpan = xDomain[1] - xDomain[0] || 1;
            const ySpan = yDomain[1] - yDomain[0] || 1;

            const norm = p => ({
                ...p,
                nx: (p.x - xDomain[0]) / xSpan,
                ny: (p.y - yDomain[0]) / ySpan,
                charLen: (p.name || '').length
            });

            // Priorities: High benchmark count first
            const normPoints = points.map(norm).sort((a, b) => b.count - a.count);

            const placedLabels = []; // {l, r, t, b}
            const results = new Map(); // id -> textposition

            // Heuristic dimensions in normalized coordinates (0..1)
            // Point radius (approximate circular dominance)
            const pr = 0.01;
            const pointBoxes = normPoints.map(p => ({
                l: p.nx - pr, r: p.nx + pr,
                b: p.ny - pr, t: p.ny + pr
            }));

            // Label dimensions
            const charWidth = isMobile ? 0.02 : 0.007; // Approx width per char normalized
            const labelHeight = isMobile ? 0.06 : 0.04;
            const offset = 0.015;

            // Positions to try in order of preference
            const positions = [
                { name: 'top center', dx: 0, dy: 1 },
                { name: 'bottom center', dx: 0, dy: -1 },
                { name: 'middle right', dx: 1, dy: 0 },
                { name: 'middle left', dx: -1, dy: 0 },
                { name: 'top right', dx: 1, dy: 1 },
                { name: 'top left', dx: -1, dy: 1 },
                { name: 'bottom right', dx: 1, dy: -1 },
                { name: 'bottom left', dx: -1, dy: -1 }
            ];

            const intersect = (r1, r2) => {
                return !(r2.l > r1.r || r2.r < r1.l || r2.t < r1.b || r2.b > r1.t);
            };

            for (const p of normPoints) {
                // Estimate label width based on char length
                // Min width 0.04 to avoid tiny boxes for short names
                const w = Math.max(0.04, p.charLen * charWidth);
                const h = labelHeight;

                for (const pos of positions) {
                    let l, r, b, t;

                    // Calculate box based on position relative to point (nx, ny)
                    if (pos.name.includes('top')) {
                        b = p.ny + offset;
                        t = b + h;
                    } else if (pos.name.includes('bottom')) {
                        t = p.ny - offset;
                        b = t - h;
                    } else {
                        // middle
                        b = p.ny - h / 2;
                        t = p.ny + h / 2;
                    }

                    if (pos.name.includes('right')) {
                        l = p.nx + offset;
                        r = l + w;
                    } else if (pos.name.includes('left')) {
                        r = p.nx - offset;
                        l = r - w;
                    } else {
                        // center
                        l = p.nx - w / 2;
                        r = p.nx + w / 2;
                    }

                    const box = { l, r, b, t };

                    // Collision Check
                    let collision = false;

                    // 0. Boundary Check
                    // If label goes outside the chart area (0-1), discard this position.
                    // If all positions fail, the label is not placed (hidden).
                    if (box.l < 0 || box.r > 1 || box.b < 0 || box.t > 1) {
                        collision = true;
                        // Do not continue inner loop here, checking bounds is fatal for this position
                    }

                    if (!collision) {
                        // 1. Check against accepted labels
                        for (const other of placedLabels) {
                            if (intersect(box, other)) { collision = true; break; }
                        }
                    }

                    if (!collision) {
                        // 2. Check against ALL points
                        // We must avoid covering any point, including our own (though offsets usually handle own)
                        for (const pb of pointBoxes) {
                            if (intersect(box, pb)) { collision = true; break; }
                        }
                    }

                    if (collision) continue;

                    // Accepted
                    placedLabels.push(box);
                    results.set(p.id, pos.name);
                    break; // Stop trying positions for this point
                }
            }

            return results;
        }

        // --- Processing & Rendering ---

        function renderTable(points, mode) {
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            const isMobile = window.innerWidth < 1024;

            tableBody.innerHTML = '';
            tableHeader.innerHTML = '';

            let headers = [];
            if (mode === 'compare') {
                headers = ['Model', 'Date', 'Fixed ECI', 'Refit ECI', 'Benchmarks Count'];
            } else if (mode === 'rank-compare') {
                headers = ['Model', 'Date', 'Fixed Rank', 'Refit Rank', 'Benchmarks Count'];
            } else {
                headers = ['Model', 'Date', 'ECI', 'Benchmarks Count'];
            }

            const cellPadding = isMobile ? "px-2 py-2" : "px-6 py-4";
            const headerPadding = isMobile ? "px-2 py-3" : "px-6 py-3";
            const fontSize = isMobile ? "text-xs" : "text-sm";

            headers.forEach(h => {
                if (isMobile) {
                    if (h === 'Benchmarks Count') h = 'Count';
                    if (h === 'Fixed ECI') h = 'Fixed';
                    if (h === 'Refit ECI') h = 'Refit';
                }
                const th = document.createElement('th');
                th.className = `${headerPadding} text-left text-xs font-bold text-gray-500 uppercase tracking-wider`;
                th.innerText = h;
                tableHeader.appendChild(th);
            });

            // Helper to format CI
            const fmtCI = (val, ci) => {
                if (val === undefined || val === null) return '-';
                let s = val.toFixed(2);
                if (ci && ci.low !== null && ci.high !== null) {
                    s += ` <span class="text-[10px] text-gray-400">[${ci.low.toFixed(2)}, ${ci.high.toFixed(2)}]</span>`;
                }
                return s;
            };

            // Sort by Date descending (newest first) usually better for table?
            const pointsWithDate = points.map(p => {
                 const m = RAW_DATA.models[p.id];
                 return { ...p, dateStr: m ? m.date : (p.dateStr || '-') };
            });

            pointsWithDate.sort((a, b) => new Date(b.dateStr) - new Date(a.dateStr));

            pointsWithDate.forEach(p => {
                const tr = document.createElement('tr');
                tr.className = `hover:bg-gray-50 transition-colors ${fontSize}`;

                const modelClass = isMobile
                    ? `${cellPadding} font-medium text-gray-900 max-w-[120px] truncate cursor-pointer`
                    : `${cellPadding} whitespace-nowrap font-medium text-gray-900`;

                const modelClick = isMobile ? 'onclick="this.classList.toggle(\'truncate\')"' : '';

                let rowHTML = `
                    <td class="${modelClass}" ${modelClick}>${p.name}</td>
                    <td class="${cellPadding} whitespace-nowrap text-gray-500">${p.dateStr}</td>
                `;

                if (mode === 'compare') {
                    // p.x is Fixed, p.y is Refit
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.x, p.ciFixed)}</td>
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.y, p.ciRefit)}</td>
                    `;
                } else if (mode === 'rank-compare') {
                    // p.x is Fixed Rank, p.y is Refit Rank
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${p.x}</td>
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${p.y}</td>
                    `;
                } else {
                    // p.y is ECI
                    rowHTML += `
                        <td class="${cellPadding} whitespace-nowrap text-gray-700 font-mono">${fmtCI(p.y, p.ci)}</td>
                    `;
                }

                rowHTML += `<td class="${cellPadding} whitespace-nowrap text-gray-500 text-center">${p.count}</td>`;
                tr.innerHTML = rowHTML;
                tableBody.appendChild(tr);
            });
        }

        async function updateChart() {
            const status = document.getElementById('status-text');
            const loader = document.getElementById('loading-overlay');
            const activeBenchmarks = Array.from(state.selectedBenchmarks);

            updateCount();

            if (activeBenchmarks.length === 0) {
                Plotly.purge('chart-container');
                if (state.view === 'table') {
                    renderTable([], state.mode);
                }
                status.innerText = "Select at least one benchmark.";
                return;
            }

            try {
                const plotData = [];
                const isMobile = window.innerWidth < 1024;
                let layout = {
                    title: {
                        text: 'Model Capability (ECI) over Time',
                        font: { family: 'Inter', size: isMobile ? 16 : 22, weight: 900, color: '#111827' }
                    },
                    xaxis: { title: { text: 'Release Date', font: { weight: 600 } }, gridcolor: '#f3f4f6', zeroline: false, automargin: true },
                    yaxis: { title: { text: 'Domain-specific ECI', font: { weight: 600 } }, gridcolor: '#f3f4f6', zeroline: false, automargin: true },
                    hovermode: 'closest',
                    template: 'plotly_white',
                    margin: isMobile ? { t: 60, r: 40, l: 40, b: 80 } : { t: 90, r: 50, l: 80, b: 100 },
                    legend: {
                        orientation: 'h',
                        y: isMobile ? -0.2 : -0.15,
                        x: 0.5,
                        xanchor: 'center',
                        font: { size: isMobile ? 10 : 13, weight: 500 }
                    },
                    font: { family: 'Inter, sans-serif' }
                };

                // Helper to get top models for labeling (prioritize models with data)
                const getTopModelIds = (limit = 20) => {
                    return Object.keys(RAW_DATA.models)
                        .map(id => ({
                            id,
                            count: Object.keys(RAW_DATA.performances[id] || {}).filter(b => activeBenchmarks.includes(b)).length
                        }))
                        .filter(x => x.count >= state.minBenchmarks)
                        .sort((a, b) => b.count - a.count)
                        .slice(0, limit)
                        .map(x => x.id);
                };

                if (state.mode === 'compare' || state.mode === 'rank-compare') {
                    loader.classList.remove('hidden');
                    status.innerText = "Computing comparison...";
                    await new Promise(r => setTimeout(r, 50));

                    // 1. Calculate Scores
                    const fixedScores = {};
                    Object.keys(RAW_DATA.models).forEach(modelId => {
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[modelId][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });
                        if (perfs.length >= state.minBenchmarks) {
                            fixedScores[modelId] = solveFixed(perfs, diffs, discs);
                        }
                    });
                    const refitResult = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                    const refitScores = refitResult.ability || {};
                    const refitDiffs = refitResult.difficulty || {};
                    const refitDiscs = refitResult.discriminability || {};
                    const refitScaling = refitResult.scaling || { a: 0, b: 1 };

                    // 2. Filter & Collect
                    const rawPoints = []; // {id, x, y, count}

                    Object.keys(refitScores).forEach(modelId => {
                        if (fixedScores[modelId] !== undefined) {
                            const m = RAW_DATA.models[modelId];
                            const cx = fixedScores[modelId];
                            const cy = refitScores[modelId];
                            const count = Object.keys(RAW_DATA.performances[modelId] || {}).filter(b => activeBenchmarks.includes(b)).length;

                            let ciFixed = { low: null, high: null };
                            let ciRefit = { low: null, high: null };

                            if (state.showCI && state.mode === 'compare') { // Only calculate CI for standard compare
                                // Calc Fixed CI
                                const perfs = [], diffs = [], discs = [];
                                activeBenchmarks.forEach(bId => {
                                    if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                        perfs.push(RAW_DATA.performances[modelId][bId]);
                                        diffs.push(RAW_DATA.benchmarks[bId].diff);
                                        discs.push(RAW_DATA.benchmarks[bId].disc);
                                    }
                                });
                                ciFixed = calculateBootstrapCI(perfs, diffs, discs);

                                // Calc Refit CI (using Bootstrapped Ability on Fixed Refit Item Params)
                                const rPerfs = [], rDiffs = [], rDiscs = [];
                                activeBenchmarks.forEach(bId => {
                                    if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                        rPerfs.push(RAW_DATA.performances[modelId][bId]);
                                        // Use the difficulty/disc from the JMLE result
                                        const d = refitDiffs[bId];
                                        const a = refitDiscs[bId];
                                        if (d !== undefined && a !== undefined) {
                                            rDiffs.push(d);
                                            rDiscs.push(a);
                                        }
                                    }
                                });
                                if (rDiffs.length === rPerfs.length) {
                                    ciRefit = calculateBootstrapCI(rPerfs, rDiffs, rDiscs, refitScaling);
                                }
                            }

                            rawPoints.push({
                                id: modelId,
                                x: cx, // Store raw scores initially
                                y: cy,
                                count,
                                name: m.name,
                                ciFixed,
                                ciRefit
                            });
                        }
                    });

                    // Rank Compare Logic Transformation
                    if (state.mode === 'rank-compare') {
                        // Sort by Fixed (descending) -> Assign Rank
                        const sortedByFixed = [...rawPoints].sort((a, b) => b.x - a.x);
                        sortedByFixed.forEach((p, i) => p.fixedRank = i + 1);

                        // Sort by Refit (descending) -> Assign Rank
                        const sortedByRefit = [...rawPoints].sort((a, b) => b.y - a.y);
                        sortedByRefit.forEach((p, i) => p.refitRank = i + 1);

                        // Update x, y to Ranks
                        rawPoints.forEach(p => {
                            p.x = p.fixedRank;
                            p.y = p.refitRank;
                        });

                        // Calculate Spearman Correlation
                        // rho = 1 - (6 * sum(d^2)) / (n * (n^2 - 1))
                        const n = rawPoints.length;
                        if (n > 1) {
                            let sumD2 = 0;
                            rawPoints.forEach(p => {
                                const d = p.fixedRank - p.refitRank;
                                sumD2 += d * d;
                            });
                            const rho = 1 - (6 * sumD2) / (n * (n * n - 1));
                            status.innerText = `Spearman Correlation: ${rho.toFixed(4)} (${n} models)`;
                        } else {
                            status.innerText = "Not enough models for correlation.";
                        }

                        // Display Largest Deviations
                        const deviations = [...rawPoints];
                        deviations.forEach(p => p.delta = p.fixedRank - p.refitRank); // Positive = Improved in Refit (Lower Rank Number)

                        deviations.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));
                        const topDeviations = deviations.slice(0, 5);

                        const bpStatsDiv = document.getElementById('breakpoint-stats');
                        const bpContentDiv = document.getElementById('breakpoint-content');

                        if (topDeviations.length > 0) {
                            bpStatsDiv.classList.remove('hidden');

                            // Update Title
                            const titleEl = document.getElementById('stats-title');
                            if (titleEl) titleEl.innerText = "Rank Deviations";

                            let html = `<div class="space-y-1">`;

                            topDeviations.forEach(d => {
                                const valStr = d.delta > 0 ? `+${d.delta}` : `${d.delta}`;
                                const colClass = d.delta > 0 ? 'text-green-600' : (d.delta < 0 ? 'text-red-600' : 'text-gray-500');
                                html += `<div class="flex justify-between items-center text-[10px]">
                                            <span class="truncate max-w-[140px]" title="${d.name}">${d.name}</span>
                                            <span class="font-mono font-bold ${colClass}">${valStr}</span>
                                         </div>`;
                            });
                            html += `</div><div class="mt-2 text-[9px] text-gray-400 border-t pt-1">Fixed Rank vs Refit Rank<br>(+ means better Refit rank)</div>`;

                            bpContentDiv.innerHTML = html;
                        }
                    }

                    // 3. Axis Scaling
                    let xRange = [0, 1], yRange = [0, 1];
                    if (rawPoints.length > 0) {
                        const xs = rawPoints.map(p => p.x);
                        const ys = rawPoints.map(p => p.y);
                        const xMin = Math.min(...xs), xMax = Math.max(...xs);
                        const yMin = Math.min(...ys), yMax = Math.max(...ys);
                        const xPad = (xMax - xMin || 1) * 0.08;
                        const yPad = (yMax - yMin || 1) * 0.08;

                        // For ranks, we want 1 to be "top", so we might want to reverse ranges?
                        // But standard plot is (0,0) at bottom-left.
                        // If we want 1 at top-right (best-best), we need 1 to be high value.
                        // But rank 1 is numerically low.
                        // Let's reverse axes for Rank mode so 1 is at top/right if desired,
                        // OR just plot numerically 1..N (1 is bottom-left).
                        // Usually, rank plots have 1 at top-left or top-right.
                        // Let's stick to standard numerical for now (1 is bottom-left).
                        // Actually, reversing axis is better for "performance" intuition.
                        if (state.mode === 'rank-compare') {
                             xRange = [xMax + xPad, Math.max(0, xMin - xPad)]; // Reversed: N -> 1
                             yRange = [yMax + yPad, Math.max(0, yMin - yPad)]; // Reversed: N -> 1
                        } else {
                             xRange = [xMin - xPad, xMax + xPad];
                             yRange = [yMin - yPad, yMax + yPad];
                        }

                        layout.xaxis.range = xRange;
                        layout.yaxis.range = yRange;

                        // Trend Line (Diagonal for Rank Compare means perfect agreement)
                        plotData.push({
                            x: xRange, y: xRange, // Diagonal y=x
                            mode: 'lines', type: 'scatter', name: 'Agreement',
                            line: { dash: 'dash', color: 'rgba(0,0,0,0.15)', width: 1.5 }, showlegend: false, hoverinfo: 'none'
                        });
                    }

                    if (state.view === 'table') {
                        document.getElementById('chart-wrapper').classList.add('hidden');
                        document.getElementById('table-container').classList.remove('hidden');
                        renderTable(rawPoints, state.mode);
                        if (state.mode !== 'rank-compare') status.innerText = `Showing ${rawPoints.length} models in table.`;
                        loader.classList.add('hidden');
                        return;
                    }

                    document.getElementById('table-container').classList.add('hidden');
                    document.getElementById('chart-wrapper').classList.remove('hidden');

                    // Smart Labeling
                    const labelPositions = selectNonOverlappingLabels(rawPoints, xRange, yRange, isMobile);

                    // Deconstruct for Plotly
                    // Group by Organization
                    const orgGroups = {};
                    rawPoints.forEach(p => {
                        const org = getOrganization(p.name);
                        if (!orgGroups[org]) orgGroups[org] = [];
                        orgGroups[org].push(p);
                    });

                    // Create Traces for each organization
                    Object.keys(orgGroups).sort().forEach(org => {
                        const points = orgGroups[org];
                        const x = [], y = [], hovertext = [], displayLabels = [], textPositions = [];

                        points.forEach(p => {
                            x.push(p.x);
                            y.push(p.y);
                            hovertext.push(p.name);
                            const pos = labelPositions.get(p.id);
                            displayLabels.push(pos ? p.name : '');
                            textPositions.push(pos || 'top center');
                        });

                        let hoverTemplate = '';
                        let customData = [];

                        if (state.mode === 'rank-compare') {
                             hoverTemplate = '<b>%{hovertext}</b><br>Fixed Rank: %{x}<br>Refit Rank: %{y}<br>Change: %{customdata}<extra></extra>';
                             customData = points.map(p => {
                                 const d = p.fixedRank - p.refitRank;
                                 return d > 0 ? `+${d}` : `${d}`;
                             });
                        } else {
                             hoverTemplate = '<b>%{hovertext}</b><br>Fixed: %{x:.1f} %{customdata[0]}<br>Refit: %{y:.1f} %{customdata[1]}<extra></extra>';
                             customData = points.map(p => [
                                p.ciFixed.low ? `[${p.ciFixed.low.toFixed(1)}, ${p.ciFixed.high.toFixed(1)}]` : '',
                                p.ciRefit.low ? `[${p.ciRefit.low.toFixed(1)}, ${p.ciRefit.high.toFixed(1)}]` : ''
                            ]);
                        }

                        plotData.push({
                            x, y,
                            hovertext: hovertext,
                            text: displayLabels,
                            mode: 'markers+text',
                            type: 'scatter',
                            name: org,
                            textposition: textPositions,
                            textfont: { size: 10, color: '#4b5563', weight: 600 },
                            marker: {
                                color: ORG_COLORS[org] || ORG_COLORS['Other'],
                                size: 9,
                                line: { width: 1, color: 'white' },
                                opacity: 0.85
                            },
                            error_x: (state.showCI && state.mode === 'compare') ? {
                                type: 'data',
                                array: points.map(p => (p.ciFixed.high !== null ? p.ciFixed.high - p.x : null)),
                                arrayminus: points.map(p => (p.ciFixed.low !== null ? p.x - p.ciFixed.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            error_y: (state.showCI && state.mode === 'compare') ? {
                                type: 'data',
                                array: points.map(p => (p.ciRefit.high !== null ? p.ciRefit.high - p.y : null)),
                                arrayminus: points.map(p => (p.ciRefit.low !== null ? p.y - p.ciRefit.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            hovertemplate: hoverTemplate,
                            customdata: customData
                        });
                    });

                    if (state.mode === 'rank-compare') {
                        layout.title.text = 'Comparison: Fixed vs. Refit Ranks';
                        layout.xaxis.title.text = 'Fixed Parameters Rank (1=Best)';
                        layout.yaxis.title.text = 'Refit (JMLE) Rank (1=Best)';
                    } else {
                        layout.title.text = 'Comparison: Fixed vs. Refit ECI';
                        layout.xaxis.title.text = 'Fixed Parameters ECI';
                        layout.yaxis.title.text = 'Refit (JMLE) ECI';
                        status.innerText = `Comparing ${rawPoints.length} models.`;
                    }

                } else {
                    const rawPoints = []; // {id, x (time), y, count, name}
                    const isFixed = state.mode === 'fixed';

                    if (state.mode === 'fixed') {
                        Object.keys(RAW_DATA.models).forEach(modelId => {
                            const m = RAW_DATA.models[modelId];
                            if (!m.date) return;
                            const perfs = [], diffs = [], discs = [];
                            activeBenchmarks.forEach(bId => {
                                if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                    perfs.push(RAW_DATA.performances[modelId][bId]);
                                    diffs.push(RAW_DATA.benchmarks[bId].diff);
                                    discs.push(RAW_DATA.benchmarks[bId].disc);
                                }
                            });
                            if (perfs.length >= state.minBenchmarks) {
                                const theta = solveFixed(perfs, diffs, discs);
                                // Store x as numeric timestamp for collision logic
                                const ci = state.showCI ? calculateBootstrapCI(perfs, diffs, discs) : { low: null, high: null };
                                // Store x as numeric timestamp for collision logic
                                rawPoints.push({
                                    id: modelId,
                                    x: new Date(m.date).getTime(),
                                    dateStr: m.date,
                                    y: theta,
                                    ci,
                                    count: perfs.length,
                                    name: m.name
                                });
                            }
                        });
                    }

                    if (state.mode === 'refit') {
                        loader.classList.remove('hidden');
                        status.innerText = "Refitting model...";
                        await new Promise(r => setTimeout(r, 50));
                        try {
                            const refitResult = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                            const refitScores = refitResult.ability || {};
                            const refitDiffs = refitResult.difficulty || {};
                            const refitDiscs = refitResult.discriminability || {};
                            const refitScaling = refitResult.scaling || { a: 0, b: 1 };

                            Object.keys(refitScores).forEach(modelId => {
                                const m = RAW_DATA.models[modelId];
                                if (m && m.date) {
                                    const count = Object.keys(RAW_DATA.performances[modelId] || {}).filter(b => activeBenchmarks.includes(b)).length;
                                    rawPoints.push({
                                        id: modelId,
                                        x: new Date(m.date).getTime(),
                                        dateStr: m.date,
                                        y: refitScores[modelId],
                                        count: count,
                                        name: m.name
                                    });

                                    if (state.showCI) {
                                        // Calc Refit CI
                                        const rPerfs = [], rDiffs = [], rDiscs = [];
                                        activeBenchmarks.forEach(bId => {
                                            if (RAW_DATA.performances[modelId] && RAW_DATA.performances[modelId][bId] !== undefined) {
                                                rPerfs.push(RAW_DATA.performances[modelId][bId]);
                                                const d = refitDiffs[bId];
                                                const a = refitDiscs[bId];
                                                if (d !== undefined && a !== undefined) {
                                                    rDiffs.push(d);
                                                    rDiscs.push(a);
                                                }
                                            }
                                        });
                                        if (rDiffs.length === rPerfs.length) {
                                            rawPoints[rawPoints.length - 1].ci = calculateBootstrapCI(rPerfs, rDiffs, rDiscs, refitScaling);
                                        } else {
                                            rawPoints[rawPoints.length - 1].ci = { low: null, high: null };
                                        }
                                    } else {
                                        rawPoints[rawPoints.length - 1].ci = { low: null, high: null };
                                    }
                                }
                            });
                        } catch (e) { console.error(e); }
                    }

                    if (state.view === 'table') {
                        document.getElementById('chart-wrapper').classList.add('hidden');
                        document.getElementById('table-container').classList.remove('hidden');
                        renderTable(rawPoints, state.mode);
                        status.innerText = `Showing ${rawPoints.length} models in table.`;
                        loader.classList.add('hidden');
                        return;
                    }

                    document.getElementById('table-container').classList.add('hidden');
                    document.getElementById('chart-wrapper').classList.remove('hidden');

                    // Smart Labels
                    let xRange = [0, 1], yRange = [0, 1];
                    if (rawPoints.length > 0) {
                        const xs = rawPoints.map(p => p.x);
                        const ys = rawPoints.map(p => p.y);
                        // Add some padding to date range (approx 1 month in ms)
                        const month = 1000 * 60 * 60 * 24 * 30;
                        xRange = [Math.min(...xs) - month, Math.max(...xs) + month];
                        const yMin = Math.min(...ys), yMax = Math.max(...ys);
                        const yPad = (yMax - yMin || 1) * 0.1;
                        yRange = [yMin - yPad, yMax + yPad];
                        layout.xaxis.range = xRange;
                        layout.yaxis.range = yRange;
                    }

                    const labelPositions = selectNonOverlappingLabels(rawPoints, xRange, yRange, isMobile);

                    //Sort by date for line connection if we wanted lines (here strictly markers)
                    rawPoints.sort((a, b) => a.x - b.x);

                    // Breakpoint Analysis Overlay
                    const bpStatsDiv = document.getElementById('breakpoint-stats');
                    const bpContentDiv = document.getElementById('breakpoint-content');

                    if (state.showBreakpoint && rawPoints.length > 5) {
                        bpStatsDiv.classList.remove('hidden');
                        const titleEl = document.getElementById('stats-title');
                        if (titleEl) titleEl.innerText = "Breakpoint Analysis";
                        status.innerText = "Running statistical analysis...";

                        await new Promise(r => setTimeout(r, 10));

                        // Use Frontier for Analysis
                        const frontierPoints = getFrontier(rawPoints);

                        if (frontierPoints.length < 6) {
                             bpContentDiv.innerText = "Insufficient frontier points for analysis.";
                             status.innerText = "Analysis skipped.";
                             return;
                        }

                        const lin = linearRegression(frontierPoints);
                        const bp = breakpointRegression(frontierPoints);

                        if (lin && bp) {
                            const bicLin = calculateBIC(lin.n, lin.k, lin.rss);
                            const bicBp = calculateBIC(frontierPoints.length, bp.k, bp.rss);

                            let ciText = "";
                            let ci = null;
                            if (bicBp < bicLin + 2) {
                                // Bootstrap using FULL data (rawPoints)
                                ci = bootstrapFrontier(rawPoints, 1000);
                            }

                            if (ci) {
                                const dLow = new Date(ci.low).toISOString().split('T')[0];
                                const dHigh = new Date(ci.high).toISOString().split('T')[0];
                                ciText = `90% CI: ${dLow} to ${dHigh}`;
                            }

                            // Use median split if available
                            const splitX = ci ? ci.median : bp.splitX;
                            const dSplit = new Date(splitX).toISOString().split('T')[0];

                            const diff = bicLin - bicBp;
                            let evidence = "Weak/None";
                            if (diff > 2) evidence = "Positive";
                            if (diff > 6) evidence = "Strong";
                            if (diff > 10) evidence = "Very Strong";

                            // Growth Factors
                            const msPerYear = 1000 * 60 * 60 * 24 * 365.25;
                            // Additive growth: slope (points/ms) * msPerYear = points/year
                            const calcGrowth = (slope) => (slope * msPerYear).toFixed(2) + " ECI points / year";

                            const linearGrowth = calcGrowth(lin.slope);

                            let preGrowth = "-", postGrowth = "-";
                            let constrainedBp = null;

                            // Re-fit constrained with the chosen split point
                            constrainedBp = solveConstrained(frontierPoints, splitX);
                            if (constrainedBp) {
                                preGrowth = calcGrowth(constrainedBp.slope1);
                                postGrowth = calcGrowth(constrainedBp.slope2);
                            }

                            let speedup = null;
                            if (constrainedBp && constrainedBp.slope1 !== 0) {
                                speedup = ((constrainedBp.slope2 - constrainedBp.slope1) / constrainedBp.slope1 * 100);
                            }

                            bpContentDiv.innerHTML = `
                                <div class="flex flex-wrap gap-x-6 gap-y-2 items-center">
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Linear BIC:</span>
                                        <span class="font-mono font-bold">${bicLin.toFixed(1)}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Break BIC:</span>
                                        <span class="font-mono font-bold text-indigo-600">${bicBp.toFixed(1)}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Evidence:</span>
                                        <span class="font-medium">${evidence}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Split:</span>
                                        <span class="font-bold text-gray-900">${dSplit}</span>
                                    </div>
                                </div>
                                <div class="flex flex-wrap gap-x-6 gap-y-2 items-center mt-2 pt-2 border-t border-gray-100">
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500 font-bold">Growth:</span>
                                        <span class="font-mono text-gray-700">${linearGrowth}</span>
                                    </div>
                                    ${constrainedBp ? `
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Pre:</span>
                                        <span class="font-mono text-indigo-600 font-bold">${preGrowth}</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-gray-500">Post:</span>
                                        <span class="font-mono text-pink-600 font-bold">${postGrowth}</span>
                                    </div>
                                    ${speedup !== null ? `
                                    <div class="flex items-center gap-2 bg-green-50 px-2 py-0.5 rounded border border-green-100">
                                        <span class="text-green-700 font-bold">🚀 ${speedup > 0 ? '+' : ''}${speedup.toFixed(0)}% Speedup</span>
                                    </div>
                                    ` : ''}
                                    ` : ''}
                                </div>
                                ${ciText ? `<div class="mt-1 text-gray-400 text-[10px]">${ciText}</div>` : ''}
                            `;

                            // Helper to generate dense points for hover
                            const generateLinePoints = (startT, endT, slope, intercept) => {
                                const pointsX = [];
                                const pointsY = [];
                                const step = 1000 * 60 * 60 * 24 * 15; // 15 days
                                for (let t = startT; t <= endT; t += step) {
                                    pointsX.push(new Date(t).toISOString());
                                    pointsY.push(slope * t + intercept);
                                }
                                // Ensure end point is included
                                if (pointsX[pointsX.length-1] !== new Date(endT).toISOString()) {
                                    pointsX.push(new Date(endT).toISOString());
                                    pointsY.push(slope * endT + intercept);
                                }
                                return { x: pointsX, y: pointsY };
                            };

                            const xMin = xRange[0], xMax = xRange[1];

                            // 1. Linear Fit
                            const linPts = generateLinePoints(xMin, xMax, lin.slope, lin.intercept);
                            plotData.push({
                                x: linPts.x,
                                y: linPts.y,
                                mode: 'lines', type: 'scatter', name: 'Linear Fit',
                                line: { dash: 'dot', color: '#9ca3af', width: 2 },
                                hovertemplate: `<b>Linear Trend</b><br>Growth: ${linearGrowth}<extra></extra>`
                            });

                            // 2. Constrained Breakpoint Fit
                            if (constrainedBp) {
                                const splitX = ci ? ci.median : bp.splitX;

                                const prePts = generateLinePoints(xMin, splitX, constrainedBp.slope1, constrainedBp.intercept1);
                                plotData.push({
                                    x: prePts.x,
                                    y: prePts.y,
                                    mode: 'lines', type: 'scatter', name: 'Pre-Break',
                                    line: { color: '#4f46e5', width: 3 },
                                    hovertemplate: `<b>Pre-Break Trend</b><br>Growth: ${preGrowth}<extra></extra>`
                                });

                                const postPts = generateLinePoints(splitX, xMax, constrainedBp.slope2, constrainedBp.intercept2);
                                plotData.push({
                                    x: postPts.x,
                                    y: postPts.y,
                                    mode: 'lines', type: 'scatter', name: 'Post-Break',
                                    line: { color: '#ec4899', width: 3 },
                                    hovertemplate: `<b>Post-Break Trend</b><br>Growth: ${postGrowth}<extra></extra>`
                                });

                                if (ci) {
                                     layout.shapes = [
                                        {
                                            type: 'rect',
                                            xref: 'x', yref: 'paper',
                                            x0: new Date(ci.low).toISOString(),
                                            x1: new Date(ci.high).toISOString(),
                                            y0: 0, y1: 1,
                                            fillcolor: '#4f46e5',
                                            opacity: 0.1,
                                            line: { width: 0 }
                                        },
                                        {
                                            type: 'line',
                                            xref: 'x', yref: 'paper',
                                            x0: new Date(splitX).toISOString(),
                                            x1: new Date(splitX).toISOString(),
                                            y0: 0, y1: 1,
                                            line: { color: '#4f46e5', width: 1, dash: 'dash' }
                                        }
                                     ];
                                }
                            }
                        } else {
                            bpContentDiv.innerText = "Insufficient data.";
                        }
                        status.innerText = "Analysis complete.";
                    } else {
                        bpStatsDiv.classList.add('hidden');
                    }

                    // Group by Organization
                    const orgGroups = {};
                    rawPoints.forEach(p => {
                        const org = getOrganization(p.name);
                        if (!orgGroups[org]) orgGroups[org] = [];
                        orgGroups[org].push(p);
                    });

                    // Create Traces
                    Object.keys(orgGroups).sort().forEach(org => {
                        const points = orgGroups[org];
                        const x = [], y = [], hovertext = [], displayLabels = [], textPositions = [];

                        points.forEach(p => {
                            x.push(p.dateStr);
                            y.push(p.y);
                            hovertext.push(p.name);
                            const pos = labelPositions.get(p.id);
                            displayLabels.push(pos ? p.name : '');
                            textPositions.push(pos || 'top center');
                        });

                        plotData.push({
                            x, y,
                            hovertext: hovertext,
                            text: displayLabels,
                            mode: 'markers+text',
                            type: 'scatter',
                            name: org,
                            textposition: textPositions,
                            textfont: { size: 10, color: isFixed ? '#4b5563' : '#4b5563', weight: 600 },
                            marker: {
                                color: ORG_COLORS[org] || ORG_COLORS['Other'],
                                size: 10,
                                line: { width: 1.5, color: 'white' },
                                opacity: 0.9
                            },
                            error_y: state.showCI ? {
                                type: 'data',
                                array: points.map(p => (p.ci.high !== null ? p.ci.high - p.y : null)),
                                arrayminus: points.map(p => (p.ci.low !== null ? p.y - p.ci.low : null)),
                                visible: true,
                                color: 'rgba(0,0,0,0.2)',
                                thickness: 1,
                                width: 2
                            } : undefined,
                            hovertemplate: '<b>%{hovertext}</b><br>Date: %{x}<br>ECI: %{y:.2f} %{customdata}<extra></extra>',
                            customdata: points.map(p => p.ci.low ? `[${p.ci.low.toFixed(1)}, ${p.ci.high.toFixed(1)}]` : '')
                        });
                    });

                }

                Plotly.newPlot('chart-container', plotData, layout, { responsive: true, displayModeBar: false });

            } catch (err) {
                console.error("UpdateChart Error:", err);
                status.innerText = "An error occurred while updating the chart.";
            } finally {
                loader.classList.add('hidden');
            }
        }

        async function exportData() {
            const status = document.getElementById('status-text');
            if (status) status.innerText = "Preparing export...";

            try {
                const activeBenchmarks = Array.from(state.selectedBenchmarks);
                const modelIds = Object.keys(RAW_DATA.models);
                const rows = [];

                // Define extraction logic based on mode
                let header = [];
                if (state.mode === 'fixed') header = ['Model', 'Date', 'Fixed_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'refit') header = ['Model', 'Date', 'Refit_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'compare') header = ['Model', 'Date', 'Fixed_ECI', 'Refit_ECI', 'Included_Benchmarks'];
                else if (state.mode === 'rank-compare') header = ['Model', 'Date', 'Fixed_Rank', 'Refit_Rank', 'Included_Benchmarks'];

                rows.push(header);

                // Pre-calc JMLE if needed
                let refitScores = {};
                if (state.mode === 'refit' || state.mode === 'compare' || state.mode === 'rank-compare') {
                    const res = await solveJMLE(state.selectedBenchmarks, state.minBenchmarks);
                    refitScores = res.ability || {};
                }

                modelIds.forEach(id => {
                    const m = RAW_DATA.models[id];
                    let fixedVal = null;
                    let refitVal = null;
                    let employedBenchmarks = [];

                    // Identify utilized benchmarks
                    activeBenchmarks.forEach(bId => {
                        if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                            employedBenchmarks.push(RAW_DATA.benchmarks[bId].name);
                        }
                    });

                    // Calc fixed if needed
                    if (state.mode === 'fixed' || state.mode === 'compare' || state.mode === 'rank-compare') {
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[id][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });

                        if (perfs.length >= state.minBenchmarks) {
                            fixedVal = solveFixed(perfs, diffs, discs);
                        }
                    }

                    if (state.mode === 'refit' || state.mode === 'compare' || state.mode === 'rank-compare') {
                        refitVal = refitScores[id];
                    }

                    const benchString = `"${employedBenchmarks.join('; ')}"`;

                    // Construct Row
                    if (state.mode === 'fixed') {
                        if (fixedVal !== null) rows.push([`"${m.name}"`, m.date, fixedVal.toFixed(2), benchString]);
                    } else if (state.mode === 'refit') {
                        if (refitVal !== undefined) rows.push([`"${m.name}"`, m.date, refitVal.toFixed(2), benchString]);
                    } else if (state.mode === 'compare') {
                        if (fixedVal !== null && refitVal !== undefined) {
                            rows.push([`"${m.name}"`, m.date, fixedVal.toFixed(2), refitVal.toFixed(2), benchString]);
                        }
                    } else if (state.mode === 'rank-compare') {
                        // We need to re-compute ranks globally for export, but this function iterates per model.
                        // Better approach: collect all valid pairs first, sort, rank, then export.
                        // For simplicity in this patch, we skip complex re-ranking inside the export loop
                        // or assume the user just wants the filtered data.
                        // Actually, without sorting the whole set, we can't export ranks easily here efficiently without refactoring.
                        // Let's just export the scores for now or do a quick re-calculation.
                        // Since exportData is async, we can do it properly.
                    }
                });

                if (state.mode === 'rank-compare') {
                    // Post-process for Rank Compare Export
                    // Gather all valid models
                    const validModels = [];
                     modelIds.forEach(id => {
                        const m = RAW_DATA.models[id];
                        let f = null;
                        // ... (re-calc fixed) - wait, this is inefficient to duplicate code.
                        // Given the architecture, let's just piggyback on what we have.
                        // Let's restart the loop properly for Rank Compare.
                     });

                     // Actually, let's just simplify and export the table data if possible?
                     // But table data is not stored in state.

                     // Re-implement simplified rank logic for export
                     const data = [];
                     modelIds.forEach(id => {
                        // ... calc fixedVal and refitVal ...
                        const perfs = [], diffs = [], discs = [];
                        activeBenchmarks.forEach(bId => {
                            if (RAW_DATA.performances[id] && RAW_DATA.performances[id][bId] !== undefined) {
                                perfs.push(RAW_DATA.performances[id][bId]);
                                diffs.push(RAW_DATA.benchmarks[bId].diff);
                                discs.push(RAW_DATA.benchmarks[bId].disc);
                            }
                        });
                        let f = null;
                        if (perfs.length >= state.minBenchmarks) f = solveFixed(perfs, diffs, discs);
                        let r = refitScores[id];

                        if (f !== null && r !== undefined) {
                            data.push({ id, name: RAW_DATA.models[id].name, date: RAW_DATA.models[id].date, f, r,
                                benches: activeBenchmarks.filter(b => RAW_DATA.performances[id][b] !== undefined).map(b => RAW_DATA.benchmarks[b].name).join('; ')
                            });
                        }
                     });

                     data.sort((a,b) => b.f - a.f).forEach((d,i) => d.fRank = i+1);
                     data.sort((a,b) => b.r - a.r).forEach((d,i) => d.rRank = i+1);

                     data.forEach(d => {
                         rows.push([`"${d.name}"`, d.date, d.fRank, d.rRank, `"${d.benches}"`]);
                     });
                }

                // Generate CSV
                const csvContent = rows.map(r => r.join(",")).join("\n");

                // Standard Download Method (Hidden Anchor)
                // We use a Data URI here because Blob URLs on file:// protocol often ignore the 'download' attribute (filename).
                // Browsers may still override the filename on local files depending on security settings, but this is the best standard approach.
                const BOM = "\uFEFF";
                const uri = 'data:text/csv;charset=utf-8,' + encodeURIComponent(BOM + csvContent);

                const link = document.createElement("a");
                link.setAttribute("href", uri);
                link.setAttribute("download", `eci_export_${state.mode}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                if (status) status.innerText = "Export complete.";

            } catch (e) {
                console.error("Export Error:", e);
                alert("Failed to export data: " + e.message);
            }
        }

        // --- UI Setup ---
        async function init() {
            try {
                const status = document.getElementById('status-text');
                if (status) status.innerText = "Initializing...";

                if (typeof RAW_DATA === 'undefined' || !RAW_DATA.benchmarks) {
                    throw new Error("Data not loaded correctly");
                }

                // Default selection
                // Default selection (Math)
                Object.keys(RAW_DATA.benchmarks).forEach(id => {
                    if (RAW_DATA.benchmarks[id].domain === 'Math') {
                        state.selectedBenchmarks.add(id);
                    }
                });

                // Category filter
                const domainSelector = document.getElementById('domain-selector');
                if (domainSelector) {
                    domainSelector.addEventListener('change', (e) => {
                        state.viewedDomain = e.target.value;
                        renderBenchmarkList();
                    });
                }

                // Search filter
                const searchInput = document.getElementById('search-benchmarks');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        state.searchTerm = e.target.value;
                        renderBenchmarkList();
                    });
                }

                const clearBtn = document.getElementById('clear-domains');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        state.selectedBenchmarks.clear();
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                // Export functionality
                const handleExport = () => exportData();
                ['download-btn', 'mobile-download-btn'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('click', handleExport);
                });

                // Mode switching
                const modes = ['fixed', 'refit', 'compare', 'rank-compare'];

                function updateModeUI(selectedMode) {
                    modes.forEach(m => {
                        // Desktop
                        const dBtn = document.getElementById(`mode-${m}`);
                        if (dBtn) {
                             if (m === selectedMode) {
                                dBtn.className = "px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200";
                             } else {
                                dBtn.className = "px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all";
                             }
                        }
                        // Mobile
                        const mBtn = document.getElementById(`mobile-mode-${m}`);
                        if (mBtn) {
                            if (m === selectedMode) {
                                mBtn.className = "px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-indigo-50 text-indigo-700 border border-indigo-200";
                            } else {
                                mBtn.className = "px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50";
                            }
                        }
                    });

                    // Hide Breakpoint Toggle in Rank Compare mode
                    const bpToggle = document.getElementById('show-breakpoint-toggle');
                    const mobBpToggle = document.getElementById('mobile-show-breakpoint-toggle');
                    const bpContainer = bpToggle ? bpToggle.parentElement : null;
                    const mobBpContainer = mobBpToggle ? mobBpToggle.parentElement : null;

                    if (selectedMode === 'rank-compare') {
                        if (bpContainer) bpContainer.classList.add('hidden');
                        if (mobBpContainer) mobBpContainer.classList.add('hidden');
                    } else {
                        if (bpContainer) bpContainer.classList.remove('hidden');
                        if (mobBpContainer) mobBpContainer.classList.remove('hidden');
                    }
                }

                modes.forEach(m => {
                    ['mode-', 'mobile-mode-'].forEach(prefix => {
                        const el = document.getElementById(prefix + m);
                        if (el) {
                            el.addEventListener('click', () => {
                                state.mode = m;
                                updateModeUI(m);
                                updateChart();
                                if (window.innerWidth < 1024) toggleSidebar(false); // Close sidebar on mobile selection
                            });
                        }
                    });
                });

                // View Switching
                function updateViewUI(selectedView) {
                    // Desktop
                    ['view-chart', 'view-table'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            if (id === `view-${selectedView}`) {
                                el.className = "px-3 py-1.5 rounded-md text-sm font-medium transition-all shadow-sm bg-white text-gray-900 border border-gray-200";
                            } else {
                                el.className = "px-3 py-1.5 rounded-md text-sm font-medium text-gray-500 hover:text-gray-900 transition-all";
                            }
                        }
                    });

                    // Mobile
                    ['mobile-view-chart', 'mobile-view-table'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            if (id === `mobile-view-${selectedView}`) {
                                el.className = "px-3 py-2 rounded-md text-sm font-medium transition-all shadow-sm bg-gray-100 text-gray-900";
                            } else {
                                el.className = "px-3 py-2 rounded-md text-sm font-medium text-gray-500 hover:bg-gray-50";
                            }
                        }
                    });
                }

                ['view-chart', 'view-table', 'mobile-view-chart', 'mobile-view-table'].forEach(bid => {
                    const el = document.getElementById(bid);
                    if (el) {
                        el.addEventListener('click', () => {
                            const view = bid.includes('mobile-') ? bid.replace('mobile-view-', '') : bid.replace('view-', '');
                            state.view = view;
                            updateViewUI(view);
                            updateChart();
                            if (window.innerWidth < 1024 && bid.includes('mobile-')) toggleSidebar(false);
                        });
                    }
                });

                // Initialize UI state
                updateModeUI(state.mode);
                updateViewUI(state.view);

                // Bulk actions
                const selectAll = document.getElementById('select-all');
                if (selectAll) {
                    selectAll.addEventListener('click', () => {
                        const term = state.searchTerm.toLowerCase();
                        const viewed = state.viewedDomain;
                        Object.entries(RAW_DATA.benchmarks).forEach(([id, b]) => {
                            const matchesSearch = b.name.toLowerCase().includes(term);
                            const matchesDomain = (viewed === 'All' || b.domain === viewed);
                            if (matchesSearch && matchesDomain) state.selectedBenchmarks.add(id);
                        });
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                const deselectAll = document.getElementById('deselect-all');
                if (deselectAll) {
                    deselectAll.addEventListener('click', () => {
                        state.selectedBenchmarks.clear();
                        renderSelectedBenchmarkTags();
                        renderBenchmarkList();
                        updateChart();
                    });
                }

                // Min Benchmarks selector
                const slider = document.getElementById('min-benchmarks');
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        const val = parseInt(e.target.value);
                        const display = document.getElementById('min-benchmarks-val');
                        if (display) display.innerText = val;
                        state.minBenchmarks = val;
                        updateChart();
                    });
                }

                // Show Breakpoint toggle
                function toggleBreakpoint(checked) {
                    state.showBreakpoint = checked;
                    const dToggle = document.getElementById('show-breakpoint-toggle');
                    if (dToggle) dToggle.checked = checked;
                    const mToggle = document.getElementById('mobile-show-breakpoint-toggle');
                    if (mToggle) mToggle.checked = checked;
                    updateChart();
                }

                const bpToggle = document.getElementById('show-breakpoint-toggle');
                if (bpToggle) bpToggle.addEventListener('change', (e) => toggleBreakpoint(e.target.checked));

                const mobBpToggle = document.getElementById('mobile-show-breakpoint-toggle');
                if (mobBpToggle) mobBpToggle.addEventListener('change', (e) => toggleBreakpoint(e.target.checked));

                // Show CI toggle
                function toggleCI(checked) {
                    state.showCI = checked;
                    const dToggle = document.getElementById('show-ci-toggle');
                    if (dToggle) dToggle.checked = checked;
                    const mToggle = document.getElementById('mobile-show-ci-toggle');
                    if (mToggle) mToggle.checked = checked;
                    updateChart();
                }

                const ciToggle = document.getElementById('show-ci-toggle');
                if (ciToggle) ciToggle.addEventListener('change', (e) => toggleCI(e.target.checked));

                const mobCiToggle = document.getElementById('mobile-show-ci-toggle');
                if (mobCiToggle) mobCiToggle.addEventListener('change', (e) => toggleCI(e.target.checked));

                // Mobile Sidebar Logic
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const menuBtn = document.getElementById('mobile-menu-btn');
                const closeBtn = document.getElementById('sidebar-close-btn');

                function toggleSidebar(show) {
                    if (show) {
                        sidebar.classList.remove('-translate-x-full');
                        overlay.classList.remove('hidden');
                        // Small delay for opacity transition
                        setTimeout(() => overlay.classList.remove('opacity-0'), 10);
                    } else {
                        sidebar.classList.add('-translate-x-full');
                        overlay.classList.add('opacity-0');
                        setTimeout(() => overlay.classList.add('hidden'), 300);
                    }
                }

                if (menuBtn) menuBtn.addEventListener('click', () => toggleSidebar(true));
                if (closeBtn) closeBtn.addEventListener('click', () => toggleSidebar(false));
                if (overlay) overlay.addEventListener('click', () => toggleSidebar(false));

                // Resize listener
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => updateChart(), 200);
                });

                // Initial Render
                if (status) status.innerText = "Rendering filters...";
                renderDomainFilters();
                renderSelectedBenchmarkTags();
                renderBenchmarkList();

                if (status) status.innerText = "Updating chart...";
                await updateChart();

            } catch (err) {
                console.error("Init Error:", err);
                const status = document.getElementById('status-text');
                if (status) {
                    status.innerText = "Initialization Failed: " + err.message;
                    status.classList.add('text-red-600', 'font-bold');
                }
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>

</html>