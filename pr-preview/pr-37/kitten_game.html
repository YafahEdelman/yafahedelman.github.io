<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Kitten - AI Designed Tiny Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f9ff; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1 class="text-3xl font-bold text-gray-800 drop-shadow-md">Tiny 3D Kitten</h1>
        <p class="text-gray-600 font-medium bg-white/80 px-4 py-2 rounded-full mt-2 inline-block shadow-sm">
            Click or tap the kitten to pet it!
        </p>
        <div class="mt-4">
            <a href="games.html" class="pointer-events-auto text-indigo-600 hover:text-indigo-800 font-bold bg-white/90 px-4 py-2 rounded-lg shadow-sm border border-indigo-100 transition-colors">
                &larr; Back to Games
            </a>
        </div>
    </div>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f9ff);
        scene.fog = new THREE.Fog(0xf0f9ff, 10, 50);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // --- ENVIRONMENT ---
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x90e0ef });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- KITTEN MODEL ---
        const kittenGroup = new THREE.Group();
        scene.add(kittenGroup);

        const materialFur = new THREE.MeshStandardMaterial({ color: 0xffaa55, roughness: 0.8 }); // Orange tabby
        const materialWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
        const materialEyes = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 });
        const materialNose = new THREE.MeshStandardMaterial({ color: 0xff99aa, roughness: 0.5 });

        // Helper to create a capsule-like shape (Cylinder + 2 Spheres)
        function createCapsule(radius, length, material) {
            const group = new THREE.Group();

            const cylinderGeo = new THREE.CylinderGeometry(radius, radius, length, 16);
            const cylinder = new THREE.Mesh(cylinderGeo, material);
            cylinder.castShadow = true;
            group.add(cylinder);

            const sphereGeo = new THREE.SphereGeometry(radius, 16, 16);

            const topSphere = new THREE.Mesh(sphereGeo, material);
            topSphere.position.y = length / 2;
            topSphere.castShadow = true;
            group.add(topSphere);

            const bottomSphere = new THREE.Mesh(sphereGeo, material);
            bottomSphere.position.y = -length / 2;
            bottomSphere.castShadow = true;
            group.add(bottomSphere);

            return group;
        }

        // Body
        // Capsule length 1.2, radius 0.7.
        // Note: createCapsule aligns along Y. We need to rotate it to align along Z.
        const body = createCapsule(0.7, 1.2, materialFur);
        body.rotation.x = Math.PI / 2;
        body.position.y = 1.2;
        kittenGroup.add(body);

        // Head
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 1.8, 1); // Moved forward (Z+) instead of X+
        kittenGroup.add(headGroup);

        const headGeo = new THREE.SphereGeometry(0.65, 16, 16);
        const head = new THREE.Mesh(headGeo, materialFur);
        head.castShadow = true;
        headGroup.add(head);

        // Ears
        const earGeo = new THREE.ConeGeometry(0.2, 0.4, 16);
        const leftEar = new THREE.Mesh(earGeo, materialFur);
        leftEar.position.set(0.3, 0.6, 0.2);
        leftEar.rotation.x = -0.2;
        leftEar.rotation.z = -0.2;
        headGroup.add(leftEar);

        const rightEar = new THREE.Mesh(earGeo, materialFur);
        rightEar.position.set(-0.3, 0.6, 0.2);
        rightEar.rotation.x = -0.2;
        rightEar.rotation.z = 0.2;
        headGroup.add(rightEar);

        // Face
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const leftEye = new THREE.Mesh(eyeGeo, materialEyes);
        leftEye.position.set(0.25, 0.1, 0.55);
        headGroup.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeo, materialEyes);
        rightEye.position.set(-0.25, 0.1, 0.55);
        headGroup.add(rightEye);

        const noseGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const nose = new THREE.Mesh(noseGeo, materialNose);
        nose.position.set(0, 0.0, 0.62);
        headGroup.add(nose);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.15, 0.12, 1.0, 8);
        const legs = [];

        function createLeg(x, z, name) {
            const legGroup = new THREE.Group();
            legGroup.position.set(x, 1.0, z);

            const legMesh = new THREE.Mesh(legGeo, materialFur);
            legMesh.position.y = -0.5; // pivot at top
            legMesh.castShadow = true;

            legGroup.add(legMesh);
            kittenGroup.add(legGroup);
            legs.push({ mesh: legGroup, name: name, initialRot: 0 });
            return legGroup;
        }

        // Adjusted leg positions for Z-forward orientation
        const legFL = createLeg(0.4, 0.6, 'FL');
        const legFR = createLeg(-0.4, 0.6, 'FR');
        const legBL = createLeg(0.4, -0.6, 'BL');
        const legBR = createLeg(-0.4, -0.6, 'BR');

        // Tail
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1.4, -0.8);
        kittenGroup.add(tailGroup);

        const tailGeo = new THREE.CylinderGeometry(0.1, 0.05, 1.2, 8);
        const tail = new THREE.Mesh(tailGeo, materialFur);
        tail.rotation.x = -Math.PI / 4; // Angle up and back
        tail.position.set(0, 0.4, -0.4);
        tail.castShadow = true;
        tailGroup.add(tail);


        // --- PARTICLES (HEARTS) ---
        const hearts = [];
        const heartGeo = new THREE.ShapeGeometry(
            new THREE.Shape()
                .moveTo(0.25, 0.25)
                .bezierCurveTo(0.25, 0.25, 0.20, 0, 0, 0)
                .bezierCurveTo(-0.30, 0, -0.30, 0.35, -0.30, 0.35)
                .bezierCurveTo(-0.30, 0.55, -0.10, 0.77, 0.25, 0.95)
                .bezierCurveTo(0.60, 0.77, 0.80, 0.55, 0.80, 0.35)
                .bezierCurveTo(0.80, 0.35, 0.80, 0, 0.50, 0)
                .bezierCurveTo(0.35, 0, 0.25, 0.25, 0.25, 0.25)
        );
        const heartMat = new THREE.MeshBasicMaterial({ color: 0xff69b4, side: THREE.DoubleSide });

        function spawnHeart() {
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.scale.set(0.2, 0.2, 0.2);
            // Position above head
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            heart.position.copy(worldPos);
            heart.position.y += 1.0 + Math.random() * 0.5;
            heart.position.x += (Math.random() - 0.5) * 0.5;
            heart.rotation.z = Math.PI; // Correct orientation from shape

            scene.add(heart);
            hearts.push({ mesh: heart, life: 1.0, speedY: 1.5 + Math.random() });
        }

        // --- AI & LOGIC ---
        let state = 'IDLE'; // IDLE, WALK, PET
        let stateTimer = 0;
        let targetPos = new THREE.Vector3();
        let walkSpeed = 2.5;
        let turnSpeed = 3.0;
        let petTimer = 0;

        function pickRandomPoint() {
            const r = 8 * Math.sqrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            return new THREE.Vector3(r * Math.cos(theta), 0, r * Math.sin(theta));
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onPointerDown(event) {
            // Normalize mouse coords
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersection with kitten parts
            const intersects = raycaster.intersectObjects(kittenGroup.children, true);

            if (intersects.length > 0) {
                // Pet the kitten!
                state = 'PET';
                petTimer = 1.5; // Pet for 1.5 seconds
                spawnHeart();
                spawnHeart();
                spawnHeart();
            }
        }
        window.addEventListener('pointerdown', onPointerDown);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Behavior State Machine
            if (state === 'IDLE') {
                stateTimer -= dt;

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 3) * 0.02, 1);

                // Tail wag
                tailGroup.rotation.y = Math.sin(time * 2) * 0.2;

                if (stateTimer <= 0) {
                    state = 'WALK';
                    targetPos = pickRandomPoint();
                    stateTimer = 5.0; // Max walk time before rethinking
                }
            }
            else if (state === 'WALK') {
                // Determine direction
                const currentPos = kittenGroup.position.clone();
                const direction = targetPos.clone().sub(currentPos);
                const dist = direction.length();

                if (dist < 0.2) {
                    state = 'IDLE';
                    stateTimer = 1.0 + Math.random() * 2.0;
                } else {
                    direction.normalize();

                    // Rotate towards target
                    const targetRotation = Math.atan2(direction.x, direction.z); // Facing Z direction
                    let rotDiff = targetRotation - kittenGroup.rotation.y;

                    // Normalize angle to -PI to PI
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;

                    kittenGroup.rotation.y += rotDiff * turnSpeed * dt;

                    // Move forward
                    kittenGroup.position.add(direction.multiplyScalar(walkSpeed * dt));

                    // Walk Animation
                    const legAmp = 0.4;
                    const legFreq = 10;
                    legs[0].mesh.rotation.x = Math.sin(time * legFreq) * legAmp; // FL
                    legs[1].mesh.rotation.x = Math.cos(time * legFreq) * legAmp; // FR
                    legs[2].mesh.rotation.x = Math.cos(time * legFreq) * legAmp; // BL
                    legs[3].mesh.rotation.x = Math.sin(time * legFreq) * legAmp; // BR

                    // Bob head
                    headGroup.position.y = 1.8 + Math.sin(time * legFreq * 2) * 0.05;

                    stateTimer -= dt;
                    if (stateTimer <= 0) {
                        state = 'IDLE';
                        stateTimer = 1.0;
                    }
                }
            }
            else if (state === 'PET') {
                petTimer -= dt;

                // Happy purr vibration
                kittenGroup.position.y = Math.sin(time * 50) * 0.02;

                // Close eyes (scale y)
                leftEye.scale.y = 0.1;
                rightEye.scale.y = 0.1;

                // Tail happy
                tailGroup.rotation.z = Math.sin(time * 15) * 0.5;

                // Spawn occasional hearts
                if (Math.random() < 0.05) spawnHeart();

                if (petTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                    kittenGroup.position.y = 0; // Reset height
                    leftEye.scale.y = 1;
                    rightEye.scale.y = 1;
                }
            }

            // Update Hearts
            for (let i = hearts.length - 1; i >= 0; i--) {
                const h = hearts[i];
                h.life -= dt;
                h.mesh.position.y += h.speedY * dt;
                h.mesh.material.opacity = h.life;
                h.mesh.material.transparent = true;

                if (h.life <= 0) {
                    scene.remove(h.mesh);
                    hearts.splice(i, 1);
                }
            }

            // Constrain to floor
            if(kittenGroup.position.y < 0) kittenGroup.position.y = 0;

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
