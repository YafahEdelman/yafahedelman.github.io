<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Kitten - AI Designed Tiny Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f9ff; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1 class="text-3xl font-bold text-gray-800 drop-shadow-md">Tiny 3D Kitten</h1>
        <p class="text-gray-600 font-medium bg-white/80 px-4 py-2 rounded-full mt-2 inline-block shadow-sm">
            Click or tap the kitten to pet it!
        </p>
        <div class="mt-4">
            <a href="games.html" class="pointer-events-auto text-indigo-600 hover:text-indigo-800 font-bold bg-white/90 px-4 py-2 rounded-lg shadow-sm border border-indigo-100 transition-colors">
                &larr; Back to Games
            </a>
        </div>
    </div>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f9ff);
        scene.fog = new THREE.Fog(0xf0f9ff, 10, 50);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // --- ENVIRONMENT ---
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x90e0ef });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- KITTEN MODEL ---
        const kittenGroup = new THREE.Group();
        scene.add(kittenGroup);

        const materialFur = new THREE.MeshStandardMaterial({ color: 0xffaa55, roughness: 0.8 }); // Orange tabby
        const materialWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
        const materialEyes = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 });
        const materialNose = new THREE.MeshStandardMaterial({ color: 0xff99aa, roughness: 0.5 });

        // Helper to create a capsule-like shape (Cylinder + 2 Spheres)
        function createCapsule(radius, length, material) {
            const group = new THREE.Group();

            const cylinderGeo = new THREE.CylinderGeometry(radius, radius, length, 16);
            const cylinder = new THREE.Mesh(cylinderGeo, material);
            cylinder.castShadow = true;
            group.add(cylinder);

            const sphereGeo = new THREE.SphereGeometry(radius, 16, 16);

            const topSphere = new THREE.Mesh(sphereGeo, material);
            topSphere.position.y = length / 2;
            topSphere.castShadow = true;
            group.add(topSphere);

            const bottomSphere = new THREE.Mesh(sphereGeo, material);
            bottomSphere.position.y = -length / 2;
            bottomSphere.castShadow = true;
            group.add(bottomSphere);

            return group;
        }

        // Body
        // Capsule length 1.2, radius 0.7.
        // Note: createCapsule aligns along Y. We need to rotate it to align along Z.
        const body = createCapsule(0.7, 1.2, materialFur);
        body.rotation.x = Math.PI / 2;
        body.position.y = 1.2;
        kittenGroup.add(body);

        // Head
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 1.8, 1); // Moved forward (Z+) instead of X+
        kittenGroup.add(headGroup);

        const headGeo = new THREE.SphereGeometry(0.65, 16, 16);
        const head = new THREE.Mesh(headGeo, materialFur);
        head.castShadow = true;
        headGroup.add(head);

        // Ears
        const earGeo = new THREE.ConeGeometry(0.2, 0.4, 16);
        const leftEar = new THREE.Mesh(earGeo, materialFur);
        leftEar.position.set(0.3, 0.6, 0.2);
        leftEar.rotation.x = -0.2;
        leftEar.rotation.z = -0.2;
        headGroup.add(leftEar);

        const rightEar = new THREE.Mesh(earGeo, materialFur);
        rightEar.position.set(-0.3, 0.6, 0.2);
        rightEar.rotation.x = -0.2;
        rightEar.rotation.z = 0.2;
        headGroup.add(rightEar);

        // Face
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const leftEye = new THREE.Mesh(eyeGeo, materialEyes);
        leftEye.position.set(0.25, 0.1, 0.55);
        headGroup.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeo, materialEyes);
        rightEye.position.set(-0.25, 0.1, 0.55);
        headGroup.add(rightEye);

        const noseGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const nose = new THREE.Mesh(noseGeo, materialNose);
        nose.position.set(0, 0.0, 0.62);
        headGroup.add(nose);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.15, 0.12, 1.0, 8);
        const legs = [];

        function createLeg(x, z, name) {
            const legGroup = new THREE.Group();
            legGroup.position.set(x, 1.0, z);

            const legMesh = new THREE.Mesh(legGeo, materialFur);
            legMesh.position.y = -0.5; // pivot at top
            legMesh.castShadow = true;

            legGroup.add(legMesh);
            kittenGroup.add(legGroup);
            legs.push({ mesh: legGroup, name: name, initialRot: 0 });
            return legGroup;
        }

        // Adjusted leg positions for Z-forward orientation
        const legFL = createLeg(0.4, 0.6, 'FL');
        const legFR = createLeg(-0.4, 0.6, 'FR');
        const legBL = createLeg(0.4, -0.6, 'BL');
        const legBR = createLeg(-0.4, -0.6, 'BR');

        // Tail
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1.4, -0.8);
        kittenGroup.add(tailGroup);

        const tailGeo = new THREE.CylinderGeometry(0.1, 0.05, 1.2, 8);
        const tail = new THREE.Mesh(tailGeo, materialFur);
        tail.rotation.x = -Math.PI / 4; // Angle up and back
        tail.position.set(0, 0.4, -0.4);
        tail.castShadow = true;
        tailGroup.add(tail);


        // --- PARTICLES (HEARTS) ---
        const hearts = [];
        const heartGeo = new THREE.ShapeGeometry(
            new THREE.Shape()
                .moveTo(0.25, 0.25)
                .bezierCurveTo(0.25, 0.25, 0.20, 0, 0, 0)
                .bezierCurveTo(-0.30, 0, -0.30, 0.35, -0.30, 0.35)
                .bezierCurveTo(-0.30, 0.55, -0.10, 0.77, 0.25, 0.95)
                .bezierCurveTo(0.60, 0.77, 0.80, 0.55, 0.80, 0.35)
                .bezierCurveTo(0.80, 0.35, 0.80, 0, 0.50, 0)
                .bezierCurveTo(0.35, 0, 0.25, 0.25, 0.25, 0.25)
        );
        const heartMat = new THREE.MeshBasicMaterial({ color: 0xff69b4, side: THREE.DoubleSide });

        function spawnHeart() {
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.scale.set(0.2, 0.2, 0.2);
            // Position above head
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            heart.position.copy(worldPos);
            heart.position.y += 1.0 + Math.random() * 0.5;
            heart.position.x += (Math.random() - 0.5) * 0.5;
            heart.rotation.z = Math.PI; // Correct orientation from shape

            scene.add(heart);
            hearts.push({ mesh: heart, life: 1.0, speedY: 1.5 + Math.random() });
        }

        // --- Zzz PARTICLES ---
        function createZzzTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Z', 32, 32);
            // Add slight outline
            ctx.strokeStyle = '#88ccff';
            ctx.lineWidth = 2;
            ctx.strokeText('Z', 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const zzzTexture = createZzzTexture();
        const zzzMaterial = new THREE.SpriteMaterial({ map: zzzTexture, transparent: true, opacity: 0.8 });
        const zzzs = [];

        function spawnZzz() {
            const zzz = new THREE.Sprite(zzzMaterial);
            zzz.scale.set(0.5, 0.5, 0.5);

            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            zzz.position.copy(worldPos);
            zzz.position.y += 0.8;
            zzz.position.x += (Math.random() - 0.5) * 0.2;

            scene.add(zzz);
            zzzs.push({ mesh: zzz, life: 2.0, speedY: 0.8, swayOffset: Math.random() * 10 });
        }

        // --- TOYS ---
        const toys = [];
        const toyMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.4 }),
        ];

        function createToys() {
            // Ball
            const ballGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const ball = new THREE.Mesh(ballGeo, toyMaterials[0]);
            ball.castShadow = true;
            ball.position.set(3, 0.4, 3);
            scene.add(ball);
            toys.push({ mesh: ball, type: 'ball', radius: 0.4, velocity: new THREE.Vector3() });

            // Box
            const boxGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
            const box = new THREE.Mesh(boxGeo, toyMaterials[2]);
            box.castShadow = true;
            box.position.set(-3, 0.35, -2);
            scene.add(box);
            toys.push({ mesh: box, type: 'box', radius: 0.5, velocity: new THREE.Vector3() });

            // Another Ball
            const ball2 = new THREE.Mesh(ballGeo, toyMaterials[3]);
            ball2.castShadow = true;
            ball2.position.set(2, 0.4, -4);
            scene.add(ball2);
            toys.push({ mesh: ball2, type: 'ball', radius: 0.4, velocity: new THREE.Vector3() });
        }
        createToys();

        // --- AI & LOGIC ---
        let state = 'IDLE'; // IDLE, WALK, PET, SLEEP
        let stateTimer = 0;
        let targetPos = new THREE.Vector3();
        let walkSpeed = 2.5;
        let turnSpeed = 3.0;
        let petTimer = 0;
        let sleepTimer = 0;

        function pickRandomPoint() {
            const r = 8 * Math.sqrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            return new THREE.Vector3(r * Math.cos(theta), 0, r * Math.sin(theta));
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onPointerDown(event) {
            // Normalize mouse coords
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersection with kitten parts
            const intersects = raycaster.intersectObjects(kittenGroup.children, true);

            if (intersects.length > 0) {
                // Pet/Wake the kitten!
                state = 'PET';
                petTimer = 1.5; // Pet for 1.5 seconds
                spawnHeart();
                spawnHeart();
                spawnHeart();
            }
        }
        window.addEventListener('pointerdown', onPointerDown);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Behavior State Machine
            if (state === 'IDLE') {
                stateTimer -= dt;

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 3) * 0.02, 1);

                // Tail wag
                tailGroup.rotation.y = Math.sin(time * 2) * 0.2;

                // Lerp back to standing pose
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 5 * dt);
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 5 * dt);
                leftEye.scale.y = THREE.MathUtils.lerp(leftEye.scale.y, 1, 10 * dt);
                rightEye.scale.y = THREE.MathUtils.lerp(rightEye.scale.y, 1, 10 * dt);
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.8, 5 * dt);

                if (stateTimer <= 0) {
                    // 30% chance to sleep, 70% chance to walk
                    if (Math.random() < 0.3) {
                        state = 'SLEEP';
                        stateTimer = 5.0 + Math.random() * 5.0; // Sleep 5-10s
                    } else {
                        state = 'WALK';
                        targetPos = pickRandomPoint();
                        stateTimer = 5.0; // Max walk time
                    }
                }
            }
            else if (state === 'SLEEP') {
                stateTimer -= dt;

                // Curl/Lower animation
                // Lower body to floor
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.6, 2 * dt);
                // Roll slightly
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0.2, 2 * dt);
                // Lower head
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.4, 2 * dt);

                // Close eyes
                leftEye.scale.y = THREE.MathUtils.lerp(leftEye.scale.y, 0.1, 10 * dt);
                rightEye.scale.y = THREE.MathUtils.lerp(rightEye.scale.y, 0.1, 10 * dt);

                // Slow breathing
                body.scale.set(1, 1 + Math.sin(time * 1.5) * 0.03, 1);

                // Stop tail wag
                tailGroup.rotation.y = THREE.MathUtils.lerp(tailGroup.rotation.y, 0, 2 * dt);

                // Spawn Zzz
                if (Math.random() < 0.02) spawnZzz();

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                }
            }
            else if (state === 'WALK') {
                // Determine direction
                const currentPos = kittenGroup.position.clone();
                const direction = targetPos.clone().sub(currentPos);
                const dist = direction.length();

                if (dist < 0.2) {
                    state = 'IDLE';
                    stateTimer = 1.0 + Math.random() * 2.0;
                } else {
                    direction.normalize();

                    // Rotate towards target
                    const targetRotation = Math.atan2(direction.x, direction.z); // Facing Z direction
                    let rotDiff = targetRotation - kittenGroup.rotation.y;

                    // Normalize angle to -PI to PI
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;

                    kittenGroup.rotation.y += rotDiff * turnSpeed * dt;

                    // Move forward
                    kittenGroup.position.add(direction.multiplyScalar(walkSpeed * dt));

                    // Walk Animation
                    const legAmp = 0.4;
                    const legFreq = 10;
                    legs[0].mesh.rotation.x = Math.sin(time * legFreq) * legAmp; // FL
                    legs[1].mesh.rotation.x = Math.cos(time * legFreq) * legAmp; // FR
                    legs[2].mesh.rotation.x = Math.cos(time * legFreq) * legAmp; // BL
                    legs[3].mesh.rotation.x = Math.sin(time * legFreq) * legAmp; // BR

                    // Bob head
                    headGroup.position.y = 1.8 + Math.sin(time * legFreq * 2) * 0.05;

                    stateTimer -= dt;
                    if (stateTimer <= 0) {
                        state = 'IDLE';
                        stateTimer = 1.0;
                    }
                }
            }
            else if (state === 'PET') {
                petTimer -= dt;

                // Wake up pose quickly
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 5 * dt);

                // Happy purr vibration
                kittenGroup.position.y = Math.sin(time * 50) * 0.02; // relative to 0 ideally
                if(kittenGroup.position.y < 0 && state !== 'SLEEP') kittenGroup.position.y = Math.max(0, kittenGroup.position.y);

                // Close eyes (scale y)
                leftEye.scale.y = 0.1;
                rightEye.scale.y = 0.1;

                // Tail happy
                tailGroup.rotation.z = Math.sin(time * 15) * 0.5;

                // Spawn occasional hearts
                if (Math.random() < 0.05) spawnHeart();

                if (petTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                    kittenGroup.position.y = 0; // Reset height
                    leftEye.scale.y = 1;
                    rightEye.scale.y = 1;
                }
            }

            // Update Hearts
            for (let i = hearts.length - 1; i >= 0; i--) {
                const h = hearts[i];
                h.life -= dt;
                h.mesh.position.y += h.speedY * dt;
                h.mesh.material.opacity = h.life;
                h.mesh.material.transparent = true;

                if (h.life <= 0) {
                    scene.remove(h.mesh);
                    hearts.splice(i, 1);
                }
            }

            // Update Zzzs
            for (let i = zzzs.length - 1; i >= 0; i--) {
                const z = zzzs[i];
                z.life -= dt;
                z.mesh.position.y += z.speedY * dt;
                z.mesh.position.x += Math.sin(time * 2 + z.swayOffset) * 0.01;
                z.mesh.material.opacity = Math.min(z.life, 0.8);

                if (z.life <= 0) {
                    scene.remove(z.mesh);
                    zzzs.splice(i, 1);
                }
            }

            // Constrain to floor
            if(kittenGroup.position.y < 0) kittenGroup.position.y = 0;

            // Toy Physics & Interaction
            const kittenPos = kittenGroup.position.clone();
            toys.forEach(toy => {
                // Simple friction
                toy.velocity.multiplyScalar(0.92);
                toy.mesh.position.add(toy.velocity.clone().multiplyScalar(dt));

                // Rotation for balls
                if (toy.type === 'ball') {
                    toy.mesh.rotation.x += toy.velocity.z * dt * 2;
                    toy.mesh.rotation.z -= toy.velocity.x * dt * 2;
                }

                // Collision with kitten
                const dist = kittenPos.distanceTo(toy.mesh.position);
                if (dist < 1.0) { // Kitten radius approx 0.7 + toy radius
                    const pushDir = toy.mesh.position.clone().sub(kittenPos).normalize();
                    toy.velocity.add(pushDir.multiplyScalar(5.0 * dt)); // Push toy

                    // If kitten is walking, maybe it pushes harder?
                    if (state === 'WALK') {
                         toy.velocity.add(pushDir.multiplyScalar(2.0 * dt));
                    }
                }

                // Bounds check (simple room limits)
                if (toy.mesh.position.x > 15) { toy.mesh.position.x = 15; toy.velocity.x *= -0.8; }
                if (toy.mesh.position.x < -15) { toy.mesh.position.x = -15; toy.velocity.x *= -0.8; }
                if (toy.mesh.position.z > 15) { toy.mesh.position.z = 15; toy.velocity.z *= -0.8; }
                if (toy.mesh.position.z < -15) { toy.mesh.position.z = -15; toy.velocity.z *= -0.8; }
            });

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
