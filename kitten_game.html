<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Kitten Simulator - AI Designed Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        #stats-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            min-width: 180px;
        }
        .stat-bar {
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
            margin: 4px 0 10px 0;
        }
        .stat-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        #action-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .action-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 14px;
        }
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .action-btn:active {
            transform: translateY(0);
        }
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 12px 15px;
            border-radius: 12px;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-size: 13px;
        }
        #kitten-name {
            font-size: 18px;
            font-weight: bold;
            color: #ff6b35;
            margin-bottom: 5px;
        }
        #mood-display {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .mood-emoji {
            font-size: 20px;
        }
        #time-display {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 10;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        .instructions {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1 class="text-2xl font-bold text-white drop-shadow-lg">üê± Kitten Simulator</h1>
        <p class="text-white/90 font-medium bg-black/30 px-4 py-2 rounded-full mt-2 inline-block text-sm">
            Click to pet ‚Ä¢ Drag toys ‚Ä¢ Use buttons below
        </p>
    </div>

    <div id="stats-panel">
        <div id="kitten-name">Whiskers</div>
        <div id="mood-display">
            <span class="mood-emoji">üò∫</span>
            <span id="mood-text">Happy</span>
        </div>
        <div style="margin-top: 12px;">
            <div style="display: flex; justify-content: space-between; font-size: 12px;">
                <span>‚ù§Ô∏è Happiness</span>
                <span id="happiness-val">100%</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill" id="happiness-bar" style="width: 100%; background: linear-gradient(90deg, #ff6b6b, #ff8e8e);"></div>
            </div>

            <div style="display: flex; justify-content: space-between; font-size: 12px;">
                <span>üçñ Hunger</span>
                <span id="hunger-val">100%</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill" id="hunger-bar" style="width: 100%; background: linear-gradient(90deg, #ffa502, #ffbe47);"></div>
            </div>

            <div style="display: flex; justify-content: space-between; font-size: 12px;">
                <span>‚ö° Energy</span>
                <span id="energy-val">100%</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill" id="energy-bar" style="width: 100%; background: linear-gradient(90deg, #26de81, #67e99f);"></div>
            </div>
        </div>
        <div class="instructions">
            üñ±Ô∏è Drag to rotate camera<br>
            üì± Pinch to zoom
        </div>
    </div>

    <div id="info-panel">
        <div style="font-weight: bold; margin-bottom: 5px;">Current Activity</div>
        <div id="activity-display" style="color: #666;">Idle</div>
        <div style="margin-top: 8px; font-size: 11px; color: #888;">
            Age: <span id="kitten-age">Kitten</span>
        </div>
    </div>

    <div id="time-display">
        <span id="time-icon">‚òÄÔ∏è</span> <span id="time-text">Day</span>
    </div>

    <div id="action-panel">
        <button class="action-btn" style="background: linear-gradient(135deg, #ff6b6b, #ee5a5a); color: white;" onclick="feedKitten()">üçñ Feed</button>
        <button class="action-btn" style="background: linear-gradient(135deg, #a55eea, #8854d0); color: white;" onclick="callKitten()">üì¢ Call</button>
        <button class="action-btn" style="background: linear-gradient(135deg, #26de81, #20bf6b); color: white;" onclick="throwToy()">üéæ Throw Toy</button>
        <button class="action-btn" style="background: linear-gradient(135deg, #fed330, #f7b731); color: #333;" onclick="toggleNap()">üò¥ Nap Time</button>
        <a href="games.html" class="action-btn" style="background: linear-gradient(135deg, #4b6cb7, #182848); color: white; text-decoration: none;">‚Üê Back</a>
    </div>

    <div id="tooltip"></div>

    <script>
        // ============================================
        // ENHANCED 3D KITTEN SIMULATOR
        // ============================================

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();

        // Sky gradient background
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.5, '#B0E0E6');
        gradient.addColorStop(1, '#98FB98');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
        const skyTexture = new THREE.CanvasTexture(canvas);
        scene.background = skyTexture;
        scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 14);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- CAMERA CONTROLS ---
        let cameraAngle = 0;
        let cameraHeight = 6;
        let cameraDistance = 14;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x98FB98, 0.4);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.0);
        sunLight.position.set(15, 25, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 60;
        sunLight.shadow.camera.left = -25;
        sunLight.shadow.camera.right = 25;
        sunLight.shadow.camera.top = 25;
        sunLight.shadow.camera.bottom = -25;
        sunLight.shadow.bias = -0.0001;
        scene.add(sunLight);

        // Fill light
        const fillLight = new THREE.DirectionalLight(0xB0E0E6, 0.3);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);

        // ============================================
        // ENVIRONMENT
        // ============================================

        // Ground with grass texture
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Base green
            ctx.fillStyle = '#7cb342';
            ctx.fillRect(0, 0, 256, 256);

            // Grass blades
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const shade = Math.random();
                ctx.fillStyle = shade > 0.5 ? '#8bc34a' : (shade > 0.25 ? '#689f38' : '#558b2f');
                ctx.fillRect(x, y, 2, 4);
            }

            // Some lighter patches
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 256, 10 + Math.random() * 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(139, 195, 74, 0.3)';
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        const grassTexture = createGrassTexture();
        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(20, 20);

        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ map: grassTexture });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Flowers
        const flowers = [];
        const flowerColors = [0xff69b4, 0xffff00, 0xff6347, 0xffa500, 0x9370db, 0xffffff];

        function createFlower(x, z, color) {
            const group = new THREE.Group();

            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.4, 6);
            const stemMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.2;
            group.add(stem);

            // Petals
            const petalGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const petalMat = new THREE.MeshLambertMaterial({ color: color });
            for (let i = 0; i < 5; i++) {
                const petal = new THREE.Mesh(petalGeo, petalMat);
                const angle = (i / 5) * Math.PI * 2;
                petal.position.set(Math.cos(angle) * 0.1, 0.45, Math.sin(angle) * 0.1);
                petal.scale.set(1, 0.5, 1);
                group.add(petal);
            }

            // Center
            const centerGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const centerMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
            const center = new THREE.Mesh(centerGeo, centerMat);
            center.position.y = 0.45;
            group.add(center);

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            scene.add(group);
            flowers.push(group);
        }

        // Place flowers around the scene
        for (let i = 0; i < 40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 8 + Math.random() * 15;
            createFlower(
                Math.cos(angle) * dist,
                Math.sin(angle) * dist,
                flowerColors[Math.floor(Math.random() * flowerColors.length)]
            );
        }

        // Trees
        function createTree(x, z) {
            const group = new THREE.Group();

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const foliageMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 2.8;
            foliage.scale.set(1, 0.8, 1);
            foliage.castShadow = true;
            group.add(foliage);

            group.position.set(x, 0, z);
            scene.add(group);
        }

        createTree(-12, -8);
        createTree(15, -5);
        createTree(-10, 12);
        createTree(18, 10);

        // Cat Bed
        const bedGroup = new THREE.Group();
        const bedBaseGeo = new THREE.CylinderGeometry(1.5, 1.3, 0.3, 24);
        const bedBaseMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
        const bedBase = new THREE.Mesh(bedBaseGeo, bedBaseMat);
        bedBase.position.y = 0.15;
        bedBase.receiveShadow = true;
        bedGroup.add(bedBase);

        const bedCushionGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.25, 24);
        const bedCushionMat = new THREE.MeshStandardMaterial({ color: 0xffe4c4, roughness: 0.95 });
        const bedCushion = new THREE.Mesh(bedCushionGeo, bedCushionMat);
        bedCushion.position.y = 0.35;
        bedGroup.add(bedCushion);

        // Bed rim
        const bedRimGeo = new THREE.TorusGeometry(1.35, 0.2, 8, 24);
        const bedRim = new THREE.Mesh(bedRimGeo, bedBaseMat);
        bedRim.rotation.x = Math.PI / 2;
        bedRim.position.y = 0.4;
        bedGroup.add(bedRim);

        bedGroup.position.set(-5, 0, 4);
        scene.add(bedGroup);

        // Food Bowl
        const foodBowlGroup = new THREE.Group();
        const bowlGeo = new THREE.CylinderGeometry(0.5, 0.35, 0.25, 16);
        const bowlMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness: 0.3, metalness: 0.1 });
        const bowl = new THREE.Mesh(bowlGeo, bowlMat);
        bowl.position.y = 0.125;
        foodBowlGroup.add(bowl);

        const foodGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
        const foodMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
        const food = new THREE.Mesh(foodGeo, foodMat);
        food.position.y = 0.25;
        food.visible = false;
        foodBowlGroup.add(food);

        foodBowlGroup.position.set(5, 0, 3);
        scene.add(foodBowlGroup);

        // Water Bowl
        const waterBowlGroup = new THREE.Group();
        const waterBowl = new THREE.Mesh(bowlGeo, new THREE.MeshStandardMaterial({ color: 0x4169e1, roughness: 0.3, metalness: 0.1 }));
        waterBowl.position.y = 0.125;
        waterBowlGroup.add(waterBowl);

        const waterGeo = new THREE.CylinderGeometry(0.38, 0.38, 0.08, 16);
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, roughness: 0.1, metalness: 0.2, transparent: true, opacity: 0.8 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.y = 0.22;
        waterBowlGroup.add(water);

        waterBowlGroup.position.set(6, 0, 3);
        scene.add(waterBowlGroup);

        // Scratching Post
        const scratchPostGroup = new THREE.Group();
        const postBaseGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.15, 16);
        const postBaseMat = new THREE.MeshStandardMaterial({ color: 0xdeb887, roughness: 0.9 });
        const postBase = new THREE.Mesh(postBaseGeo, postBaseMat);
        postBase.position.y = 0.075;
        scratchPostGroup.add(postBase);

        const postGeo = new THREE.CylinderGeometry(0.3, 0.35, 2.5, 16);
        const postMat = new THREE.MeshStandardMaterial({ color: 0xd2691e, roughness: 1 });
        const post = new THREE.Mesh(postGeo, postMat);
        post.position.y = 1.4;
        post.castShadow = true;
        scratchPostGroup.add(post);

        const platformGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.15, 16);
        const platform = new THREE.Mesh(platformGeo, postBaseMat);
        platform.position.y = 2.75;
        platform.castShadow = true;
        scratchPostGroup.add(platform);

        scratchPostGroup.position.set(-6, 0, -3);
        scene.add(scratchPostGroup);

        // Butterflies
        const butterflies = [];

        function createButterfly() {
            const group = new THREE.Group();
            const wingGeo = new THREE.PlaneGeometry(0.3, 0.2);
            const wingColors = [0xff69b4, 0x87CEEB, 0xffa500, 0xffff00, 0x9370db];
            const wingMat = new THREE.MeshBasicMaterial({
                color: wingColors[Math.floor(Math.random() * wingColors.length)],
                side: THREE.DoubleSide
            });

            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.x = 0.12;
            leftWing.rotation.y = 0.3;
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.x = -0.12;
            rightWing.rotation.y = -0.3;
            group.add(rightWing);

            group.position.set(
                (Math.random() - 0.5) * 20,
                2 + Math.random() * 3,
                (Math.random() - 0.5) * 20
            );

            scene.add(group);
            butterflies.push({
                mesh: group,
                leftWing: leftWing,
                rightWing: rightWing,
                baseY: group.position.y,
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 0.5,
                radius: 3 + Math.random() * 5,
                centerX: group.position.x,
                centerZ: group.position.z
            });
        }

        for (let i = 0; i < 8; i++) {
            createButterfly();
        }

        // ============================================
        // ENHANCED KITTEN MODEL
        // ============================================

        const kittenGroup = new THREE.Group();
        scene.add(kittenGroup);

        // Materials
        const furColor = 0xffaa55;
        const materialFur = new THREE.MeshStandardMaterial({ color: furColor, roughness: 0.85 });
        const materialStripes = new THREE.MeshStandardMaterial({ color: 0xcc7733, roughness: 0.85 });
        const materialWhite = new THREE.MeshStandardMaterial({ color: 0xfff8f0, roughness: 0.85 });
        const materialInnerEar = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.7 });
        const materialEyes = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1, metalness: 0.3 });
        const materialEyeWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const materialIris = new THREE.MeshStandardMaterial({ color: 0x4a9c2d, roughness: 0.2, metalness: 0.1 });
        const materialNose = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.5 });
        const materialPawPad = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.6 });
        const materialWhisker = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // Body - more detailed capsule shape
        function createEnhancedCapsule(radius, length, material, segments = 20) {
            const group = new THREE.Group();
            const cylinderGeo = new THREE.CylinderGeometry(radius, radius * 0.95, length, segments);
            const cylinder = new THREE.Mesh(cylinderGeo, material);
            cylinder.castShadow = true;
            group.add(cylinder);

            const sphereGeo = new THREE.SphereGeometry(radius, segments, segments);
            const topSphere = new THREE.Mesh(sphereGeo, material);
            topSphere.position.y = length / 2;
            topSphere.castShadow = true;
            group.add(topSphere);

            const bottomSphere = new THREE.Mesh(sphereGeo, material);
            bottomSphere.position.y = -length / 2;
            bottomSphere.scale.set(0.95, 0.9, 0.95);
            bottomSphere.castShadow = true;
            group.add(bottomSphere);

            return group;
        }

        // Main Body
        const body = createEnhancedCapsule(0.7, 1.3, materialFur);
        body.rotation.x = Math.PI / 2;
        body.position.y = 1.2;
        kittenGroup.add(body);

        // Belly (white patch)
        const bellyGeo = new THREE.SphereGeometry(0.55, 16, 16);
        const belly = new THREE.Mesh(bellyGeo, materialWhite);
        belly.scale.set(0.9, 0.6, 1);
        belly.position.set(0, 0.9, 0.3);
        kittenGroup.add(belly);

        // Stripes on body
        for (let i = 0; i < 4; i++) {
            const stripeGeo = new THREE.BoxGeometry(0.05, 0.4, 0.6);
            const stripe = new THREE.Mesh(stripeGeo, materialStripes);
            stripe.position.set(0.6 - i * 0.15, 1.35, 0.1);
            stripe.rotation.z = 0.3 - i * 0.15;
            kittenGroup.add(stripe);
        }

        // Head Group
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 1.8, 1.1);
        kittenGroup.add(headGroup);

        // Main head
        const headGeo = new THREE.SphereGeometry(0.68, 20, 20);
        const head = new THREE.Mesh(headGeo, materialFur);
        head.castShadow = true;
        head.scale.set(1, 0.95, 0.9);
        headGroup.add(head);

        // Cheeks
        const cheekGeo = new THREE.SphereGeometry(0.25, 12, 12);
        const leftCheek = new THREE.Mesh(cheekGeo, materialWhite);
        leftCheek.position.set(0.35, -0.15, 0.45);
        leftCheek.scale.set(1, 0.8, 0.7);
        headGroup.add(leftCheek);

        const rightCheek = new THREE.Mesh(cheekGeo, materialWhite);
        rightCheek.position.set(-0.35, -0.15, 0.45);
        rightCheek.scale.set(1, 0.8, 0.7);
        headGroup.add(rightCheek);

        // Muzzle
        const muzzleGeo = new THREE.SphereGeometry(0.2, 12, 12);
        const muzzle = new THREE.Mesh(muzzleGeo, materialWhite);
        muzzle.position.set(0, -0.15, 0.55);
        muzzle.scale.set(1.2, 0.8, 0.8);
        headGroup.add(muzzle);

        // Ears with inner ear
        function createEar(isLeft) {
            const earGroup = new THREE.Group();

            const earGeo = new THREE.ConeGeometry(0.22, 0.45, 16);
            const ear = new THREE.Mesh(earGeo, materialFur);
            ear.castShadow = true;
            earGroup.add(ear);

            const innerEarGeo = new THREE.ConeGeometry(0.12, 0.3, 12);
            const innerEar = new THREE.Mesh(innerEarGeo, materialInnerEar);
            innerEar.position.z = 0.05;
            innerEar.position.y = -0.05;
            earGroup.add(innerEar);

            // Ear tuft
            const tuftGeo = new THREE.ConeGeometry(0.05, 0.15, 6);
            const tuft = new THREE.Mesh(tuftGeo, materialFur);
            tuft.position.y = 0.2;
            earGroup.add(tuft);

            return earGroup;
        }

        const leftEar = createEar(true);
        leftEar.position.set(0.35, 0.6, 0.15);
        leftEar.rotation.x = -0.15;
        leftEar.rotation.z = -0.25;
        headGroup.add(leftEar);

        const rightEar = createEar(false);
        rightEar.position.set(-0.35, 0.6, 0.15);
        rightEar.rotation.x = -0.15;
        rightEar.rotation.z = 0.25;
        headGroup.add(rightEar);

        // Enhanced Eyes
        function createEye(isLeft) {
            const eyeGroup = new THREE.Group();

            // Eye white
            const eyeWhiteGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeWhite = new THREE.Mesh(eyeWhiteGeo, materialEyeWhite);
            eyeWhite.scale.set(1, 1.1, 0.6);
            eyeGroup.add(eyeWhite);

            // Iris
            const irisGeo = new THREE.SphereGeometry(0.08, 16, 16);
            const iris = new THREE.Mesh(irisGeo, materialIris);
            iris.position.z = 0.05;
            eyeGroup.add(iris);

            // Pupil
            const pupilGeo = new THREE.SphereGeometry(0.04, 12, 12);
            const pupil = new THREE.Mesh(pupilGeo, materialEyes);
            pupil.position.z = 0.08;
            eyeGroup.add(pupil);

            // Eye shine
            const shineGeo = new THREE.SphereGeometry(0.02, 8, 8);
            const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const shine = new THREE.Mesh(shineGeo, shineMat);
            shine.position.set(0.03, 0.03, 0.1);
            eyeGroup.add(shine);

            // Eyelid (for blinking)
            const eyelidGeo = new THREE.SphereGeometry(0.13, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const eyelidMat = new THREE.MeshStandardMaterial({ color: furColor, roughness: 0.85 });
            const eyelid = new THREE.Mesh(eyelidGeo, eyelidMat);
            eyelid.rotation.x = Math.PI;
            eyelid.position.z = 0.02;
            eyelid.scale.y = 0;
            eyeGroup.add(eyelid);

            eyeGroup.userData = { eyelid, iris, pupil };

            return eyeGroup;
        }

        const leftEye = createEye(true);
        leftEye.position.set(0.22, 0.12, 0.52);
        headGroup.add(leftEye);

        const rightEye = createEye(false);
        rightEye.position.set(-0.22, 0.12, 0.52);
        headGroup.add(rightEye);

        // Nose
        const noseGeo = new THREE.SphereGeometry(0.07, 12, 12);
        const nose = new THREE.Mesh(noseGeo, materialNose);
        nose.position.set(0, -0.05, 0.62);
        nose.scale.set(1.2, 0.8, 0.8);
        headGroup.add(nose);

        // Mouth line
        const mouthCurve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(-0.08, -0.18, 0.58),
            new THREE.Vector3(0, -0.22, 0.6),
            new THREE.Vector3(0.08, -0.18, 0.58)
        );
        const mouthGeo = new THREE.TubeGeometry(mouthCurve, 10, 0.01, 6, false);
        const mouthMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const mouth = new THREE.Mesh(mouthGeo, mouthMat);
        headGroup.add(mouth);

        // Whiskers
        function createWhisker(startX, startY, endX, endY, startZ) {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(startX, startY, startZ),
                new THREE.Vector3(startX + (endX - startX) * 0.5, startY + 0.02, startZ + 0.1),
                new THREE.Vector3(endX, endY, startZ + 0.05)
            );
            const geo = new THREE.TubeGeometry(curve, 8, 0.008, 4, false);
            return new THREE.Mesh(geo, materialWhisker);
        }

        // Left whiskers
        const whiskerL1 = createWhisker(0.2, -0.1, 0.6, -0.05, 0.5);
        const whiskerL2 = createWhisker(0.2, -0.12, 0.6, -0.12, 0.5);
        const whiskerL3 = createWhisker(0.2, -0.14, 0.6, -0.2, 0.5);
        headGroup.add(whiskerL1, whiskerL2, whiskerL3);

        // Right whiskers
        const whiskerR1 = createWhisker(-0.2, -0.1, -0.6, -0.05, 0.5);
        const whiskerR2 = createWhisker(-0.2, -0.12, -0.6, -0.12, 0.5);
        const whiskerR3 = createWhisker(-0.2, -0.14, -0.6, -0.2, 0.5);
        headGroup.add(whiskerR1, whiskerR2, whiskerR3);

        // Legs with paw pads
        const legs = [];

        function createLeg(x, z, name) {
            const legGroup = new THREE.Group();
            legGroup.position.set(x, 1.0, z);

            // Upper leg
            const upperLegGeo = new THREE.CylinderGeometry(0.14, 0.12, 0.5, 10);
            const upperLeg = new THREE.Mesh(upperLegGeo, materialFur);
            upperLeg.position.y = -0.25;
            upperLeg.castShadow = true;
            legGroup.add(upperLeg);

            // Lower leg
            const lowerLegGroup = new THREE.Group();
            lowerLegGroup.position.y = -0.5;

            const lowerLegGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.5, 10);
            const lowerLeg = new THREE.Mesh(lowerLegGeo, materialFur);
            lowerLeg.position.y = -0.25;
            lowerLeg.castShadow = true;
            lowerLegGroup.add(lowerLeg);

            // Paw
            const pawGeo = new THREE.SphereGeometry(0.12, 10, 10);
            const paw = new THREE.Mesh(pawGeo, materialWhite);
            paw.position.y = -0.5;
            paw.scale.set(1.1, 0.6, 1.3);
            lowerLegGroup.add(paw);

            // Paw pads
            const padGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const mainPad = new THREE.Mesh(padGeo, materialPawPad);
            mainPad.position.set(0, -0.52, 0.05);
            mainPad.scale.set(1.5, 0.5, 1.2);
            lowerLegGroup.add(mainPad);

            // Toe beans
            for (let i = 0; i < 3; i++) {
                const toePad = new THREE.Mesh(padGeo, materialPawPad);
                toePad.position.set(-0.04 + i * 0.04, -0.5, 0.1);
                toePad.scale.set(0.8, 0.4, 0.8);
                lowerLegGroup.add(toePad);
            }

            legGroup.add(lowerLegGroup);
            legGroup.userData = { lowerLeg: lowerLegGroup };

            kittenGroup.add(legGroup);
            legs.push({ mesh: legGroup, lowerLeg: lowerLegGroup, name: name, initialRot: 0 });
            return legGroup;
        }

        const legFL = createLeg(0.35, 0.55, 'FL');
        const legFR = createLeg(-0.35, 0.55, 'FR');
        const legBL = createLeg(0.35, -0.55, 'BL');
        const legBR = createLeg(-0.35, -0.55, 'BR');

        // Tail
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1.35, -0.85);
        kittenGroup.add(tailGroup);

        // Create segmented tail for better animation
        const tailSegments = [];
        let prevSegment = tailGroup;

        for (let i = 0; i < 5; i++) {
            const segGroup = new THREE.Group();
            const radius = 0.1 - i * 0.015;
            const segGeo = new THREE.CylinderGeometry(radius, radius + 0.01, 0.25, 8);
            const segment = new THREE.Mesh(segGeo, materialFur);
            segment.rotation.x = -Math.PI / 6;
            segment.position.y = 0.12;
            segment.castShadow = true;
            segGroup.add(segment);
            segGroup.position.y = i === 0 ? 0 : 0.2;
            prevSegment.add(segGroup);
            tailSegments.push(segGroup);
            prevSegment = segGroup;
        }

        // Tail tip
        const tailTipGeo = new THREE.SphereGeometry(0.06, 8, 8);
        const tailTip = new THREE.Mesh(tailTipGeo, materialStripes);
        tailTip.position.y = 0.15;
        tailSegments[tailSegments.length - 1].add(tailTip);

        // ============================================
        // TOYS
        // ============================================

        const toys = [];

        // Yarn ball
        function createYarnBall(x, z, color) {
            const group = new THREE.Group();
            const ballGeo = new THREE.SphereGeometry(0.35, 20, 20);
            const ballMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9 });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            ball.castShadow = true;
            group.add(ball);

            // Yarn lines
            for (let i = 0; i < 8; i++) {
                const curve = new THREE.EllipseCurve(0, 0, 0.36, 0.36, 0, Math.PI * 2, false, Math.random() * Math.PI);
                const points = curve.getPoints(20);
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, p.y, 0)));
                const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                const line = new THREE.Line(lineGeo, lineMat);
                line.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                group.add(line);
            }

            group.position.set(x, 0.35, z);
            scene.add(group);
            toys.push({ mesh: group, type: 'ball', radius: 0.35, velocity: new THREE.Vector3(), angularVel: new THREE.Vector3() });
            return group;
        }

        // Mouse toy
        function createMouseToy(x, z) {
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.SphereGeometry(0.2, 12, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const mouseBody = new THREE.Mesh(bodyGeo, bodyMat);
            mouseBody.scale.set(1, 0.8, 1.5);
            mouseBody.castShadow = true;
            group.add(mouseBody);

            // Ears
            const earGeo = new THREE.CircleGeometry(0.08, 12);
            const earMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, side: THREE.DoubleSide });
            const leftMouseEar = new THREE.Mesh(earGeo, earMat);
            leftMouseEar.position.set(0.1, 0.12, 0.15);
            leftMouseEar.rotation.x = -0.3;
            group.add(leftMouseEar);

            const rightMouseEar = new THREE.Mesh(earGeo, earMat);
            rightMouseEar.position.set(-0.1, 0.12, 0.15);
            rightMouseEar.rotation.x = -0.3;
            group.add(rightMouseEar);

            // Tail
            const tailCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, -0.3),
                new THREE.Vector3(0, 0.1, -0.5),
                new THREE.Vector3(0, 0, -0.7)
            );
            const tailGeo = new THREE.TubeGeometry(tailCurve, 10, 0.02, 6, false);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            group.add(tail);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftMouseEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftMouseEye.position.set(0.06, 0.05, 0.25);
            group.add(leftMouseEye);

            const rightMouseEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightMouseEye.position.set(-0.06, 0.05, 0.25);
            group.add(rightMouseEye);

            group.position.set(x, 0.15, z);
            scene.add(group);
            toys.push({ mesh: group, type: 'mouse', radius: 0.25, velocity: new THREE.Vector3(), angularVel: new THREE.Vector3() });
            return group;
        }

        // Feather toy
        function createFeatherToy(x, z) {
            const group = new THREE.Group();

            // Stick
            const stickGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.8, 8);
            const stickMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const stick = new THREE.Mesh(stickGeo, stickMat);
            stick.rotation.x = Math.PI / 4;
            stick.position.y = 0.3;
            group.add(stick);

            // Feathers
            const featherColors = [0xff69b4, 0x9370db, 0x00ced1];
            for (let i = 0; i < 5; i++) {
                const featherGeo = new THREE.PlaneGeometry(0.08, 0.3);
                const featherMat = new THREE.MeshStandardMaterial({
                    color: featherColors[i % featherColors.length],
                    side: THREE.DoubleSide
                });
                const feather = new THREE.Mesh(featherGeo, featherMat);
                feather.position.set(Math.sin(i * 0.5) * 0.05, 0.7, Math.cos(i * 0.5) * 0.05);
                feather.rotation.set(0.2, i * 0.3, 0);
                group.add(feather);
            }

            group.position.set(x, 0, z);
            scene.add(group);
            toys.push({ mesh: group, type: 'feather', radius: 0.3, velocity: new THREE.Vector3(), angularVel: new THREE.Vector3() });
            return group;
        }

        createYarnBall(3, 2, 0xff6b6b);
        createYarnBall(-2, -3, 0x4ecdc4);
        createMouseToy(4, -2);
        createFeatherToy(-4, 1);

        // ============================================
        // PARTICLES
        // ============================================

        const particles = [];

        // Heart particles
        function createHeartShape() {
            const shape = new THREE.Shape();
            shape.moveTo(0.25, 0.25);
            shape.bezierCurveTo(0.25, 0.25, 0.20, 0, 0, 0);
            shape.bezierCurveTo(-0.30, 0, -0.30, 0.35, -0.30, 0.35);
            shape.bezierCurveTo(-0.30, 0.55, -0.10, 0.77, 0.25, 0.95);
            shape.bezierCurveTo(0.60, 0.77, 0.80, 0.55, 0.80, 0.35);
            shape.bezierCurveTo(0.80, 0.35, 0.80, 0, 0.50, 0);
            shape.bezierCurveTo(0.35, 0, 0.25, 0.25, 0.25, 0.25);
            return shape;
        }

        const heartGeo = new THREE.ShapeGeometry(createHeartShape());
        const heartMat = new THREE.MeshBasicMaterial({ color: 0xff69b4, side: THREE.DoubleSide, transparent: true });

        function spawnHeart(intensity = 1) {
            const heart = new THREE.Mesh(heartGeo, heartMat.clone());
            heart.scale.set(0.15 * intensity, 0.15 * intensity, 0.15 * intensity);
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            heart.position.copy(worldPos);
            heart.position.y += 0.8 + Math.random() * 0.3;
            heart.position.x += (Math.random() - 0.5) * 0.5;
            heart.rotation.z = Math.PI + (Math.random() - 0.5) * 0.3;
            scene.add(heart);
            particles.push({
                mesh: heart,
                type: 'heart',
                life: 1.5,
                speedY: 1.0 + Math.random() * 0.5,
                speedX: (Math.random() - 0.5) * 0.5,
                rotSpeed: (Math.random() - 0.5) * 2
            });
        }

        // Zzz particles
        function createZzzTexture(letter = 'Z') {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter, 32, 32);
            ctx.strokeStyle = '#88ccff';
            ctx.lineWidth = 2;
            ctx.strokeText(letter, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const zzzTexture = createZzzTexture();

        function spawnZzz() {
            const zzzMaterial = new THREE.SpriteMaterial({ map: zzzTexture, transparent: true, opacity: 0.9 });
            const zzz = new THREE.Sprite(zzzMaterial);
            zzz.scale.set(0.4, 0.4, 0.4);
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            zzz.position.copy(worldPos);
            zzz.position.y += 0.6;
            zzz.position.x += 0.3;
            scene.add(zzz);
            particles.push({
                mesh: zzz,
                type: 'zzz',
                life: 2.5,
                speedY: 0.4,
                swayOffset: Math.random() * 10,
                startX: zzz.position.x
            });
        }

        // Musical notes (for purring)
        function createNoteTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px sans-serif';
            ctx.fillStyle = '#ffa500';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚ô™', 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const noteTexture = createNoteTexture();

        function spawnNote() {
            const noteMaterial = new THREE.SpriteMaterial({ map: noteTexture, transparent: true, opacity: 0.8 });
            const note = new THREE.Sprite(noteMaterial);
            note.scale.set(0.3, 0.3, 0.3);
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            note.position.copy(worldPos);
            note.position.y += 0.5;
            note.position.x += (Math.random() - 0.5) * 0.3;
            scene.add(note);
            particles.push({
                mesh: note,
                type: 'note',
                life: 1.5,
                speedY: 0.8 + Math.random() * 0.3,
                speedX: (Math.random() - 0.5) * 0.5,
                startY: note.position.y
            });
        }

        // Dust motes
        function spawnDust(pos) {
            const dustGeo = new THREE.SphereGeometry(0.02, 6, 6);
            const dustMat = new THREE.MeshBasicMaterial({ color: 0xffebcd, transparent: true, opacity: 0.6 });
            const dust = new THREE.Mesh(dustGeo, dustMat);
            dust.position.copy(pos);
            dust.position.y += Math.random() * 0.3;
            scene.add(dust);
            particles.push({
                mesh: dust,
                type: 'dust',
                life: 2,
                speedY: 0.2 + Math.random() * 0.1,
                speedX: (Math.random() - 0.5) * 0.3,
                speedZ: (Math.random() - 0.5) * 0.3
            });
        }

        // Sparkle effect
        function spawnSparkle(pos) {
            const sparkleGeo = new THREE.OctahedronGeometry(0.05, 0);
            const sparkleMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true });
            const sparkle = new THREE.Mesh(sparkleGeo, sparkleMat);
            sparkle.position.copy(pos);
            scene.add(sparkle);
            particles.push({
                mesh: sparkle,
                type: 'sparkle',
                life: 0.5,
                speedY: 1 + Math.random(),
                rotSpeed: 10
            });
        }

        // ============================================
        // KITTEN STATS & STATE
        // ============================================

        const stats = {
            happiness: 100,
            hunger: 100,
            energy: 100
        };

        let state = 'IDLE';
        let stateTimer = 0;
        let targetPos = new THREE.Vector3();
        let walkSpeed = 2.0;
        let runSpeed = 4.5;
        let currentSpeed = walkSpeed;
        let turnSpeed = 3.5;
        let blinkTimer = 0;
        let blinkDuration = 0;
        let isBlinking = false;
        let earTwitchTimer = 0;
        let gameTime = 0;
        let dayPhase = 'day';

        // ============================================
        // AUDIO SYSTEM
        // ============================================

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioInitialized = false;

        function initAudio() {
            if (!audioInitialized) {
                audioContext.resume();
                audioInitialized = true;
            }
        }

        function playMeow() {
            initAudio();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(600, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.15);
            osc.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.3);

            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }

        function playPurr() {
            initAudio();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();

            lfo.frequency.value = 25;
            lfoGain.gain.value = 30;
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);

            osc.frequency.value = 80;
            osc.type = 'sawtooth';
            osc.connect(gain);
            gain.connect(audioContext.destination);

            gain.gain.setValueAtTime(0.05, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            lfo.start();
            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
            lfo.stop(audioContext.currentTime + 0.5);
        }

        function playHappyChirp() {
            initAudio();
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(500, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);

            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

            osc.start();
            osc.stop(audioContext.currentTime + 0.15);
        }

        // ============================================
        // HELPER FUNCTIONS
        // ============================================

        function pickRandomPoint(maxDist = 8) {
            const r = maxDist * Math.sqrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            return new THREE.Vector3(r * Math.cos(theta), 0, r * Math.sin(theta));
        }

        function distanceTo(target) {
            return kittenGroup.position.distanceTo(target);
        }

        function updateStats(dt) {
            // Decrease stats over time
            stats.hunger = Math.max(0, stats.hunger - dt * 0.5);
            stats.energy = Math.max(0, stats.energy - dt * 0.3);

            // Happiness affected by other stats
            if (stats.hunger < 30) stats.happiness = Math.max(0, stats.happiness - dt * 1);
            if (stats.energy < 20) stats.happiness = Math.max(0, stats.happiness - dt * 0.5);

            // Recover energy when sleeping
            if (state === 'SLEEP') {
                stats.energy = Math.min(100, stats.energy + dt * 5);
            }

            // Update UI
            document.getElementById('happiness-bar').style.width = stats.happiness + '%';
            document.getElementById('hunger-bar').style.width = stats.hunger + '%';
            document.getElementById('energy-bar').style.width = stats.energy + '%';
            document.getElementById('happiness-val').textContent = Math.round(stats.happiness) + '%';
            document.getElementById('hunger-val').textContent = Math.round(stats.hunger) + '%';
            document.getElementById('energy-val').textContent = Math.round(stats.energy) + '%';

            // Update mood
            const moodEmoji = document.querySelector('.mood-emoji');
            const moodText = document.getElementById('mood-text');

            if (stats.happiness > 80) {
                moodEmoji.textContent = 'üò∫';
                moodText.textContent = 'Very Happy';
            } else if (stats.happiness > 50) {
                moodEmoji.textContent = 'üê±';
                moodText.textContent = 'Content';
            } else if (stats.happiness > 25) {
                moodEmoji.textContent = 'üòø';
                moodText.textContent = 'Sad';
            } else {
                moodEmoji.textContent = 'üôÄ';
                moodText.textContent = 'Upset';
            }
        }

        function updateActivityDisplay() {
            const activityEl = document.getElementById('activity-display');
            const activities = {
                'IDLE': 'üí≠ Relaxing',
                'WALK': 'üö∂ Exploring',
                'RUN': 'üèÉ Running',
                'SLEEP': 'üò¥ Sleeping',
                'PET': '‚ù§Ô∏è Being Petted',
                'EAT': 'üçñ Eating',
                'PLAY': 'üéæ Playing',
                'GROOM': 'üßπ Grooming',
                'STRETCH': 'üôÜ Stretching',
                'SIT': 'ü™ë Sitting',
                'POUNCE': 'üêæ Pouncing'
            };
            activityEl.textContent = activities[state] || state;
        }

        // ============================================
        // INTERACTION
        // ============================================

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let draggedToy = null;
        let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        function onPointerDown(event) {
            initAudio();

            if (event.target.tagName === 'BUTTON' || event.target.tagName === 'A') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check for toy click
            const toyMeshes = toys.map(t => t.mesh);
            const toyIntersects = raycaster.intersectObjects(toyMeshes, true);

            if (toyIntersects.length > 0) {
                let toyObj = toyIntersects[0].object;
                while (toyObj.parent && !toys.find(t => t.mesh === toyObj)) {
                    toyObj = toyObj.parent;
                }
                draggedToy = toys.find(t => t.mesh === toyObj);
                isDragging = false;
                return;
            }

            // Check for kitten click
            const kittenIntersects = raycaster.intersectObjects(kittenGroup.children, true);
            if (kittenIntersects.length > 0) {
                petKitten();
                isDragging = false;
                return;
            }

            // Start camera drag
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function onPointerMove(event) {
            if (draggedToy) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);

                if (intersectPoint) {
                    draggedToy.mesh.position.x = intersectPoint.x;
                    draggedToy.mesh.position.z = intersectPoint.z;
                    draggedToy.mesh.position.y = 1;
                }
            } else if (isDragging) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(2, Math.min(15, cameraHeight - deltaY * 0.05));

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onPointerUp(event) {
            if (draggedToy) {
                // Throw the toy
                const throwForce = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    0,
                    (Math.random() - 0.5) * 5
                );
                draggedToy.velocity.add(throwForce);
                draggedToy.mesh.position.y = draggedToy.type === 'ball' ? 0.35 : 0.15;
                draggedToy = null;
            }
            isDragging = false;
        }

        function onWheel(event) {
            cameraDistance = Math.max(5, Math.min(25, cameraDistance + event.deltaY * 0.01));
        }

        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('wheel', onWheel);

        // Touch support
        let lastTouchDist = 0;
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                cameraDistance = Math.max(5, Math.min(25, cameraDistance - (dist - lastTouchDist) * 0.05));
                lastTouchDist = dist;
            }
        });

        // ============================================
        // ACTION FUNCTIONS
        // ============================================

        function petKitten() {
            state = 'PET';
            stateTimer = 2.0;
            stats.happiness = Math.min(100, stats.happiness + 15);
            playPurr();
            for (let i = 0; i < 5; i++) {
                setTimeout(() => spawnHeart(1 + Math.random() * 0.5), i * 100);
            }
        }

        function feedKitten() {
            initAudio();
            food.visible = true;

            // Make kitten go to food
            state = 'WALK';
            targetPos = foodBowlGroup.position.clone();
            targetPos.y = 0;
            stateTimer = 10;

            // When kitten arrives, eat
            setTimeout(() => {
                if (distanceTo(foodBowlGroup.position) < 2) {
                    state = 'EAT';
                    stateTimer = 3;
                    stats.hunger = Math.min(100, stats.hunger + 40);
                    stats.happiness = Math.min(100, stats.happiness + 10);
                    playHappyChirp();
                    setTimeout(() => {
                        food.visible = false;
                    }, 3000);
                }
            }, 3000);
        }

        function callKitten() {
            initAudio();
            playMeow();

            // Kitten comes to camera
            state = 'RUN';
            currentSpeed = runSpeed;
            targetPos = new THREE.Vector3(
                Math.sin(cameraAngle) * 3,
                0,
                Math.cos(cameraAngle) * 3
            );
            stateTimer = 5;
            stats.happiness = Math.min(100, stats.happiness + 5);
        }

        function throwToy() {
            initAudio();

            // Pick random toy
            const toy = toys[Math.floor(Math.random() * toys.length)];

            // Throw it somewhere
            const throwTarget = pickRandomPoint(10);
            toy.velocity.set(
                (throwTarget.x - toy.mesh.position.x) * 2,
                3,
                (throwTarget.z - toy.mesh.position.z) * 2
            );

            // Kitten chases
            setTimeout(() => {
                state = 'POUNCE';
                targetPos = toy.mesh.position.clone();
                targetPos.y = 0;
                currentSpeed = runSpeed;
                stateTimer = 5;
            }, 300);
        }

        function toggleNap() {
            initAudio();

            if (state === 'SLEEP') {
                state = 'IDLE';
                stateTimer = 1;
            } else {
                // Go to bed first
                state = 'WALK';
                targetPos = bedGroup.position.clone();
                targetPos.y = 0;
                stateTimer = 10;

                setTimeout(() => {
                    if (distanceTo(bedGroup.position) < 2.5) {
                        kittenGroup.position.copy(bedGroup.position);
                        kittenGroup.position.y = 0.35;
                        state = 'SLEEP';
                        stateTimer = 15;
                    }
                }, 3000);
            }
        }

        // Expose functions globally
        window.feedKitten = feedKitten;
        window.callKitten = callKitten;
        window.throwToy = throwToy;
        window.toggleNap = toggleNap;

        // ============================================
        // ANIMATION LOOP
        // ============================================

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            gameTime += dt;

            // Update camera position
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(kittenGroup.position.x, 1, kittenGroup.position.z);

            // Update stats
            updateStats(dt);
            updateActivityDisplay();

            // Day/Night cycle (sped up for demo)
            const dayLength = 120; // 2 minutes per day
            const dayProgress = (gameTime % dayLength) / dayLength;

            if (dayProgress < 0.25 || dayProgress > 0.75) {
                dayPhase = 'night';
                document.getElementById('time-icon').textContent = 'üåô';
                document.getElementById('time-text').textContent = 'Night';
                sunLight.intensity = 0.3;
                ambientLight.intensity = 0.2;
            } else {
                dayPhase = 'day';
                document.getElementById('time-icon').textContent = '‚òÄÔ∏è';
                document.getElementById('time-text').textContent = 'Day';
                sunLight.intensity = 1.0;
                ambientLight.intensity = 0.5;
            }

            // Blinking
            blinkTimer -= dt;
            if (blinkTimer <= 0 && !isBlinking) {
                isBlinking = true;
                blinkDuration = 0.15;
                blinkTimer = 2 + Math.random() * 4;
            }

            if (isBlinking) {
                blinkDuration -= dt;
                const blinkAmount = blinkDuration > 0.075 ? 1 - (0.15 - blinkDuration) / 0.075 : blinkDuration / 0.075;
                leftEye.userData.eyelid.scale.y = 1 - blinkAmount;
                rightEye.userData.eyelid.scale.y = 1 - blinkAmount;
                if (blinkDuration <= 0) isBlinking = false;
            }

            // Ear twitching
            earTwitchTimer -= dt;
            if (earTwitchTimer <= 0) {
                const twitchEar = Math.random() > 0.5 ? leftEar : rightEar;
                twitchEar.rotation.z += (Math.random() - 0.5) * 0.2;
                earTwitchTimer = 1 + Math.random() * 3;
            }
            leftEar.rotation.z = THREE.MathUtils.lerp(leftEar.rotation.z, -0.25, dt * 3);
            rightEar.rotation.z = THREE.MathUtils.lerp(rightEar.rotation.z, 0.25, dt * 3);

            // Whisker animation
            const whiskerWave = Math.sin(time * 3) * 0.02;
            whiskerL1.rotation.z = whiskerWave;
            whiskerL2.rotation.z = -whiskerWave;
            whiskerR1.rotation.z = -whiskerWave;
            whiskerR2.rotation.z = whiskerWave;

            // Tail animation (always active with segments)
            const tailWave = Math.sin(time * 2) * 0.15;
            tailSegments.forEach((seg, i) => {
                seg.rotation.z = tailWave * (i + 1) * 0.3;
                seg.rotation.x = Math.sin(time * 1.5 + i * 0.5) * 0.1;
            });

            // State machine
            if (state === 'IDLE') {
                stateTimer -= dt;

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 2.5) * 0.02, 1);

                // Subtle head movement
                headGroup.rotation.y = Math.sin(time * 0.5) * 0.05;
                headGroup.rotation.x = Math.sin(time * 0.3) * 0.02;

                // Return to standing pose
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 3 * dt);
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 3 * dt);
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.8, 3 * dt);

                // Reset legs
                legs.forEach(leg => {
                    leg.mesh.rotation.x = THREE.MathUtils.lerp(leg.mesh.rotation.x, 0, 5 * dt);
                });

                // Eyes open
                leftEye.userData.eyelid.scale.y = THREE.MathUtils.lerp(leftEye.userData.eyelid.scale.y, 0, 5 * dt);
                rightEye.userData.eyelid.scale.y = THREE.MathUtils.lerp(rightEye.userData.eyelid.scale.y, 0, 5 * dt);

                if (stateTimer <= 0) {
                    // Choose next behavior based on needs
                    if (stats.energy < 30) {
                        state = 'SLEEP';
                        targetPos = bedGroup.position.clone();
                        stateTimer = 8 + Math.random() * 7;
                    } else if (stats.hunger < 40 && food.visible) {
                        state = 'WALK';
                        targetPos = foodBowlGroup.position.clone();
                        targetPos.y = 0;
                        stateTimer = 10;
                    } else if (Math.random() < 0.1) {
                        state = 'GROOM';
                        stateTimer = 3 + Math.random() * 2;
                    } else if (Math.random() < 0.1) {
                        state = 'STRETCH';
                        stateTimer = 2;
                    } else if (Math.random() < 0.15) {
                        state = 'SIT';
                        stateTimer = 3 + Math.random() * 4;
                    } else if (Math.random() < 0.2 && toys.length > 0) {
                        state = 'PLAY';
                        const randomToy = toys[Math.floor(Math.random() * toys.length)];
                        targetPos = randomToy.mesh.position.clone();
                        targetPos.y = 0;
                        stateTimer = 5;
                    } else {
                        state = 'WALK';
                        targetPos = pickRandomPoint();
                        currentSpeed = walkSpeed;
                        stateTimer = 5 + Math.random() * 3;
                    }
                }
            }
            else if (state === 'WALK' || state === 'RUN' || state === 'POUNCE' || state === 'PLAY') {
                stateTimer -= dt;

                const currentPos = kittenGroup.position.clone();
                const direction = targetPos.clone().sub(currentPos);
                direction.y = 0;
                const dist = direction.length();

                if (dist < 0.3 || stateTimer <= 0) {
                    if (state === 'POUNCE') {
                        // Pounce animation
                        for (let i = 0; i < 3; i++) {
                            spawnDust(kittenGroup.position);
                        }
                        stats.happiness = Math.min(100, stats.happiness + 5);
                        playHappyChirp();
                    }
                    state = 'IDLE';
                    stateTimer = 1 + Math.random() * 2;
                    currentSpeed = walkSpeed;
                } else {
                    direction.normalize();

                    // Rotate towards target
                    const targetRotation = Math.atan2(direction.x, direction.z);
                    let rotDiff = targetRotation - kittenGroup.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    kittenGroup.rotation.y += rotDiff * turnSpeed * dt;

                    // Move forward
                    kittenGroup.position.add(direction.multiplyScalar(currentSpeed * dt));

                    // Walk/Run animation
                    const legAmp = state === 'RUN' || state === 'POUNCE' ? 0.6 : 0.35;
                    const legFreq = state === 'RUN' || state === 'POUNCE' ? 15 : 8;
                    legs[0].mesh.rotation.x = Math.sin(time * legFreq) * legAmp;
                    legs[1].mesh.rotation.x = Math.cos(time * legFreq) * legAmp;
                    legs[2].mesh.rotation.x = Math.cos(time * legFreq) * legAmp;
                    legs[3].mesh.rotation.x = Math.sin(time * legFreq) * legAmp;

                    // Body bob
                    kittenGroup.position.y = Math.abs(Math.sin(time * legFreq * 2)) * 0.05;
                    headGroup.position.y = 1.8 + Math.sin(time * legFreq * 2) * 0.03;

                    // Occasionally spawn dust while running
                    if ((state === 'RUN' || state === 'POUNCE') && Math.random() < 0.02) {
                        spawnDust(kittenGroup.position);
                    }
                }
            }
            else if (state === 'SLEEP') {
                stateTimer -= dt;

                // Move towards bed if not there
                if (distanceTo(bedGroup.position) > 2.5) {
                    const direction = bedGroup.position.clone().sub(kittenGroup.position);
                    direction.y = 0;
                    direction.normalize();
                    kittenGroup.position.add(direction.multiplyScalar(walkSpeed * dt));

                    const targetRotation = Math.atan2(direction.x, direction.z);
                    kittenGroup.rotation.y = THREE.MathUtils.lerp(kittenGroup.rotation.y, targetRotation, turnSpeed * dt);
                } else {
                    // Sleep animation
                    kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.5, 2 * dt);
                    kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0.4, 2 * dt);
                    headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.3, 2 * dt);

                    // Close eyes
                    leftEye.userData.eyelid.scale.y = THREE.MathUtils.lerp(leftEye.userData.eyelid.scale.y, 1, 5 * dt);
                    rightEye.userData.eyelid.scale.y = THREE.MathUtils.lerp(rightEye.userData.eyelid.scale.y, 1, 5 * dt);

                    // Curl legs
                    legs.forEach(leg => {
                        leg.mesh.rotation.x = THREE.MathUtils.lerp(leg.mesh.rotation.x, 0.5, 3 * dt);
                    });

                    // Slow breathing
                    body.scale.set(1, 1 + Math.sin(time * 1.5) * 0.03, 1);

                    // Spawn Zzz
                    if (Math.random() < 0.015) spawnZzz();
                }

                if (stateTimer <= 0) {
                    state = 'STRETCH';
                    stateTimer = 2;
                }
            }
            else if (state === 'PET') {
                stateTimer -= dt;

                // Happy vibration
                kittenGroup.position.y = Math.sin(time * 40) * 0.015;
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 5 * dt);

                // Squint eyes happily
                leftEye.userData.eyelid.scale.y = 0.7;
                rightEye.userData.eyelid.scale.y = 0.7;

                // Fast tail wag
                tailSegments.forEach((seg, i) => {
                    seg.rotation.z = Math.sin(time * 12 + i) * 0.4;
                });

                // Purr particles
                if (Math.random() < 0.03) spawnNote();
                if (Math.random() < 0.02) spawnHeart(0.7);

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1;
                    kittenGroup.position.y = 0;
                }
            }
            else if (state === 'EAT') {
                stateTimer -= dt;

                // Face the bowl
                const toBowl = foodBowlGroup.position.clone().sub(kittenGroup.position);
                toBowl.y = 0;
                const targetRot = Math.atan2(toBowl.x, toBowl.z);
                kittenGroup.rotation.y = THREE.MathUtils.lerp(kittenGroup.rotation.y, targetRot, 3 * dt);

                // Head bob (eating motion)
                headGroup.position.y = 1.5 + Math.sin(time * 10) * 0.1;
                headGroup.rotation.x = 0.3 + Math.sin(time * 10) * 0.1;

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 2;
                    headGroup.rotation.x = 0;
                }
            }
            else if (state === 'GROOM') {
                stateTimer -= dt;

                // Sit and groom
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.2, 3 * dt);

                // Lift paw to face
                legs[0].mesh.rotation.x = THREE.MathUtils.lerp(legs[0].mesh.rotation.x, -0.8, 3 * dt);
                legs[0].mesh.rotation.z = THREE.MathUtils.lerp(legs[0].mesh.rotation.z, 0.3, 3 * dt);

                // Head tilts to meet paw
                headGroup.rotation.z = Math.sin(time * 3) * 0.2;
                headGroup.rotation.x = 0.1;

                // Squint
                leftEye.userData.eyelid.scale.y = 0.5;
                rightEye.userData.eyelid.scale.y = 0.5;

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1;
                    legs[0].mesh.rotation.z = 0;
                    headGroup.rotation.x = 0;
                    headGroup.rotation.z = 0;
                }
            }
            else if (state === 'STRETCH') {
                stateTimer -= dt;

                const progress = 1 - (stateTimer / 2);

                if (progress < 0.5) {
                    // Front stretch
                    legs[0].mesh.rotation.x = THREE.MathUtils.lerp(0, -0.6, progress * 2);
                    legs[1].mesh.rotation.x = THREE.MathUtils.lerp(0, -0.6, progress * 2);
                    kittenGroup.rotation.x = THREE.MathUtils.lerp(0, -0.15, progress * 2);
                    headGroup.rotation.x = THREE.MathUtils.lerp(0, 0.2, progress * 2);
                } else {
                    // Back stretch
                    legs[2].mesh.rotation.x = THREE.MathUtils.lerp(0, 0.5, (progress - 0.5) * 2);
                    legs[3].mesh.rotation.x = THREE.MathUtils.lerp(0, 0.5, (progress - 0.5) * 2);
                    kittenGroup.rotation.x = THREE.MathUtils.lerp(-0.15, 0.1, (progress - 0.5) * 2);
                }

                // Big yawn
                if (progress > 0.3 && progress < 0.7) {
                    // Open mouth wide (scale muzzle)
                    muzzle.scale.y = 1.5;
                }

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1;
                    kittenGroup.rotation.x = 0;
                    headGroup.rotation.x = 0;
                    muzzle.scale.y = 0.8;
                    stats.energy = Math.min(100, stats.energy + 5);
                }
            }
            else if (state === 'SIT') {
                stateTimer -= dt;

                // Sitting pose
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.3, 3 * dt);

                // Tuck back legs
                legs[2].mesh.rotation.x = THREE.MathUtils.lerp(legs[2].mesh.rotation.x, 0.8, 3 * dt);
                legs[3].mesh.rotation.x = THREE.MathUtils.lerp(legs[3].mesh.rotation.x, 0.8, 3 * dt);

                // Front legs straight
                legs[0].mesh.rotation.x = THREE.MathUtils.lerp(legs[0].mesh.rotation.x, -0.1, 3 * dt);
                legs[1].mesh.rotation.x = THREE.MathUtils.lerp(legs[1].mesh.rotation.x, -0.1, 3 * dt);

                // Tail wraps around
                tailGroup.rotation.y = THREE.MathUtils.lerp(tailGroup.rotation.y, 0.8, 2 * dt);

                // Look around occasionally
                if (Math.sin(time * 0.5) > 0.8) {
                    headGroup.rotation.y = Math.sin(time * 2) * 0.3;
                }

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1;
                    tailGroup.rotation.y = 0;
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= dt;

                if (p.type === 'heart') {
                    p.mesh.position.y += p.speedY * dt;
                    p.mesh.position.x += p.speedX * dt;
                    p.mesh.rotation.z += p.rotSpeed * dt;
                    p.mesh.material.opacity = Math.min(1, p.life);
                }
                else if (p.type === 'zzz') {
                    p.mesh.position.y += p.speedY * dt;
                    p.mesh.position.x = p.startX + Math.sin(time * 2 + p.swayOffset) * 0.3;
                    p.mesh.scale.setScalar(0.4 + (2.5 - p.life) * 0.1);
                    p.mesh.material.opacity = Math.min(0.9, p.life * 0.5);
                }
                else if (p.type === 'note') {
                    p.mesh.position.y += p.speedY * dt;
                    p.mesh.position.x += Math.sin(time * 5 + p.startY) * dt * 0.5;
                    p.mesh.material.opacity = p.life / 1.5;
                }
                else if (p.type === 'dust') {
                    p.mesh.position.y += p.speedY * dt;
                    p.mesh.position.x += p.speedX * dt;
                    p.mesh.position.z += p.speedZ * dt;
                    p.mesh.material.opacity = p.life * 0.3;
                }
                else if (p.type === 'sparkle') {
                    p.mesh.position.y += p.speedY * dt;
                    p.mesh.rotation.y += p.rotSpeed * dt;
                    p.mesh.material.opacity = p.life * 2;
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            // Update butterflies
            butterflies.forEach(b => {
                b.phase += dt * b.speed;
                b.mesh.position.x = b.centerX + Math.cos(b.phase) * b.radius;
                b.mesh.position.z = b.centerZ + Math.sin(b.phase) * b.radius;
                b.mesh.position.y = b.baseY + Math.sin(b.phase * 3) * 0.5;

                // Wing flap
                const wingAngle = Math.sin(time * 15) * 0.8;
                b.leftWing.rotation.y = 0.3 + wingAngle;
                b.rightWing.rotation.y = -0.3 - wingAngle;

                // Face direction of movement
                b.mesh.rotation.y = b.phase + Math.PI / 2;
            });

            // Animate flowers (gentle sway)
            flowers.forEach((f, i) => {
                f.rotation.z = Math.sin(time * 0.5 + i) * 0.05;
            });

            // Toy physics
            toys.forEach(toy => {
                // Apply gravity if airborne
                if (toy.mesh.position.y > (toy.type === 'ball' ? 0.35 : 0.15)) {
                    toy.velocity.y -= 15 * dt;
                }

                // Apply velocity
                toy.mesh.position.add(toy.velocity.clone().multiplyScalar(dt));

                // Ground collision
                const groundY = toy.type === 'ball' ? 0.35 : 0.15;
                if (toy.mesh.position.y < groundY) {
                    toy.mesh.position.y = groundY;
                    toy.velocity.y *= -0.5;
                    toy.velocity.x *= 0.8;
                    toy.velocity.z *= 0.8;
                }

                // Friction
                toy.velocity.x *= 0.98;
                toy.velocity.z *= 0.98;

                // Rolling rotation for balls
                if (toy.type === 'ball') {
                    toy.mesh.rotation.x += toy.velocity.z * dt * 3;
                    toy.mesh.rotation.z -= toy.velocity.x * dt * 3;
                }

                // Kitten collision
                const dist = kittenGroup.position.distanceTo(toy.mesh.position);
                if (dist < 1.2 && state !== 'SLEEP') {
                    const pushDir = toy.mesh.position.clone().sub(kittenGroup.position).normalize();
                    const pushForce = (state === 'RUN' || state === 'POUNCE' || state === 'PLAY') ? 8 : 3;
                    toy.velocity.add(pushDir.multiplyScalar(pushForce * dt));
                }

                // Bounds
                const bound = 18;
                if (Math.abs(toy.mesh.position.x) > bound) {
                    toy.mesh.position.x = Math.sign(toy.mesh.position.x) * bound;
                    toy.velocity.x *= -0.7;
                }
                if (Math.abs(toy.mesh.position.z) > bound) {
                    toy.mesh.position.z = Math.sign(toy.mesh.position.z) * bound;
                    toy.velocity.z *= -0.7;
                }
            });

            // Constrain kitten to ground
            if (state !== 'SLEEP' && kittenGroup.position.y < 0) {
                kittenGroup.position.y = 0;
            }

            // Keep kitten in bounds
            const kittenBound = 15;
            kittenGroup.position.x = Math.max(-kittenBound, Math.min(kittenBound, kittenGroup.position.x));
            kittenGroup.position.z = Math.max(-kittenBound, Math.min(kittenBound, kittenGroup.position.z));

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
