<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Kitten Simulator - AI Designed Tiny Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f9ff; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { touch-action: none; display: block; }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        #stats-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10;
            min-width: 180px;
        }
        .stat-bar {
            height: 12px;
            background: #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
            margin: 4px 0 10px 0;
        }
        .stat-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        #tools-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .tool-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .tool-btn:hover { transform: scale(1.1); }
        .tool-btn.active { border-color: #fbbf24; box-shadow: 0 0 20px rgba(251, 191, 36, 0.6); }
        #state-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        #location-indicator {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(255,255,255,0.85);
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            color: #666;
            z-index: 10;
            max-width: 200px;
        }
        @media (max-width: 768px) {
            #ui-layer h1 { font-size: 1rem; padding: 6px 12px; }
            #stats-panel { top: auto; bottom: 90px; left: 5px; padding: 8px 10px; min-width: 120px; font-size: 10px; }
            .stat-bar { height: 8px; margin: 2px 0 6px 0; }
            #state-indicator { top: 5px; right: 5px; padding: 6px 12px; font-size: 12px; }
            #location-indicator { top: 40px; right: 5px; padding: 4px 10px; font-size: 10px; }
            #tools-panel { bottom: 10px; gap: 6px; }
            .tool-btn { width: 46px; height: 46px; font-size: 18px; border-width: 2px; }
            #instructions { display: none; }
        }
        @media (max-width: 400px) {
            .tool-btn { width: 40px; height: 40px; font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1 class="text-2xl font-bold text-gray-800 drop-shadow-md bg-white/80 px-4 py-2 rounded-full inline-block">üê± Tiny 3D Kitten Simulator</h1>
        <div class="mt-2">
            <a href="games.html" class="pointer-events-auto text-indigo-600 hover:text-indigo-800 font-bold bg-white/90 px-3 py-1 rounded-lg shadow-sm border border-indigo-100 transition-colors text-sm">
                &larr; Back to Games
            </a>
        </div>
    </div>

    <div id="stats-panel">
        <div style="font-weight: bold; margin-bottom: 10px; font-size: 16px;">üê± Whiskers</div>
        <div style="font-size: 12px; color: #666;">Happiness</div>
        <div class="stat-bar"><div id="happiness-bar" class="stat-fill" style="width: 80%; background: linear-gradient(90deg, #f472b6, #ec4899);"></div></div>
        <div style="font-size: 12px; color: #666;">Energy</div>
        <div class="stat-bar"><div id="energy-bar" class="stat-fill" style="width: 70%; background: linear-gradient(90deg, #60a5fa, #3b82f6);"></div></div>
        <div style="font-size: 12px; color: #666;">Fullness</div>
        <div class="stat-bar"><div id="fullness-bar" class="stat-fill" style="width: 60%; background: linear-gradient(90deg, #4ade80, #22c55e);"></div></div>
        <div style="font-size: 9px; color: #bbb; margin-top: 8px; text-align: right;">v2.0.0</div>
    </div>

    <div id="state-indicator">üò∫ Idle</div>
    <div id="location-indicator">üìç Living Room</div>

    <div id="tools-panel">
        <button class="tool-btn active" id="pet-tool" style="background: linear-gradient(135deg, #fda4af, #fb7185);" title="Pet">‚úã</button>
        <button class="tool-btn" id="laser-tool" style="background: linear-gradient(135deg, #f87171, #ef4444);" title="Laser Pointer">üî¥</button>
        <button class="tool-btn" id="treat-tool" style="background: linear-gradient(135deg, #a78bfa, #8b5cf6);" title="Give Treat">üçñ</button>
        <button class="tool-btn" id="yarn-tool" style="background: linear-gradient(135deg, #60a5fa, #3b82f6);" title="Throw Yarn">üß∂</button>
        <button class="tool-btn" id="catnip-tool" style="background: linear-gradient(135deg, #4ade80, #22c55e);" title="Catnip">üåø</button>
        <button class="tool-btn active" id="follow-tool" style="background: linear-gradient(135deg, #fbbf24, #f59e0b);" title="Camera Follow: ON">üëÅÔ∏è</button>
    </div>

    <div id="instructions">
        <strong>Controls:</strong><br>
        ‚Ä¢ Click kitten to pet<br>
        ‚Ä¢ Drag to orbit camera<br>
        ‚Ä¢ Scroll to zoom<br>
        ‚Ä¢ üì∑ = Toggle follow
    </div>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f9ff);
        // No fog - clearer view of the world

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 14);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        // --- GLOBAL WORLD BOUNDS (for expansion) ---
        const WORLD_BOUNDS = {
            minX: -30,
            maxX: 55,
            minZ: -15,
            maxZ: 55
        };

        // --- CAMERA CONTROLS ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = 0;
        let cameraHeight = 8;
        let cameraDistance = 14;
        let cameraFollowEnabled = true; // Toggle for camera follow
        let freeCamPosition = new THREE.Vector3(0, 8, 14); // Saved camera position for free mode
        let freeCamLookAngle = 0; // Horizontal look angle for free camera
        let freeCamPitch = -0.3; // Vertical look angle for free camera

        // --- STATS SYSTEM ---
        const stats = {
            happiness: 80,
            energy: 70,
            fullness: 60
        };

        function updateStatsUI() {
            document.getElementById('happiness-bar').style.width = stats.happiness + '%';
            document.getElementById('energy-bar').style.width = stats.energy + '%';
            document.getElementById('fullness-bar').style.width = stats.fullness + '%';
        }

        // --- TOOL STATE ---
        let currentTool = 'pet';
        let laserActive = false;

        // Laser dot
        const laserDot = new THREE.Mesh(
            new THREE.CircleGeometry(0.15, 16),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        laserDot.rotation.x = -Math.PI / 2;
        laserDot.position.y = 0.02;
        laserDot.visible = false;
        scene.add(laserDot);

        // Tool button event listeners
        document.getElementById('pet-tool').addEventListener('click', () => selectTool('pet'));
        document.getElementById('laser-tool').addEventListener('click', () => selectTool('laser'));
        document.getElementById('treat-tool').addEventListener('click', () => selectTool('treat'));
        document.getElementById('yarn-tool').addEventListener('click', () => selectTool('yarn'));
        document.getElementById('catnip-tool').addEventListener('click', () => selectTool('catnip'));
        document.getElementById('follow-tool').addEventListener('click', toggleCameraFollow);

        function selectTool(tool) {
            currentTool = tool;
            // Only toggle active on non-follow tool buttons
            document.querySelectorAll('.tool-btn:not(#follow-tool)').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + '-tool').classList.add('active');
            if (tool !== 'laser') {
                laserDot.visible = false;
                laserActive = false;
            }
        }

        function toggleCameraFollow() {
            cameraFollowEnabled = !cameraFollowEnabled;
            const followBtn = document.getElementById('follow-tool');
            if (cameraFollowEnabled) {
                // When re-enabling follow, sync cameraAngle to current view
                const dx = kittenGroup.position.x - camera.position.x;
                const dz = kittenGroup.position.z - camera.position.z;
                cameraAngle = Math.atan2(-dx, -dz);
                cameraDistance = Math.sqrt(dx * dx + dz * dz);
                cameraHeight = camera.position.y;
                followBtn.classList.add('active');
                followBtn.title = 'Camera Follow: ON';
                followBtn.textContent = 'üëÅÔ∏è';
            } else {
                // Save current camera state for free mode - preserve exact view
                freeCamPosition.copy(camera.position);
                // Calculate look direction from camera to where it was looking (the cat)
                const lookDir = new THREE.Vector3();
                lookDir.subVectors(kittenGroup.position, camera.position);
                freeCamLookAngle = Math.atan2(lookDir.x, -lookDir.z);
                freeCamPitch = Math.atan2(lookDir.y - 1, Math.sqrt(lookDir.x * lookDir.x + lookDir.z * lookDir.z)) * -1;
                followBtn.classList.remove('active');
                followBtn.title = 'Camera Follow: OFF (free look)';
                followBtn.textContent = 'üîì';
            }
        }

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // --- LOCATION SYSTEM ---
        const locations = {};
        let currentLocation = 'livingRoom';
        const locationBounds = {
            livingRoom: { minX: -8, maxX: 8, minZ: -6, maxZ: 8 },
            bedroom: { minX: -25, maxX: -12, minZ: -6, maxZ: 8 },
            kitchen: { minX: 12, maxX: 25, minZ: -6, maxZ: 8 },
            lawn: { minX: -10, maxX: 10, minZ: 10, maxZ: 30 }
        };

        // Materials for environment
        const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
        const fabricMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.9 });
        const carpetMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.95 });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFF8DC, roughness: 0.9 });
        const tileMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.7 });

        // --- ENVIRONMENT: MAIN FLOOR ---
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x90e0ef });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // === LIVING ROOM (Central Hub) ===
        const livingRoom = new THREE.Group();
        livingRoom.position.set(0, 0, 0);
        scene.add(livingRoom);
        locations.livingRoom = livingRoom;

        // Living room floor (carpet)
        const livingFloorGeo = new THREE.PlaneGeometry(16, 14);
        const livingFloor = new THREE.Mesh(livingFloorGeo, carpetMaterial);
        livingFloor.rotation.x = -Math.PI / 2;
        livingFloor.position.set(0, 0.01, 1);
        livingFloor.receiveShadow = true;
        livingRoom.add(livingFloor);

        // Couch
        const couchGroup = new THREE.Group();
        couchGroup.position.set(0, 0, -4);
        livingRoom.add(couchGroup);

        // Couch base
        const couchBaseGeo = new THREE.BoxGeometry(4, 0.8, 1.5);
        const couchBase = new THREE.Mesh(couchBaseGeo, fabricMaterial);
        couchBase.position.y = 0.4;
        couchBase.castShadow = true;
        couchBase.receiveShadow = true;
        couchGroup.add(couchBase);

        // Couch back
        const couchBackGeo = new THREE.BoxGeometry(4, 1.2, 0.4);
        const couchBack = new THREE.Mesh(couchBackGeo, fabricMaterial);
        couchBack.position.set(0, 1.0, -0.55);
        couchBack.castShadow = true;
        couchGroup.add(couchBack);

        // Couch arm rests
        const armGeo = new THREE.BoxGeometry(0.4, 0.9, 1.5);
        const leftArm = new THREE.Mesh(armGeo, fabricMaterial);
        leftArm.position.set(-2.0, 0.65, 0);
        leftArm.castShadow = true;
        couchGroup.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, fabricMaterial);
        rightArm.position.set(2.0, 0.65, 0);
        rightArm.castShadow = true;
        couchGroup.add(rightArm);

        // Couch cushions
        const cushionGeo = new THREE.BoxGeometry(1.2, 0.25, 1.0);
        const cushionMat = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.85 });
        for (let i = -1; i <= 1; i++) {
            const cushion = new THREE.Mesh(cushionGeo, cushionMat);
            cushion.position.set(i * 1.3, 0.92, 0.1);
            cushion.castShadow = true;
            couchGroup.add(cushion);
        }

        // Coffee table
        const coffeeTableGroup = new THREE.Group();
        coffeeTableGroup.position.set(0, 0, -1.5);
        livingRoom.add(coffeeTableGroup);

        const tableTopGeo = new THREE.BoxGeometry(2.0, 0.1, 1.0);
        const tableTop = new THREE.Mesh(tableTopGeo, woodMaterial);
        tableTop.position.y = 0.5;
        tableTop.castShadow = true;
        tableTop.receiveShadow = true;
        coffeeTableGroup.add(tableTop);

        const tableLegGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
        const legPositions = [[-0.8, -0.4], [0.8, -0.4], [-0.8, 0.4], [0.8, 0.4]];
        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(tableLegGeo, woodMaterial);
            leg.position.set(pos[0], 0.25, pos[1]);
            leg.castShadow = true;
            coffeeTableGroup.add(leg);
        });

        // Rug under coffee table
        const rugGeo = new THREE.PlaneGeometry(4, 3);
        const rugMat = new THREE.MeshStandardMaterial({ color: 0xCD853F, roughness: 0.95 });
        const rug = new THREE.Mesh(rugGeo, rugMat);
        rug.rotation.x = -Math.PI / 2;
        rug.position.set(0, 0.02, -2.5);
        rug.receiveShadow = true;
        livingRoom.add(rug);

        // Fireplace
        const fireplaceGroup = new THREE.Group();
        fireplaceGroup.position.set(-6, 0, 0);
        livingRoom.add(fireplaceGroup);

        // Fireplace structure
        const fireplaceBaseGeo = new THREE.BoxGeometry(2.5, 2.0, 1.0);
        const fireplaceBase = new THREE.Mesh(fireplaceBaseGeo, new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.9 }));
        fireplaceBase.position.y = 1.0;
        fireplaceBase.castShadow = true;
        fireplaceGroup.add(fireplaceBase);

        // Fireplace opening
        const openingGeo = new THREE.BoxGeometry(1.5, 1.2, 0.5);
        const openingMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const opening = new THREE.Mesh(openingGeo, openingMat);
        opening.position.set(0, 0.7, 0.3);
        fireplaceGroup.add(opening);

        // Mantle
        const mantleGeo = new THREE.BoxGeometry(3.0, 0.15, 0.5);
        const mantle = new THREE.Mesh(mantleGeo, woodMaterial);
        mantle.position.set(0, 2.1, 0.25);
        mantle.castShadow = true;
        fireplaceGroup.add(mantle);

        // Fire glow (point light)
        const fireLight = new THREE.PointLight(0xff6600, 0.5, 5);
        fireLight.position.set(-6, 0.8, 0.5);
        livingRoom.add(fireLight);

        // Fire particles (simple animated flames)
        const fireParticles = [];
        const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
        for (let i = 0; i < 5; i++) {
            const fireGeo = new THREE.ConeGeometry(0.1, 0.4, 8);
            const flame = new THREE.Mesh(fireGeo, fireMat);
            flame.position.set(-6 + (Math.random() - 0.5) * 0.8, 0.5, 0.3);
            livingRoom.add(flame);
            fireParticles.push({ mesh: flame, offset: Math.random() * Math.PI * 2 });
        }

        // (Window removed - was causing floating frame issue when walls fade)

        // === BEDROOM ===
        const bedroom = new THREE.Group();
        bedroom.position.set(-18, 0, 0);
        scene.add(bedroom);
        locations.bedroom = bedroom;

        // Bedroom floor
        const bedroomFloorGeo = new THREE.PlaneGeometry(12, 14);
        const bedroomFloor = new THREE.Mesh(bedroomFloorGeo, carpetMaterial);
        bedroomFloor.rotation.x = -Math.PI / 2;
        bedroomFloor.position.y = 0.01;
        bedroomFloor.receiveShadow = true;
        bedroom.add(bedroomFloor);

        // Bed
        const bedGroup = new THREE.Group();
        bedGroup.position.set(0, 0, -3);
        bedroom.add(bedGroup);

        // Bed frame
        const bedFrameGeo = new THREE.BoxGeometry(3.5, 0.4, 4.5);
        const bedFrame = new THREE.Mesh(bedFrameGeo, woodMaterial);
        bedFrame.position.y = 0.2;
        bedFrame.castShadow = true;
        bedGroup.add(bedFrame);

        // Mattress
        const mattressGeo = new THREE.BoxGeometry(3.3, 0.4, 4.3);
        const mattressMat = new THREE.MeshStandardMaterial({ color: 0xFFF5EE, roughness: 0.9 });
        const mattress = new THREE.Mesh(mattressGeo, mattressMat);
        mattress.position.y = 0.6;
        mattress.castShadow = true;
        bedGroup.add(mattress);

        // Pillow
        const pillowGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
        const pillowMat = new THREE.MeshStandardMaterial({ color: 0xFFFAFA, roughness: 0.85 });
        const pillow = new THREE.Mesh(pillowGeo, pillowMat);
        pillow.position.set(0, 0.95, -1.6);
        pillow.castShadow = true;
        bedGroup.add(pillow);

        // Blanket
        const blanketGeo = new THREE.BoxGeometry(3.2, 0.15, 3.0);
        const blanketMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.9 });
        const blanket = new THREE.Mesh(blanketGeo, blanketMat);
        blanket.position.set(0, 0.88, 0.3);
        blanket.castShadow = true;
        bedGroup.add(blanket);

        // Headboard
        const headboardGeo = new THREE.BoxGeometry(3.5, 1.5, 0.2);
        const headboard = new THREE.Mesh(headboardGeo, woodMaterial);
        headboard.position.set(0, 1.15, -2.15);
        headboard.castShadow = true;
        bedGroup.add(headboard);

        // Under-bed space (kitten can hide here)
        const underBedGeo = new THREE.BoxGeometry(3.3, 0.3, 4.3);
        const underBedMat = new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0.7 });
        const underBed = new THREE.Mesh(underBedGeo, underBedMat);
        underBed.position.set(0, 0.05, 0);
        bedGroup.add(underBed);

        // Nightstand
        const nightstandGeo = new THREE.BoxGeometry(0.8, 0.7, 0.6);
        const nightstand = new THREE.Mesh(nightstandGeo, woodMaterial);
        nightstand.position.set(2.3, 0.35, -3.5);
        nightstand.castShadow = true;
        bedroom.add(nightstand);

        // Lamp on nightstand
        const lampBaseGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.2, 12);
        const lampBase = new THREE.Mesh(lampBaseGeo, new THREE.MeshStandardMaterial({ color: 0xDAA520 }));
        lampBase.position.set(2.3, 0.8, -3.5);
        bedroom.add(lampBase);

        const lampShadeGeo = new THREE.ConeGeometry(0.25, 0.3, 12);
        const lampShadeMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC, emissive: 0x332200, emissiveIntensity: 0.3 });
        const lampShade = new THREE.Mesh(lampShadeGeo, lampShadeMat);
        lampShade.position.set(2.3, 1.1, -3.5);
        lampShade.rotation.x = Math.PI;
        bedroom.add(lampShade);

        // Laundry basket
        const basketGeo = new THREE.CylinderGeometry(0.5, 0.4, 0.8, 12, 1, true);
        const basketMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.9, side: THREE.DoubleSide });
        const basket = new THREE.Mesh(basketGeo, basketMat);
        basket.position.set(-2, 0.4, 2);
        basket.castShadow = true;
        bedroom.add(basket);

        // === KITCHEN ===
        const kitchen = new THREE.Group();
        kitchen.position.set(18, 0, 0);
        scene.add(kitchen);
        locations.kitchen = kitchen;

        // Kitchen floor (tiles)
        const kitchenFloorGeo = new THREE.PlaneGeometry(12, 14);
        const kitchenFloor = new THREE.Mesh(kitchenFloorGeo, tileMaterial);
        kitchenFloor.rotation.x = -Math.PI / 2;
        kitchenFloor.position.y = 0.01;
        kitchenFloor.receiveShadow = true;
        kitchen.add(kitchenFloor);

        // Kitchen counter
        const counterGeo = new THREE.BoxGeometry(5, 1.2, 0.8);
        const counterMat = new THREE.MeshStandardMaterial({ color: 0xE8E8E8, roughness: 0.3 });
        const counter = new THREE.Mesh(counterGeo, counterMat);
        counter.position.set(0, 0.6, -4);
        counter.castShadow = true;
        kitchen.add(counter);

        // Counter cabinets
        const cabinetGeo = new THREE.BoxGeometry(5, 1.1, 0.75);
        const cabinet = new THREE.Mesh(cabinetGeo, woodMaterial);
        cabinet.position.set(0, 0.55, -4);
        cabinet.castShadow = true;
        kitchen.add(cabinet);

        // Food bowl
        const foodBowlGeo = new THREE.CylinderGeometry(0.25, 0.2, 0.12, 16);
        const foodBowlMat = new THREE.MeshStandardMaterial({ color: 0xFF6347, roughness: 0.5 });
        const foodBowl = new THREE.Mesh(foodBowlGeo, foodBowlMat);
        foodBowl.position.set(-2, 0.06, 2);
        foodBowl.castShadow = true;
        kitchen.add(foodBowl);

        // Food in bowl
        const foodGeo = new THREE.CylinderGeometry(0.2, 0.18, 0.08, 16);
        const foodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
        const food = new THREE.Mesh(foodGeo, foodMat);
        food.position.set(-2, 0.1, 2);
        kitchen.add(food);

        // Water bowl
        const waterBowlGeo = new THREE.CylinderGeometry(0.25, 0.2, 0.12, 16);
        const waterBowlMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.5 });
        const waterBowl = new THREE.Mesh(waterBowlGeo, waterBowlMat);
        waterBowl.position.set(-1.2, 0.06, 2);
        waterBowl.castShadow = true;
        kitchen.add(waterBowl);

        // Water in bowl
        const waterGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.02, 16);
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, roughness: 0.1, transparent: true, opacity: 0.7 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.set(-1.2, 0.1, 2);
        kitchen.add(water);

        // Refrigerator
        const fridgeGeo = new THREE.BoxGeometry(1.2, 2.5, 1.0);
        const fridgeMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.3 });
        const fridge = new THREE.Mesh(fridgeGeo, fridgeMat);
        fridge.position.set(3, 1.25, -3);
        fridge.castShadow = true;
        kitchen.add(fridge);

        // Sunny windowsill
        const windowsillGeo = new THREE.BoxGeometry(2.5, 0.15, 0.6);
        const windowsill = new THREE.Mesh(windowsillGeo, woodMaterial);
        windowsill.position.set(0, 1.3, 5);
        windowsill.castShadow = true;
        kitchen.add(windowsill);

        // Kitchen window
        const kitchenWindowGeo = new THREE.BoxGeometry(2.5, 1.8, 0.1);
        const windowGlassMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.3 });
        const kitchenWindow = new THREE.Mesh(kitchenWindowGeo, windowGlassMat);
        kitchenWindow.position.set(0, 2.3, 5.05);
        kitchen.add(kitchenWindow);

        // Walls between rooms (fade when camera/kitten is near)
        const fadingWalls = [];
        const fadingWallMat = new THREE.MeshStandardMaterial({
            color: 0xFFF8DC,
            roughness: 0.9,
            transparent: true,
            opacity: 1.0
        });

        const wallGeo = new THREE.BoxGeometry(0.3, 3.5, 14);
        const leftWall = new THREE.Mesh(wallGeo, fadingWallMat.clone());
        leftWall.position.set(-8.5, 1.75, 1);
        leftWall.castShadow = true;
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        fadingWalls.push(leftWall);

        const rightWall = new THREE.Mesh(wallGeo, fadingWallMat.clone());
        rightWall.position.set(8.5, 1.75, 1);
        rightWall.castShadow = true;
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        fadingWalls.push(rightWall);

        // Back wall (behind couch - living room)
        const backWallGeo = new THREE.BoxGeometry(17, 3.5, 0.3);
        const backWall = new THREE.Mesh(backWallGeo, fadingWallMat.clone());
        backWall.position.set(0, 1.75, -6);
        backWall.castShadow = true;
        backWall.receiveShadow = true;
        scene.add(backWall);
        fadingWalls.push(backWall);

        // Front wall with window (between living room and outdoor)
        const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry(5.5, 3.5, 0.3), fadingWallMat.clone());
        frontWallLeft.position.set(-5.75, 1.75, 7);
        frontWallLeft.castShadow = true;
        scene.add(frontWallLeft);
        fadingWalls.push(frontWallLeft);

        const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry(5.5, 3.5, 0.3), fadingWallMat.clone());
        frontWallRight.position.set(5.75, 1.75, 7);
        frontWallRight.castShadow = true;
        scene.add(frontWallRight);
        fadingWalls.push(frontWallRight);

        const frontWallTop = new THREE.Mesh(new THREE.BoxGeometry(6, 1.0, 0.3), fadingWallMat.clone());
        frontWallTop.position.set(0, 3.0, 7);
        frontWallTop.castShadow = true;
        scene.add(frontWallTop);
        fadingWalls.push(frontWallTop);

        // Bedroom walls
        const bedroomBackWall = new THREE.Mesh(new THREE.BoxGeometry(14, 3.5, 0.3), fadingWallMat.clone());
        bedroomBackWall.position.set(-18, 1.75, -6);
        bedroomBackWall.castShadow = true;
        scene.add(bedroomBackWall);
        fadingWalls.push(bedroomBackWall);

        const bedroomLeftWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, 3.5, 14), fadingWallMat.clone());
        bedroomLeftWall.position.set(-25, 1.75, 1);
        bedroomLeftWall.castShadow = true;
        scene.add(bedroomLeftWall);
        fadingWalls.push(bedroomLeftWall);

        // Kitchen walls
        const kitchenBackWall = new THREE.Mesh(new THREE.BoxGeometry(14, 3.5, 0.3), fadingWallMat.clone());
        kitchenBackWall.position.set(18, 1.75, -6);
        kitchenBackWall.castShadow = true;
        scene.add(kitchenBackWall);
        fadingWalls.push(kitchenBackWall);

        const kitchenRightWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, 3.5, 14), fadingWallMat.clone());
        kitchenRightWall.position.set(25, 1.75, 1);
        kitchenRightWall.castShadow = true;
        scene.add(kitchenRightWall);
        fadingWalls.push(kitchenRightWall);

        // Front wall of bedroom (facing outdoor)
        const bedroomFrontWall = new THREE.Mesh(new THREE.BoxGeometry(14, 3.5, 0.3), fadingWallMat.clone());
        bedroomFrontWall.position.set(-18, 1.75, 7);
        bedroomFrontWall.castShadow = true;
        scene.add(bedroomFrontWall);
        fadingWalls.push(bedroomFrontWall);

        // Front wall of kitchen (facing outdoor)
        const kitchenFrontWall = new THREE.Mesh(new THREE.BoxGeometry(14, 3.5, 0.3), fadingWallMat.clone());
        kitchenFrontWall.position.set(18, 1.75, 7);
        kitchenFrontWall.castShadow = true;
        scene.add(kitchenFrontWall);
        fadingWalls.push(kitchenFrontWall);

        // Doorways
        const doorwayGeo = new THREE.BoxGeometry(0.3, 2.5, 2.5);
        const doorwayMat = new THREE.MeshBasicMaterial({ visible: false });
        const leftDoorway = new THREE.Mesh(doorwayGeo, doorwayMat);
        leftDoorway.position.set(-8.5, 1.25, 0);
        scene.add(leftDoorway);

        const rightDoorway = new THREE.Mesh(doorwayGeo, doorwayMat);
        rightDoorway.position.set(8.5, 1.25, 0);
        scene.add(rightDoorway);

        // === ROOFS (with fading) ===
        const roofHeight = 3.5;

        // Living room roof - warm wood color with exposed beams
        const livingRoofMat = new THREE.MeshStandardMaterial({
            color: 0xD2691E, // Chocolate brown
            roughness: 0.8,
            transparent: true,
            opacity: 1.0
        });
        const livingRoof = new THREE.Mesh(new THREE.BoxGeometry(17, 0.2, 14), livingRoofMat);
        livingRoof.position.set(0, roofHeight, 1);
        livingRoof.receiveShadow = true;
        scene.add(livingRoof);
        fadingWalls.push(livingRoof);

        // Living room ceiling beams (decorative)
        const beamMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 1.0 });
        for (let i = -2; i <= 2; i++) {
            const beam = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 14), beamMat.clone());
            beam.position.set(i * 3.5, roofHeight - 0.1, 1);
            scene.add(beam);
            fadingWalls.push(beam);
        }

        // Bedroom roof - cozy blue-gray
        const bedroomRoofMat = new THREE.MeshStandardMaterial({
            color: 0x708090, // Slate gray
            roughness: 0.85,
            transparent: true,
            opacity: 1.0
        });
        const bedroomRoof = new THREE.Mesh(new THREE.BoxGeometry(14, 0.2, 14), bedroomRoofMat);
        bedroomRoof.position.set(-18, roofHeight, 1);
        bedroomRoof.receiveShadow = true;
        scene.add(bedroomRoof);
        fadingWalls.push(bedroomRoof);

        // Kitchen roof - clean white with skylight
        const kitchenRoofMat = new THREE.MeshStandardMaterial({
            color: 0xFFFAF0, // Floral white
            roughness: 0.9,
            transparent: true,
            opacity: 1.0
        });
        const kitchenRoof = new THREE.Mesh(new THREE.BoxGeometry(14, 0.2, 14), kitchenRoofMat);
        kitchenRoof.position.set(18, roofHeight, 1);
        kitchenRoof.receiveShadow = true;
        scene.add(kitchenRoof);
        fadingWalls.push(kitchenRoof);

        // Kitchen skylight (glass panel in roof)
        const skylightMat = new THREE.MeshStandardMaterial({
            color: 0x87CEEB,
            transparent: true,
            opacity: 0.4,
            roughness: 0.1
        });
        const skylight = new THREE.Mesh(new THREE.BoxGeometry(3, 0.25, 3), skylightMat);
        skylight.position.set(18, roofHeight + 0.05, 2);
        scene.add(skylight);
        fadingWalls.push(skylight);

        // === OUTDOOR: LAWN (Enhanced) ===
        const lawn = new THREE.Group();
        lawn.position.set(0, 0, 20);
        scene.add(lawn);
        locations.lawn = lawn;

        // Grass material
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x7CCD7C, roughness: 0.9 });

        // Lawn floor
        const lawnFloorGeo = new THREE.PlaneGeometry(30, 25);
        const lawnFloor = new THREE.Mesh(lawnFloorGeo, grassMat);
        lawnFloor.rotation.x = -Math.PI / 2;
        lawnFloor.position.y = 0.01;
        lawnFloor.receiveShadow = true;
        lawn.add(lawnFloor);

        // Grass tufts (instanced for performance)
        const grassTuftGeo = new THREE.ConeGeometry(0.05, 0.2, 4);
        const grassTuftMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 });
        for (let i = 0; i < 200; i++) {
            const tuft = new THREE.Mesh(grassTuftGeo, grassTuftMat);
            tuft.position.set(
                (Math.random() - 0.5) * 28,
                0.1,
                (Math.random() - 0.5) * 23
            );
            tuft.rotation.y = Math.random() * Math.PI;
            lawn.add(tuft);
        }

        // Garden path (stepping stones)
        const stoneGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.08, 8);
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8 });
        for (let i = 0; i < 6; i++) {
            const stone = new THREE.Mesh(stoneGeo, stoneMat);
            stone.position.set(Math.sin(i * 0.3) * 0.3, 0.02, -10 + i * 2);
            stone.receiveShadow = true;
            lawn.add(stone);
        }

        // Bird bath
        const birdbathGroup = new THREE.Group();
        birdbathGroup.position.set(5, 0, -5);
        lawn.add(birdbathGroup);

        const birdbathPedestalGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.0, 12);
        const birdbathPedestal = new THREE.Mesh(birdbathPedestalGeo, stoneMat);
        birdbathPedestal.position.y = 0.5;
        birdbathGroup.add(birdbathPedestal);

        const birdbathBasinGeo = new THREE.CylinderGeometry(0.6, 0.5, 0.15, 16);
        const birdbathBasin = new THREE.Mesh(birdbathBasinGeo, stoneMat);
        birdbathBasin.position.y = 1.05;
        birdbathBasin.castShadow = true;
        birdbathGroup.add(birdbathBasin);

        const birdbathWaterGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 16);
        const birdbathWater = new THREE.Mesh(birdbathWaterGeo, waterMat);
        birdbathWater.position.y = 1.1;
        birdbathGroup.add(birdbathWater);

        // === GARDEN ZONE ===
        const garden = new THREE.Group();
        garden.position.set(0, 0, 35);
        scene.add(garden);
        locations.garden = garden;

        // Garden floor
        const gardenFloorGeo = new THREE.PlaneGeometry(20, 15);
        const gardenFloor = new THREE.Mesh(gardenFloorGeo, grassMat);
        gardenFloor.rotation.x = -Math.PI / 2;
        gardenFloor.position.y = 0.01;
        gardenFloor.receiveShadow = true;
        garden.add(gardenFloor);

        // Flower beds with flowers
        const flowerColors = [0xFF69B4, 0xFFFF00, 0xFF4500, 0x9370DB, 0xFFFFFF];
        function createFlower(x, z, color) {
            const flowerGroup = new THREE.Group();
            flowerGroup.position.set(x, 0, z);

            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.2;
            flowerGroup.add(stem);

            // Petals
            const petalGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const petalMat = new THREE.MeshStandardMaterial({ color: color });
            for (let i = 0; i < 5; i++) {
                const petal = new THREE.Mesh(petalGeo, petalMat);
                const angle = (i / 5) * Math.PI * 2;
                petal.position.set(Math.cos(angle) * 0.08, 0.42, Math.sin(angle) * 0.08);
                flowerGroup.add(petal);
            }

            // Center
            const centerGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const centerMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const center = new THREE.Mesh(centerGeo, centerMat);
            center.position.y = 0.42;
            flowerGroup.add(center);

            return flowerGroup;
        }

        // Create flower beds
        for (let x = -6; x <= 6; x += 1.5) {
            for (let z = -5; z <= -3; z += 1) {
                const flower = createFlower(x + Math.random() * 0.5, z + Math.random() * 0.5, flowerColors[Math.floor(Math.random() * flowerColors.length)]);
                garden.add(flower);
            }
        }

        // Tall grass patches
        const tallGrassMat = new THREE.MeshStandardMaterial({ color: 0x3CB371, roughness: 0.9 });
        for (let i = 0; i < 30; i++) {
            const grassBlade = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.5, 0.01), tallGrassMat);
            grassBlade.position.set(
                -8 + Math.random() * 3,
                0.25,
                Math.random() * 10 - 5
            );
            grassBlade.rotation.y = Math.random() * Math.PI;
            grassBlade.rotation.x = (Math.random() - 0.5) * 0.3;
            garden.add(grassBlade);
        }

        // Bird feeder
        const birdFeederGroup = new THREE.Group();
        birdFeederGroup.position.set(7, 0, 0);
        garden.add(birdFeederGroup);

        const feederPoleGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
        const feederPole = new THREE.Mesh(feederPoleGeo, woodMaterial);
        feederPole.position.y = 1;
        birdFeederGroup.add(feederPole);

        const feederHouseGeo = new THREE.BoxGeometry(0.5, 0.4, 0.5);
        const feederHouse = new THREE.Mesh(feederHouseGeo, woodMaterial);
        feederHouse.position.y = 2.1;
        feederHouse.castShadow = true;
        birdFeederGroup.add(feederHouse);

        const feederRoofGeo = new THREE.ConeGeometry(0.45, 0.3, 4);
        const feederRoof = new THREE.Mesh(feederRoofGeo, new THREE.MeshStandardMaterial({ color: 0x8B0000 }));
        feederRoof.position.y = 2.45;
        feederRoof.rotation.y = Math.PI / 4;
        birdFeederGroup.add(feederRoof);

        // Garden fence
        const fenceMat = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.8 });
        for (let x = -10; x <= 10; x += 2) {
            const post = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.1), fenceMat);
            post.position.set(x, 0.4, 7);
            post.castShadow = true;
            garden.add(post);
        }
        const fenceRailGeo = new THREE.BoxGeometry(20, 0.08, 0.05);
        const fenceRail = new THREE.Mesh(fenceRailGeo, fenceMat);
        fenceRail.position.set(0, 0.6, 7);
        garden.add(fenceRail);

        // === PATIO ===
        const patio = new THREE.Group();
        patio.position.set(12, 0, 25);
        scene.add(patio);
        locations.patio = patio;

        // Patio floor (stone tiles)
        const patioFloorGeo = new THREE.PlaneGeometry(8, 8);
        const patioFloorMat = new THREE.MeshStandardMaterial({ color: 0xA0A0A0, roughness: 0.7 });
        const patioFloor = new THREE.Mesh(patioFloorGeo, patioFloorMat);
        patioFloor.rotation.x = -Math.PI / 2;
        patioFloor.position.y = 0.02;
        patioFloor.receiveShadow = true;
        patio.add(patioFloor);

        // Patio table
        const patioTableGroup = new THREE.Group();
        patioTableGroup.position.set(0, 0, 0);
        patio.add(patioTableGroup);

        const patioTableTopGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.08, 16);
        const patioTableTop = new THREE.Mesh(patioTableTopGeo, new THREE.MeshStandardMaterial({ color: 0xF5F5F5 }));
        patioTableTop.position.y = 0.9;
        patioTableTop.castShadow = true;
        patioTableGroup.add(patioTableTop);

        const patioTableLegGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.85, 8);
        const patioTableLeg = new THREE.Mesh(patioTableLegGeo, new THREE.MeshStandardMaterial({ color: 0x404040 }));
        patioTableLeg.position.y = 0.425;
        patioTableGroup.add(patioTableLeg);

        // Patio umbrella
        const umbrellaGroup = new THREE.Group();
        umbrellaGroup.position.set(0, 0, 0);
        patio.add(umbrellaGroup);

        const umbrellaPoleGeo = new THREE.CylinderGeometry(0.04, 0.04, 2.5, 8);
        const umbrellaPole = new THREE.Mesh(umbrellaPoleGeo, new THREE.MeshStandardMaterial({ color: 0x404040 }));
        umbrellaPole.position.y = 1.25;
        umbrellaGroup.add(umbrellaPole);

        const umbrellaCanopyGeo = new THREE.ConeGeometry(1.5, 0.5, 8, 1, true);
        const umbrellaCanopyMat = new THREE.MeshStandardMaterial({ color: 0xFF6347, side: THREE.DoubleSide });
        const umbrellaCanopy = new THREE.Mesh(umbrellaCanopyGeo, umbrellaCanopyMat);
        umbrellaCanopy.position.y = 2.5;
        umbrellaCanopy.rotation.x = Math.PI;
        umbrellaCanopy.castShadow = true;
        umbrellaGroup.add(umbrellaCanopy);

        // Patio chairs
        function createPatioChair(x, z, rotY) {
            const chairGroup = new THREE.Group();
            chairGroup.position.set(x, 0, z);
            chairGroup.rotation.y = rotY;

            const seatGeo = new THREE.BoxGeometry(0.6, 0.08, 0.6);
            const seat = new THREE.Mesh(seatGeo, new THREE.MeshStandardMaterial({ color: 0xF5F5F5 }));
            seat.position.y = 0.5;
            chairGroup.add(seat);

            const backGeo = new THREE.BoxGeometry(0.6, 0.7, 0.08);
            const back = new THREE.Mesh(backGeo, new THREE.MeshStandardMaterial({ color: 0xF5F5F5 }));
            back.position.set(0, 0.85, -0.26);
            chairGroup.add(back);

            return chairGroup;
        }

        patio.add(createPatioChair(1.2, 0, Math.PI / 2));
        patio.add(createPatioChair(-1.2, 0, -Math.PI / 2));

        // === POND ===
        const pond = new THREE.Group();
        pond.position.set(-10, 0, 30);
        scene.add(pond);
        locations.pond = pond;

        // Pond water
        const pondGeo = new THREE.CircleGeometry(4, 32);
        const pondMat = new THREE.MeshStandardMaterial({
            color: 0x4682B4,
            roughness: 0.1,
            transparent: true,
            opacity: 0.8
        });
        const pondWater = new THREE.Mesh(pondGeo, pondMat);
        pondWater.rotation.x = -Math.PI / 2;
        pondWater.position.y = 0.05;
        pond.add(pondWater);

        // Pond edge rocks
        const rockGeo = new THREE.DodecahedronGeometry(0.3, 0);
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
        for (let i = 0; i < 16; i++) {
            const rock = new THREE.Mesh(rockGeo, rockMat);
            const angle = (i / 16) * Math.PI * 2;
            rock.position.set(Math.cos(angle) * 4.2, 0.15, Math.sin(angle) * 4.2);
            rock.scale.set(0.8 + Math.random() * 0.4, 0.5 + Math.random() * 0.3, 0.8 + Math.random() * 0.4);
            rock.rotation.y = Math.random() * Math.PI;
            rock.castShadow = true;
            pond.add(rock);
        }

        // Lily pads
        const lilyPadGeo = new THREE.CircleGeometry(0.3, 12);
        const lilyPadMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
        const lilyPads = [];
        for (let i = 0; i < 5; i++) {
            const lilyPad = new THREE.Mesh(lilyPadGeo, lilyPadMat);
            lilyPad.rotation.x = -Math.PI / 2;
            lilyPad.position.set(
                (Math.random() - 0.5) * 5,
                0.08,
                (Math.random() - 0.5) * 5
            );
            pond.add(lilyPad);
            lilyPads.push(lilyPad);
        }

        // Simple fish (orange koi)
        const fishGroup = new THREE.Group();
        fishGroup.position.y = 0.02;
        pond.add(fishGroup);

        const fishBodyGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const fishMat = new THREE.MeshStandardMaterial({ color: 0xFF8C00 });
        const fishBody = new THREE.Mesh(fishBodyGeo, fishMat);
        fishBody.scale.set(1.5, 0.6, 1);
        fishGroup.add(fishBody);

        const fishTailGeo = new THREE.ConeGeometry(0.1, 0.2, 4);
        const fishTail = new THREE.Mesh(fishTailGeo, fishMat);
        fishTail.position.set(-0.25, 0, 0);
        fishTail.rotation.z = Math.PI / 2;
        fishGroup.add(fishTail);

        // Update location bounds for outdoor areas
        locationBounds.lawn = { minX: -12, maxX: 12, minZ: 10, maxZ: 32 };
        locationBounds.garden = { minX: -10, maxX: 10, minZ: 28, maxZ: 42 };
        locationBounds.patio = { minX: 6, maxX: 18, minZ: 20, maxZ: 32 };
        locationBounds.pond = { minX: -16, maxX: -4, minZ: 24, maxZ: 38 };

        // === FANTASY AREA ===
        const fantasyArea = new THREE.Group();
        fantasyArea.position.set(35, 0, 25);
        scene.add(fantasyArea);
        locations.fantasy = fantasyArea;

        // Fantasy ground - magical grass
        const fantasyGroundGeo = new THREE.CircleGeometry(18, 32);
        const fantasyGroundMat = new THREE.MeshStandardMaterial({
            color: 0x7B68EE, // Purple-ish magical grass
            roughness: 0.8
        });
        const fantasyGround = new THREE.Mesh(fantasyGroundGeo, fantasyGroundMat);
        fantasyGround.rotation.x = -Math.PI / 2;
        fantasyGround.position.y = 0.01;
        fantasyGround.receiveShadow = true;
        fantasyArea.add(fantasyGround);

        // Transition path from main area to fantasy
        const pathGeo = new THREE.PlaneGeometry(4, 20);
        const pathMat = new THREE.MeshStandardMaterial({
            color: 0xDDA0DD, // Plum colored path
            roughness: 0.7
        });
        const fantasyPath = new THREE.Mesh(pathGeo, pathMat);
        fantasyPath.rotation.x = -Math.PI / 2;
        fantasyPath.rotation.z = Math.PI / 2;
        fantasyPath.position.set(-18, 0.02, 0);
        fantasyArea.add(fantasyPath);

        // === MUSHROOM HOUSES ===
        function createMushroomHouse(x, z, scale = 1, capColor = 0xFF6B6B) {
            const mushroom = new THREE.Group();
            mushroom.position.set(x, 0, z);

            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.5 * scale, 0.7 * scale, 2 * scale, 12);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC, roughness: 0.8 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 1 * scale;
            stem.castShadow = true;
            mushroom.add(stem);

            // Cap
            const capGeo = new THREE.SphereGeometry(1.5 * scale, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const capMat = new THREE.MeshStandardMaterial({ color: capColor, roughness: 0.6 });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 2 * scale;
            cap.castShadow = true;
            mushroom.add(cap);

            // White spots on cap
            const spotGeo = new THREE.CircleGeometry(0.15 * scale, 8);
            const spotMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
            for (let i = 0; i < 8; i++) {
                const spot = new THREE.Mesh(spotGeo, spotMat);
                const theta = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                const phi = 0.3 + Math.random() * 0.5;
                spot.position.set(
                    Math.sin(theta) * Math.cos(phi) * 1.4 * scale,
                    2 * scale + Math.sin(phi) * 1.4 * scale,
                    Math.cos(theta) * Math.cos(phi) * 1.4 * scale
                );
                spot.lookAt(mushroom.position.x, mushroom.position.y + 2 * scale, mushroom.position.z);
                mushroom.add(spot);
            }

            // Door (tiny round door)
            const doorGeo = new THREE.CircleGeometry(0.25 * scale, 12);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 0.35 * scale, 0.7 * scale);
            mushroom.add(door);

            // Window (tiny round window)
            const windowGeo = new THREE.CircleGeometry(0.12 * scale, 8);
            const windowMat = new THREE.MeshStandardMaterial({ color: 0xFFFF99, emissive: 0xFFFF00, emissiveIntensity: 0.3 });
            const mushroomWindow = new THREE.Mesh(windowGeo, windowMat);
            mushroomWindow.position.set(0.35 * scale, 1.2 * scale, 0.65 * scale);
            mushroom.add(mushroomWindow);

            return mushroom;
        }

        // Big main mushroom house
        fantasyArea.add(createMushroomHouse(0, 0, 1.5, 0xFF6B6B)); // Red
        // Smaller mushroom houses scattered around
        fantasyArea.add(createMushroomHouse(-5, 4, 1.0, 0xFFB347)); // Orange
        fantasyArea.add(createMushroomHouse(4, -3, 1.2, 0x9370DB)); // Purple
        fantasyArea.add(createMushroomHouse(-3, -5, 0.8, 0x20B2AA)); // Teal
        fantasyArea.add(createMushroomHouse(6, 5, 0.9, 0xFF69B4)); // Pink

        // === CRYSTAL FORMATIONS ===
        function createCrystal(x, z, height = 2, color = 0x00CED1) {
            const crystal = new THREE.Group();
            crystal.position.set(x, 0, z);

            // Main crystal
            const crystalGeo = new THREE.ConeGeometry(0.3, height, 6);
            const crystalMat = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.85
            });
            const mainCrystal = new THREE.Mesh(crystalGeo, crystalMat);
            mainCrystal.position.y = height / 2;
            mainCrystal.castShadow = true;
            crystal.add(mainCrystal);

            // Smaller crystals around base
            for (let i = 0; i < 3; i++) {
                const smallH = height * (0.3 + Math.random() * 0.3);
                const smallCrystal = new THREE.Mesh(
                    new THREE.ConeGeometry(0.15, smallH, 6),
                    crystalMat
                );
                const angle = (i / 3) * Math.PI * 2 + Math.random() * 0.5;
                smallCrystal.position.set(
                    Math.cos(angle) * 0.4,
                    smallH / 2,
                    Math.sin(angle) * 0.4
                );
                smallCrystal.rotation.z = (Math.random() - 0.5) * 0.3;
                crystal.add(smallCrystal);
            }

            // Glow effect (point light)
            const glow = new THREE.PointLight(color, 0.5, 3);
            glow.position.y = height / 2;
            crystal.add(glow);
            crystal.userData.glow = glow;

            return crystal;
        }

        // Crystal cluster
        const crystals = [];
        crystals.push(createCrystal(8, -6, 2.5, 0x00CED1)); // Cyan
        crystals.push(createCrystal(9, -5, 1.8, 0xFF00FF)); // Magenta
        crystals.push(createCrystal(7.5, -7, 2.0, 0x00FF7F)); // Spring green
        crystals.push(createCrystal(-7, 6, 2.2, 0x9400D3)); // Violet
        crystals.push(createCrystal(-8, 5, 1.5, 0x00BFFF)); // Deep sky blue
        crystals.forEach(c => fantasyArea.add(c));

        // === FAIRY RING (circle of glowing flowers) ===
        const fairyRing = new THREE.Group();
        fairyRing.position.set(-2, 0, 8);
        fantasyArea.add(fairyRing);

        const fairyFlowers = [];
        for (let i = 0; i < 12; i++) {
            const flower = new THREE.Group();
            const angle = (i / 12) * Math.PI * 2;
            flower.position.set(Math.cos(angle) * 3, 0, Math.sin(angle) * 3);

            // Stem
            const fStemGeo = new THREE.CylinderGeometry(0.02, 0.03, 0.4, 6);
            const fStemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const fStem = new THREE.Mesh(fStemGeo, fStemMat);
            fStem.position.y = 0.2;
            flower.add(fStem);

            // Glowing bloom
            const bloomGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const bloomColor = [0xFF69B4, 0x00FFFF, 0xFFFF00, 0xFF00FF][i % 4];
            const bloomMat = new THREE.MeshStandardMaterial({
                color: bloomColor,
                emissive: bloomColor,
                emissiveIntensity: 0.5
            });
            const bloom = new THREE.Mesh(bloomGeo, bloomMat);
            bloom.position.y = 0.45;
            flower.add(bloom);

            fairyRing.add(flower);
            fairyFlowers.push({ mesh: flower, bloom, baseEmissive: 0.5, phase: i * 0.5 });
        }

        // Center of fairy ring - soft glow
        const fairyLight = new THREE.PointLight(0xFFB6C1, 1, 8);
        fairyLight.position.set(0, 1, 0);
        fairyRing.add(fairyLight);

        // === ENCHANTED TREE ===
        const enchantedTree = new THREE.Group();
        enchantedTree.position.set(2, 0, -8);
        fantasyArea.add(enchantedTree);

        // Twisted trunk
        const trunkGeo = new THREE.CylinderGeometry(0.4, 0.8, 4, 8, 4, false);
        // Twist the trunk vertices
        const trunkPos = trunkGeo.attributes.position;
        for (let i = 0; i < trunkPos.count; i++) {
            const y = trunkPos.getY(i);
            const twist = y * 0.3;
            const x = trunkPos.getX(i);
            const z = trunkPos.getZ(i);
            trunkPos.setX(i, x * Math.cos(twist) - z * Math.sin(twist));
            trunkPos.setZ(i, x * Math.sin(twist) + z * Math.cos(twist));
        }
        trunkGeo.computeVertexNormals();
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4A3728, roughness: 0.9 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 2;
        trunk.castShadow = true;
        enchantedTree.add(trunk);

        // Magical foliage (glowing purple/blue)
        const foliageGeo = new THREE.SphereGeometry(2.5, 12, 12);
        const foliageMat = new THREE.MeshStandardMaterial({
            color: 0x663399,
            emissive: 0x4B0082,
            emissiveIntensity: 0.2,
            roughness: 0.8
        });
        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
        foliage.position.y = 5;
        foliage.scale.y = 0.8;
        foliage.castShadow = true;
        enchantedTree.add(foliage);

        // Hanging glowing orbs from tree
        const hangingOrbs = [];
        for (let i = 0; i < 6; i++) {
            const orbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const orbColor = [0x00FFFF, 0xFF00FF, 0xFFFF00][i % 3];
            const orbMat = new THREE.MeshStandardMaterial({
                color: orbColor,
                emissive: orbColor,
                emissiveIntensity: 0.8
            });
            const orb = new THREE.Mesh(orbGeo, orbMat);
            const angle = (i / 6) * Math.PI * 2;
            const radius = 1.5 + Math.random();
            orb.position.set(
                Math.cos(angle) * radius,
                3.5 + Math.random() * 2,
                Math.sin(angle) * radius
            );

            // String
            const stringGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.5 + Math.random() * 0.5, 4);
            const stringMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const string = new THREE.Mesh(stringGeo, stringMat);
            string.position.y = 0.3;
            orb.add(string);

            enchantedTree.add(orb);
            hangingOrbs.push({ mesh: orb, baseY: orb.position.y, phase: i });
        }

        // === MAGICAL STEPPING STONES ===
        const steppingStones = [];
        const stonePath = [
            { x: -12, z: 0 }, { x: -9, z: 1 }, { x: -6, z: 0.5 },
            { x: -3, z: -1 }, { x: 0, z: -2 }, { x: 3, z: -1 }
        ];
        stonePath.forEach((pos, i) => {
            const stoneGeo = new THREE.CylinderGeometry(0.5 + Math.random() * 0.2, 0.6 + Math.random() * 0.2, 0.2, 8);
            const hue = 0.7 + (i / stonePath.length) * 0.2; // Purple to pink gradient
            const stoneColor = new THREE.Color().setHSL(hue, 0.5, 0.6);
            const stoneMat = new THREE.MeshStandardMaterial({
                color: stoneColor,
                emissive: stoneColor,
                emissiveIntensity: 0.1,
                roughness: 0.5
            });
            const stone = new THREE.Mesh(stoneGeo, stoneMat);
            stone.position.set(pos.x, 0.1, pos.z);
            stone.rotation.y = Math.random() * Math.PI;
            fantasyArea.add(stone);
            steppingStones.push({ mesh: stone, baseEmissive: 0.1, phase: i * 0.8 });
        });

        // === TINY FAIRY COTTAGE ===
        const fairyCottage = new THREE.Group();
        fairyCottage.position.set(-6, 0, -3);
        fantasyArea.add(fairyCottage);

        // Cottage base (acorn shaped)
        const cottageGeo = new THREE.SphereGeometry(0.8, 12, 12);
        const cottageMat = new THREE.MeshStandardMaterial({ color: 0xD2691E, roughness: 0.8 });
        const cottageBase = new THREE.Mesh(cottageGeo, cottageMat);
        cottageBase.scale.y = 1.2;
        cottageBase.position.y = 0.8;
        cottageBase.castShadow = true;
        fairyCottage.add(cottageBase);

        // Acorn cap roof
        const roofGeo = new THREE.SphereGeometry(0.9, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 1.6;
        fairyCottage.add(roof);

        // Tiny door
        const cDoorGeo = new THREE.PlaneGeometry(0.2, 0.35);
        const cDoorMat = new THREE.MeshStandardMaterial({ color: 0x4A3728, side: THREE.DoubleSide });
        const cDoor = new THREE.Mesh(cDoorGeo, cDoorMat);
        cDoor.position.set(0, 0.4, 0.78);
        fairyCottage.add(cDoor);

        // Tiny glowing window
        const cWindowGeo = new THREE.CircleGeometry(0.08, 8);
        const cWindowMat = new THREE.MeshStandardMaterial({
            color: 0xFFFF99,
            emissive: 0xFFFF00,
            emissiveIntensity: 0.5
        });
        const cWindow = new THREE.Mesh(cWindowGeo, cWindowMat);
        cWindow.position.set(0.4, 0.9, 0.7);
        fairyCottage.add(cWindow);

        // === FLOATING ISLANDS (small) ===
        function createFloatingIsland(x, y, z, size = 1) {
            const island = new THREE.Group();
            island.position.set(x, y, z);

            // Bottom rocky part
            const rockGeo = new THREE.ConeGeometry(size * 0.8, size * 1.5, 8);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.rotation.x = Math.PI;
            rock.position.y = -size * 0.5;
            island.add(rock);

            // Top grassy part
            const topGeo = new THREE.CylinderGeometry(size * 0.8, size * 0.9, size * 0.3, 12);
            const topMat = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.8 });
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = size * 0.15;
            island.add(top);

            // Tiny tree or flower on top
            const tinyPlant = new THREE.Group();
            const tStemGeo = new THREE.CylinderGeometry(0.03 * size, 0.05 * size, 0.3 * size, 6);
            const tStem = new THREE.Mesh(tStemGeo, new THREE.MeshStandardMaterial({ color: 0x228B22 }));
            tStem.position.y = 0.45 * size;
            tinyPlant.add(tStem);
            const tTopGeo = new THREE.SphereGeometry(0.15 * size, 8, 8);
            const tTop = new THREE.Mesh(tTopGeo, new THREE.MeshStandardMaterial({
                color: 0xFF69B4,
                emissive: 0xFF1493,
                emissiveIntensity: 0.3
            }));
            tTop.position.y = 0.6 * size;
            tinyPlant.add(tTop);
            island.add(tinyPlant);

            island.userData.baseY = y;
            island.userData.phase = Math.random() * Math.PI * 2;

            return island;
        }

        const floatingIslands = [];
        floatingIslands.push(createFloatingIsland(5, 4, 8, 0.8));
        floatingIslands.push(createFloatingIsland(-4, 3.5, 3, 0.6));
        floatingIslands.push(createFloatingIsland(8, 5, 2, 0.5));
        floatingIslands.forEach(i => fantasyArea.add(i));

        // Update location bounds for fantasy area
        locationBounds.fantasy = { minX: 20, maxX: 52, minZ: 10, maxZ: 45 };

        // Store fantasy elements for animation
        const fantasyElements = {
            crystals,
            fairyFlowers,
            hangingOrbs,
            steppingStones,
            floatingIslands,
            fairyLight
        };

        // === AMBIENT CREATURES ===

        // Butterflies
        const butterflies = [];
        const butterflyColors = [0xFF69B4, 0xFFD700, 0x87CEEB, 0xFFA500];
        function createButterfly() {
            const bfGroup = new THREE.Group();

            // Wings
            const wingGeo = new THREE.CircleGeometry(0.1, 8);
            const wingMat = new THREE.MeshBasicMaterial({
                color: butterflyColors[Math.floor(Math.random() * butterflyColors.length)],
                side: THREE.DoubleSide
            });

            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.x = 0.08;
            leftWing.rotation.y = 0.3;
            bfGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.x = -0.08;
            rightWing.rotation.y = -0.3;
            bfGroup.add(rightWing);

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 6);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            bfGroup.add(body);

            // Random starting position in garden/lawn
            bfGroup.position.set(
                (Math.random() - 0.5) * 20,
                1 + Math.random() * 2,
                20 + Math.random() * 20
            );

            bfGroup.userData = {
                leftWing,
                rightWing,
                targetPos: bfGroup.position.clone(),
                changeTimer: 0
            };

            scene.add(bfGroup);
            return bfGroup;
        }

        // Create a few butterflies
        for (let i = 0; i < 4; i++) {
            butterflies.push(createButterfly());
        }

        // Create magical butterflies in fantasy area
        function createMagicalButterfly() {
            const bfGroup = new THREE.Group();

            // Glowing wings
            const wingGeo = new THREE.CircleGeometry(0.15, 8);
            const wingColor = [0xFF00FF, 0x00FFFF, 0xFFFF00, 0x00FF00][Math.floor(Math.random() * 4)];
            const wingMat = new THREE.MeshStandardMaterial({
                color: wingColor,
                emissive: wingColor,
                emissiveIntensity: 0.5,
                side: THREE.DoubleSide
            });

            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.x = 0.12;
            leftWing.rotation.y = 0.3;
            bfGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.x = -0.12;
            rightWing.rotation.y = -0.3;
            bfGroup.add(rightWing);

            // Sparkly body
            const bodyGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 6);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: wingColor,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            bfGroup.add(body);

            // Random starting position in fantasy area
            bfGroup.position.set(
                35 + (Math.random() - 0.5) * 30,
                1.5 + Math.random() * 2,
                25 + (Math.random() - 0.5) * 20
            );

            bfGroup.userData = {
                leftWing,
                rightWing,
                targetPos: bfGroup.position.clone(),
                changeTimer: 0,
                isMagical: true,
                baseArea: { x: 35, z: 25 }
            };

            scene.add(bfGroup);
            return bfGroup;
        }

        // Create magical butterflies for fantasy area
        for (let i = 0; i < 5; i++) {
            butterflies.push(createMagicalButterfly());
        }

        // Birds
        const birds = [];
        function createBird() {
            const birdGroup = new THREE.Group();

            // Body
            const bodyGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.scale.set(1.3, 1, 1);
            birdGroup.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.set(0.12, 0.05, 0);
            birdGroup.add(head);

            // Beak
            const beakGeo = new THREE.ConeGeometry(0.03, 0.08, 6);
            const beakMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const beak = new THREE.Mesh(beakGeo, beakMat);
            beak.position.set(0.22, 0.05, 0);
            beak.rotation.z = -Math.PI / 2;
            birdGroup.add(beak);

            // Wings
            const wingGeo = new THREE.PlaneGeometry(0.2, 0.1);
            const wingMat = new THREE.MeshStandardMaterial({ color: 0x654321, side: THREE.DoubleSide });
            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.set(0, 0.05, 0.1);
            leftWing.rotation.x = 0.3;
            birdGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.position.set(0, 0.05, -0.1);
            rightWing.rotation.x = -0.3;
            birdGroup.add(rightWing);

            // Tail
            const tailGeo = new THREE.PlaneGeometry(0.1, 0.08);
            const tail = new THREE.Mesh(tailGeo, wingMat);
            tail.position.set(-0.18, 0, 0);
            tail.rotation.y = Math.PI / 2;
            birdGroup.add(tail);

            birdGroup.userData = {
                leftWing,
                rightWing,
                isFlying: false,
                perchPos: new THREE.Vector3(7, 2.5, 35), // Bird feeder
                flightTarget: null,
                stateTimer: 3 + Math.random() * 5
            };

            // Start at bird feeder
            birdGroup.position.copy(birdGroup.userData.perchPos);
            birdGroup.position.x += (Math.random() - 0.5) * 0.5;
            birdGroup.visible = true;

            scene.add(birdGroup);
            return birdGroup;
        }

        // Create birds
        for (let i = 0; i < 3; i++) {
            birds.push(createBird());
        }

        // Frog
        const frogGroup = new THREE.Group();
        frogGroup.position.set(-10, 0.15, 28);
        scene.add(frogGroup);

        const frogBodyGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const frogMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const frogBody = new THREE.Mesh(frogBodyGeo, frogMat);
        frogBody.scale.set(1.2, 0.8, 1);
        frogGroup.add(frogBody);

        const frogHeadGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const frogHead = new THREE.Mesh(frogHeadGeo, frogMat);
        frogHead.position.set(0.12, 0.05, 0);
        frogGroup.add(frogHead);

        // Frog eyes
        const frogEyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const frogEyeMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        const frogLeftEye = new THREE.Mesh(frogEyeGeo, frogEyeMat);
        frogLeftEye.position.set(0.15, 0.12, 0.05);
        frogGroup.add(frogLeftEye);
        const frogRightEye = new THREE.Mesh(frogEyeGeo, frogEyeMat);
        frogRightEye.position.set(0.15, 0.12, -0.05);
        frogGroup.add(frogRightEye);

        frogGroup.userData = {
            ribbittTimer: 5 + Math.random() * 10,
            isJumping: false
        };

        // Dragonflies
        const dragonflies = [];
        function createDragonfly() {
            const dfGroup = new THREE.Group();

            // Body
            const dfBodyGeo = new THREE.CylinderGeometry(0.01, 0.015, 0.2, 6);
            const dfBodyMat = new THREE.MeshBasicMaterial({ color: 0x0000CD });
            const dfBody = new THREE.Mesh(dfBodyGeo, dfBodyMat);
            dfBody.rotation.x = Math.PI / 2;
            dfGroup.add(dfBody);

            // Wings (4 wings)
            const dfWingGeo = new THREE.PlaneGeometry(0.15, 0.03);
            const dfWingMat = new THREE.MeshBasicMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            for (let i = 0; i < 4; i++) {
                const wing = new THREE.Mesh(dfWingGeo, dfWingMat);
                wing.position.set(0, 0, (i < 2 ? 1 : -1) * 0.04);
                wing.position.x = (i % 2 === 0 ? 0.05 : -0.05);
                wing.rotation.x = Math.PI / 2;
                dfGroup.add(wing);
            }

            dfGroup.position.set(
                -10 + (Math.random() - 0.5) * 6,
                1.5 + Math.random(),
                30 + (Math.random() - 0.5) * 6
            );

            dfGroup.userData = { offset: Math.random() * Math.PI * 2 };

            scene.add(dfGroup);
            return dfGroup;
        }

        for (let i = 0; i < 3; i++) {
            dragonflies.push(createDragonfly());
        }

        // Mouse in pantry
        const mouseGroup = new THREE.Group();
        mouseGroup.position.set(22, 0.08, 3);
        mouseGroup.visible = false; // Hidden until peek
        scene.add(mouseGroup);

        const mouseBodyGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const mouseMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const mouseBody = new THREE.Mesh(mouseBodyGeo, mouseMat);
        mouseBody.scale.set(1.3, 0.8, 1);
        mouseGroup.add(mouseBody);

        const mouseHeadGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const mouseHead = new THREE.Mesh(mouseHeadGeo, mouseMat);
        mouseHead.position.set(0.1, 0.02, 0);
        mouseGroup.add(mouseHead);

        // Mouse ears
        const mouseEarGeo = new THREE.CircleGeometry(0.03, 8);
        const mouseEarMat = new THREE.MeshBasicMaterial({ color: 0xFFB6C1, side: THREE.DoubleSide });
        const mouseLeftEar = new THREE.Mesh(mouseEarGeo, mouseEarMat);
        mouseLeftEar.position.set(0.08, 0.08, 0.03);
        mouseGroup.add(mouseLeftEar);
        const mouseRightEar = new THREE.Mesh(mouseEarGeo, mouseEarMat);
        mouseRightEar.position.set(0.08, 0.08, -0.03);
        mouseGroup.add(mouseRightEar);

        // Mouse tail
        const mouseTailGeo = new THREE.CylinderGeometry(0.01, 0.005, 0.15, 6);
        const mouseTail = new THREE.Mesh(mouseTailGeo, mouseMat);
        mouseTail.position.set(-0.12, 0, 0);
        mouseTail.rotation.z = Math.PI / 2 + 0.3;
        mouseGroup.add(mouseTail);

        mouseGroup.userData = {
            peekTimer: 10 + Math.random() * 20,
            isPeeking: false,
            peekDuration: 0
        };

        // Mouse hole in kitchen (visual marker)
        const mouseHoleGeo = new THREE.CircleGeometry(0.15, 16);
        const mouseHoleMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const mouseHole = new THREE.Mesh(mouseHoleGeo, mouseHoleMat);
        mouseHole.position.set(3.5, 0.15, 4.99);
        kitchen.add(mouseHole);

        // Function to animate creatures
        function updateCreatures(dt, time) {
            // Butterflies
            butterflies.forEach(bf => {
                bf.userData.changeTimer -= dt;
                if (bf.userData.changeTimer <= 0) {
                    // Magical butterflies stay in fantasy area
                    if (bf.userData.isMagical) {
                        bf.userData.targetPos.set(
                            bf.userData.baseArea.x + (Math.random() - 0.5) * 30,
                            1.5 + Math.random() * 3,
                            bf.userData.baseArea.z + (Math.random() - 0.5) * 20
                        );
                    } else {
                        bf.userData.targetPos.set(
                            (Math.random() - 0.5) * 25,
                            1 + Math.random() * 2.5,
                            15 + Math.random() * 25
                        );
                    }
                    bf.userData.changeTimer = 2 + Math.random() * 4;
                }

                // Move toward target
                const dir = bf.userData.targetPos.clone().sub(bf.position);
                if (dir.length() > 0.1) {
                    dir.normalize().multiplyScalar(dt * 2);
                    bf.position.add(dir);
                    bf.rotation.y = Math.atan2(dir.x, dir.z);
                }

                // Wing flapping
                const flapSpeed = 15;
                bf.userData.leftWing.rotation.y = 0.3 + Math.sin(time * flapSpeed) * 0.5;
                bf.userData.rightWing.rotation.y = -0.3 - Math.sin(time * flapSpeed) * 0.5;

                // Bobbing
                bf.position.y += Math.sin(time * 3 + bf.userData.changeTimer) * dt * 0.5;
            });

            // Birds
            birds.forEach((bird, idx) => {
                bird.userData.stateTimer -= dt;

                if (bird.userData.isFlying) {
                    // Flying animation
                    bird.userData.leftWing.rotation.x = Math.sin(time * 12) * 0.8;
                    bird.userData.rightWing.rotation.x = -Math.sin(time * 12) * 0.8;

                    if (bird.userData.flightTarget) {
                        const dir = bird.userData.flightTarget.clone().sub(bird.position);
                        if (dir.length() > 0.2) {
                            dir.normalize().multiplyScalar(dt * 4);
                            bird.position.add(dir);
                            bird.rotation.y = Math.atan2(dir.x, dir.z);
                        } else {
                            bird.userData.isFlying = false;
                            bird.userData.stateTimer = 3 + Math.random() * 5;
                        }
                    }
                } else {
                    // Perched - gentle movement
                    bird.userData.leftWing.rotation.x = 0.3;
                    bird.userData.rightWing.rotation.x = -0.3;

                    // Occasional head bob
                    bird.children[1].position.y = 0.05 + Math.sin(time * 2 + idx) * 0.02;

                    if (bird.userData.stateTimer <= 0) {
                        // Fly to new spot
                        bird.userData.isFlying = true;
                        bird.userData.flightTarget = new THREE.Vector3(
                            5 + Math.random() * 4,
                            2 + Math.random() * 1,
                            33 + Math.random() * 4
                        );
                        bird.userData.stateTimer = 2;
                    }
                }
            });

            // Frog
            frogGroup.userData.ribbittTimer -= dt;
            if (frogGroup.userData.ribbittTimer <= 0 && !frogGroup.userData.isJumping) {
                // Occasional ribbit (visual bounce)
                frogGroup.userData.isJumping = true;
                setTimeout(() => {
                    frogGroup.userData.isJumping = false;
                }, 200);
                frogGroup.userData.ribbittTimer = 8 + Math.random() * 15;
            }
            if (frogGroup.userData.isJumping) {
                frogGroup.position.y = 0.15 + Math.sin(time * 30) * 0.1;
            } else {
                frogGroup.position.y = 0.15;
            }

            // Dragonflies
            dragonflies.forEach(df => {
                const off = df.userData.offset;
                df.position.x = -10 + Math.sin(time * 0.5 + off) * 3;
                df.position.z = 30 + Math.cos(time * 0.3 + off) * 3;
                df.position.y = 1.2 + Math.sin(time * 2 + off) * 0.3;
                df.rotation.y = time * 0.5 + off;
            });

            // Mouse
            mouseGroup.userData.peekTimer -= dt;
            if (mouseGroup.userData.isPeeking) {
                mouseGroup.userData.peekDuration -= dt;
                if (mouseGroup.userData.peekDuration <= 0) {
                    mouseGroup.visible = false;
                    mouseGroup.userData.isPeeking = false;
                    mouseGroup.userData.peekTimer = 15 + Math.random() * 30;
                }
            } else if (mouseGroup.userData.peekTimer <= 0) {
                // Mouse peeks out!
                mouseGroup.visible = true;
                mouseGroup.userData.isPeeking = true;
                mouseGroup.userData.peekDuration = 2 + Math.random() * 3;
            }

            // Mouse wiggle when peeking
            if (mouseGroup.visible) {
                mouseGroup.rotation.y = Math.sin(time * 5) * 0.2;
            }
        }

        // --- KITTEN MODEL (REALISTIC) ---
        const kittenGroup = new THREE.Group();
        scene.add(kittenGroup);

        // Materials - Tabby coloring
        const materialFur = new THREE.MeshStandardMaterial({ color: 0xffaa55, roughness: 0.85 }); // Orange tabby base
        const materialFurDark = new THREE.MeshStandardMaterial({ color: 0xdd8833, roughness: 0.85 }); // Tabby stripes
        const materialWhite = new THREE.MeshStandardMaterial({ color: 0xfff8f0, roughness: 0.85 }); // Chest/belly
        const materialEyeWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        const materialIris = new THREE.MeshStandardMaterial({ color: 0x7fb069, roughness: 0.2 }); // Green eyes
        const materialPupil = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 });
        const materialEyeShine = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const materialNose = new THREE.MeshStandardMaterial({ color: 0xff8899, roughness: 0.4 });
        const materialInnerEar = new THREE.MeshStandardMaterial({ color: 0xffbbcc, roughness: 0.6 });
        const materialPawPad = new THREE.MeshStandardMaterial({ color: 0xffaabb, roughness: 0.5 }); // Pink toe beans
        const materialWhisker = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // Helper to create a capsule-like shape (Cylinder + 2 Spheres)
        function createCapsule(radius, length, material) {
            const group = new THREE.Group();
            const cylinderGeo = new THREE.CylinderGeometry(radius, radius, length, 16);
            const cylinder = new THREE.Mesh(cylinderGeo, material);
            cylinder.castShadow = true;
            group.add(cylinder);
            const sphereGeo = new THREE.SphereGeometry(radius, 16, 16);
            const topSphere = new THREE.Mesh(sphereGeo, material);
            topSphere.position.y = length / 2;
            topSphere.castShadow = true;
            group.add(topSphere);
            const bottomSphere = new THREE.Mesh(sphereGeo, material);
            bottomSphere.position.y = -length / 2;
            bottomSphere.castShadow = true;
            group.add(bottomSphere);
            return group;
        }

        // === BODY ===
        // Main body - slightly more organic shape
        const body = createCapsule(0.65, 1.3, materialFur);
        body.rotation.x = Math.PI / 2;
        body.position.y = 1.15;
        kittenGroup.add(body);

        // Chest/belly white patch
        const chestGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const chest = new THREE.Mesh(chestGeo, materialWhite);
        chest.position.set(0, 1.0, 0.4);
        chest.scale.set(0.8, 0.7, 0.6);
        kittenGroup.add(chest);

        // Shoulder bumps
        const shoulderGeo = new THREE.SphereGeometry(0.25, 12, 12);
        const leftShoulder = new THREE.Mesh(shoulderGeo, materialFur);
        leftShoulder.position.set(0.35, 1.3, 0.4);
        leftShoulder.castShadow = true;
        kittenGroup.add(leftShoulder);
        const rightShoulder = new THREE.Mesh(shoulderGeo, materialFur);
        rightShoulder.position.set(-0.35, 1.3, 0.4);
        rightShoulder.castShadow = true;
        kittenGroup.add(rightShoulder);

        // Hip bumps
        const leftHip = new THREE.Mesh(shoulderGeo, materialFur);
        leftHip.position.set(0.3, 1.2, -0.5);
        leftHip.castShadow = true;
        kittenGroup.add(leftHip);
        const rightHip = new THREE.Mesh(shoulderGeo, materialFur);
        rightHip.position.set(-0.3, 1.2, -0.5);
        rightHip.castShadow = true;
        kittenGroup.add(rightHip);

        // === HEAD ===
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 1.75, 1.1);
        kittenGroup.add(headGroup);

        // Main head - slightly wider for cat proportions
        const headGeo = new THREE.SphereGeometry(0.6, 20, 20);
        const head = new THREE.Mesh(headGeo, materialFur);
        head.scale.set(1.1, 0.95, 1.0); // Wider cheeks
        head.castShadow = true;
        headGroup.add(head);

        // Muzzle/snout protrusion
        const muzzleGeo = new THREE.SphereGeometry(0.25, 16, 16);
        const muzzle = new THREE.Mesh(muzzleGeo, materialWhite);
        muzzle.position.set(0, -0.15, 0.5);
        muzzle.scale.set(1.0, 0.7, 0.8);
        headGroup.add(muzzle);

        // Forehead stripe (tabby marking)
        const foreheadStripeGeo = new THREE.BoxGeometry(0.08, 0.2, 0.1);
        const foreheadStripe = new THREE.Mesh(foreheadStripeGeo, materialFurDark);
        foreheadStripe.position.set(0, 0.35, 0.5);
        foreheadStripe.rotation.x = -0.3;
        headGroup.add(foreheadStripe);

        // === EYES (Detailed) ===
        function createDetailedEye(xPos) {
            const eyeGroup = new THREE.Group();
            eyeGroup.position.set(xPos, 0.08, 0.45);

            // Eye socket indent (subtle)
            const socketGeo = new THREE.SphereGeometry(0.14, 12, 12);
            const socket = new THREE.Mesh(socketGeo, materialFur);
            socket.scale.set(1.0, 0.9, 0.5);
            eyeGroup.add(socket);

            // Sclera (white part)
            const scleraGeo = new THREE.SphereGeometry(0.11, 16, 16);
            const sclera = new THREE.Mesh(scleraGeo, materialEyeWhite);
            sclera.position.z = 0.05;
            eyeGroup.add(sclera);

            // Iris
            const irisGeo = new THREE.CircleGeometry(0.08, 16);
            const iris = new THREE.Mesh(irisGeo, materialIris);
            iris.position.z = 0.12;
            eyeGroup.add(iris);

            // Pupil (vertical slit for cat)
            const pupilGeo = new THREE.PlaneGeometry(0.03, 0.1);
            const pupil = new THREE.Mesh(pupilGeo, materialPupil);
            pupil.position.z = 0.125;
            eyeGroup.add(pupil);

            // Eye shine (reflection)
            const shineGeo = new THREE.CircleGeometry(0.025, 8);
            const shine = new THREE.Mesh(shineGeo, materialEyeShine);
            shine.position.set(0.02, 0.03, 0.13);
            eyeGroup.add(shine);

            // Eyelid (for blinking)
            const eyelidGeo = new THREE.SphereGeometry(0.12, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const eyelid = new THREE.Mesh(eyelidGeo, materialFur);
            eyelid.position.z = 0.06;
            eyelid.rotation.x = Math.PI; // Flipped to cover from top
            eyelid.scale.y = 0.0; // Start open
            eyeGroup.add(eyelid);

            return { group: eyeGroup, pupil, eyelid, iris };
        }

        const leftEyeData = createDetailedEye(0.22);
        const rightEyeData = createDetailedEye(-0.22);
        headGroup.add(leftEyeData.group);
        headGroup.add(rightEyeData.group);
        const leftEye = leftEyeData.group;
        const rightEye = rightEyeData.group;
        const leftEyelid = leftEyeData.eyelid;
        const rightEyelid = rightEyeData.eyelid;
        const leftPupil = leftEyeData.pupil;
        const rightPupil = rightEyeData.pupil;

        // === EARS (Detailed) ===
        function createDetailedEar(xPos, zRot) {
            const earGroup = new THREE.Group();
            earGroup.position.set(xPos, 0.55, 0.1);
            earGroup.rotation.z = zRot;
            earGroup.rotation.x = -0.15;

            // Outer ear
            const outerEarGeo = new THREE.ConeGeometry(0.18, 0.4, 16);
            const outerEar = new THREE.Mesh(outerEarGeo, materialFur);
            outerEar.castShadow = true;
            earGroup.add(outerEar);

            // Inner ear (pink)
            const innerEarGeo = new THREE.ConeGeometry(0.12, 0.3, 16);
            const innerEar = new THREE.Mesh(innerEarGeo, materialInnerEar);
            innerEar.position.set(0, -0.03, 0.05);
            earGroup.add(innerEar);

            // Ear tuft at tip
            const tuftGeo = new THREE.ConeGeometry(0.04, 0.1, 8);
            const tuft = new THREE.Mesh(tuftGeo, materialFurDark);
            tuft.position.y = 0.22;
            earGroup.add(tuft);

            return earGroup;
        }

        const leftEar = createDetailedEar(0.35, -0.2);
        const rightEar = createDetailedEar(-0.35, 0.2);
        headGroup.add(leftEar);
        headGroup.add(rightEar);

        // === NOSE (Detailed) ===
        const noseGroup = new THREE.Group();
        noseGroup.position.set(0, -0.12, 0.58);
        headGroup.add(noseGroup);

        // Main nose
        const noseGeo = new THREE.SphereGeometry(0.06, 12, 12);
        const nose = new THREE.Mesh(noseGeo, materialNose);
        nose.scale.set(1.2, 0.8, 0.6);
        noseGroup.add(nose);

        // Nostrils
        const nostrilGeo = new THREE.SphereGeometry(0.015, 8, 8);
        const leftNostril = new THREE.Mesh(nostrilGeo, materialPupil);
        leftNostril.position.set(0.03, -0.02, 0.04);
        noseGroup.add(leftNostril);
        const rightNostril = new THREE.Mesh(nostrilGeo, materialPupil);
        rightNostril.position.set(-0.03, -0.02, 0.04);
        noseGroup.add(rightNostril);

        // Mouth line
        const mouthCurve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(-0.08, -0.22, 0.55),
            new THREE.Vector3(0, -0.26, 0.58),
            new THREE.Vector3(0.08, -0.22, 0.55)
        );
        const mouthGeo = new THREE.TubeGeometry(mouthCurve, 10, 0.008, 8, false);
        const mouth = new THREE.Mesh(mouthGeo, materialPupil);
        headGroup.add(mouth);

        // === WHISKERS ===
        const whiskers = [];
        function createWhisker(side, yOffset, angle) {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(side * 0.15, yOffset * 0.02, 0.05),
                new THREE.Vector3(side * 0.35, yOffset * 0.05, 0.02)
            );
            const whiskerGeo = new THREE.TubeGeometry(curve, 8, 0.005, 4, false);
            const whisker = new THREE.Mesh(whiskerGeo, materialWhisker);
            whisker.position.set(side * 0.15, -0.08 + yOffset * 0.04, 0.52);
            whisker.rotation.z = angle;
            return whisker;
        }

        // 6 whiskers per side
        for (let i = 0; i < 3; i++) {
            const leftWhisker = createWhisker(1, i - 1, (i - 1) * 0.1);
            const rightWhisker = createWhisker(-1, i - 1, -(i - 1) * 0.1);
            headGroup.add(leftWhisker);
            headGroup.add(rightWhisker);
            whiskers.push(leftWhisker, rightWhisker);
        }

        // === LEGS (Improved with joints) ===
        const legs = [];

        function createDetailedLeg(x, z, name, isFront) {
            const legGroup = new THREE.Group();
            legGroup.position.set(x, isFront ? 1.15 : 1.1, z);

            // Upper leg
            const upperLegGeo = new THREE.CylinderGeometry(0.14, 0.11, 0.5, 10);
            const upperLeg = new THREE.Mesh(upperLegGeo, materialFur);
            upperLeg.position.y = -0.25;
            upperLeg.castShadow = true;
            legGroup.add(upperLeg);

            // Lower leg group (for joint bending)
            const lowerLegGroup = new THREE.Group();
            lowerLegGroup.position.y = -0.5;
            legGroup.add(lowerLegGroup);

            const lowerLegGeo = new THREE.CylinderGeometry(0.10, 0.08, 0.5, 10);
            const lowerLeg = new THREE.Mesh(lowerLegGeo, materialFur);
            lowerLeg.position.y = -0.25;
            lowerLeg.castShadow = true;
            lowerLegGroup.add(lowerLeg);

            // Paw
            const pawGroup = new THREE.Group();
            pawGroup.position.y = -0.5;
            lowerLegGroup.add(pawGroup);

            // Main paw pad
            const pawGeo = new THREE.SphereGeometry(0.1, 12, 12);
            const paw = new THREE.Mesh(pawGeo, materialFur);
            paw.scale.set(1.2, 0.5, 1.3);
            paw.position.y = -0.02;
            pawGroup.add(paw);

            // Toe beans (4 small pink pads)
            const toeGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const toePositions = [
                { x: 0.04, z: 0.06 }, { x: -0.04, z: 0.06 },
                { x: 0.06, z: 0.02 }, { x: -0.06, z: 0.02 }
            ];
            toePositions.forEach(pos => {
                const toe = new THREE.Mesh(toeGeo, materialPawPad);
                toe.position.set(pos.x, -0.05, pos.z);
                toe.scale.y = 0.6;
                pawGroup.add(toe);
            });

            // Main pad
            const mainPadGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const mainPad = new THREE.Mesh(mainPadGeo, materialPawPad);
            mainPad.position.set(0, -0.05, -0.02);
            mainPad.scale.set(1.2, 0.5, 1.0);
            pawGroup.add(mainPad);

            kittenGroup.add(legGroup);
            legs.push({
                group: legGroup,
                lowerLeg: lowerLegGroup,
                paw: pawGroup,
                name: name,
                initialRot: 0
            });
            return legGroup;
        }

        const legFL = createDetailedLeg(0.35, 0.55, 'FL', true);
        const legFR = createDetailedLeg(-0.35, 0.55, 'FR', true);
        const legBL = createDetailedLeg(0.35, -0.55, 'BL', false);
        const legBR = createDetailedLeg(-0.35, -0.55, 'BR', false);

        // === TAIL (Multi-segment) ===
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1.3, -0.75);
        kittenGroup.add(tailGroup);

        const tailSegments = [];
        const numTailSegments = 4;
        let prevSegment = tailGroup;

        for (let i = 0; i < numTailSegments; i++) {
            const segmentGroup = new THREE.Group();
            const segLen = 0.3 - i * 0.03;
            const segRad = 0.09 - i * 0.015;

            const segGeo = new THREE.CylinderGeometry(segRad, segRad - 0.01, segLen, 8);
            const segment = new THREE.Mesh(segGeo, materialFur);
            segment.castShadow = true;

            // Position each segment at end of previous
            if (i === 0) {
                segmentGroup.position.set(0, 0.15, -0.1);
                segmentGroup.rotation.x = -0.5; // Base angle
            } else {
                segmentGroup.position.y = -segLen * 0.8;
                segmentGroup.rotation.x = 0.15; // Slight curve
            }

            segment.position.y = -segLen / 2;
            segmentGroup.add(segment);
            prevSegment.add(segmentGroup);
            prevSegment = segmentGroup;
            tailSegments.push(segmentGroup);
        }

        // Tail tip tuft
        const tailTipGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const tailTip = new THREE.Mesh(tailTipGeo, materialFurDark);
        tailTip.position.y = -0.15;
        prevSegment.add(tailTip);

        // Store tail segments for animation
        kittenGroup.userData.tailSegments = tailSegments;


        // --- PARTICLES (HEARTS) ---
        const hearts = [];
        const heartGeo = new THREE.ShapeGeometry(
            new THREE.Shape()
                .moveTo(0.25, 0.25)
                .bezierCurveTo(0.25, 0.25, 0.20, 0, 0, 0)
                .bezierCurveTo(-0.30, 0, -0.30, 0.35, -0.30, 0.35)
                .bezierCurveTo(-0.30, 0.55, -0.10, 0.77, 0.25, 0.95)
                .bezierCurveTo(0.60, 0.77, 0.80, 0.55, 0.80, 0.35)
                .bezierCurveTo(0.80, 0.35, 0.80, 0, 0.50, 0)
                .bezierCurveTo(0.35, 0, 0.25, 0.25, 0.25, 0.25)
        );
        const heartMat = new THREE.MeshBasicMaterial({ color: 0xff69b4, side: THREE.DoubleSide });

        function spawnHeart() {
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.scale.set(0.2, 0.2, 0.2);
            // Position above head
            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            heart.position.copy(worldPos);
            heart.position.y += 1.0 + Math.random() * 0.5;
            heart.position.x += (Math.random() - 0.5) * 0.5;
            heart.rotation.z = Math.PI; // Correct orientation from shape

            scene.add(heart);
            hearts.push({ mesh: heart, life: 1.0, speedY: 1.5 + Math.random() });
        }

        // --- SPARKLE PARTICLES (for fantasy area) ---
        const sparkles = [];
        const sparkleColors = [0xFF00FF, 0x00FFFF, 0xFFFF00, 0xFF69B4, 0x00FF7F, 0x9370DB];
        const sparkleGeo = new THREE.OctahedronGeometry(0.05, 0);

        function spawnSparkle(position, count = 5, color = null) {
            for (let i = 0; i < count; i++) {
                const sparkleColor = color || sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
                const sparkleMat = new THREE.MeshBasicMaterial({
                    color: sparkleColor,
                    transparent: true,
                    opacity: 1.0
                });
                const sparkle = new THREE.Mesh(sparkleGeo, sparkleMat);
                sparkle.position.copy(position);
                sparkle.position.x += (Math.random() - 0.5) * 0.5;
                sparkle.position.y += Math.random() * 0.5;
                sparkle.position.z += (Math.random() - 0.5) * 0.5;
                sparkle.scale.setScalar(0.5 + Math.random() * 0.5);

                scene.add(sparkle);
                sparkles.push({
                    mesh: sparkle,
                    life: 1.5 + Math.random() * 0.5,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        1 + Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    rotSpeed: (Math.random() - 0.5) * 10
                });
            }
        }

        // Spawn sparkle burst at position (for user clicks)
        function spawnSparkleBurst(position, count = 12) {
            for (let i = 0; i < count; i++) {
                const sparkleColor = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
                const sparkleMat = new THREE.MeshBasicMaterial({
                    color: sparkleColor,
                    transparent: true,
                    opacity: 1.0
                });
                const sparkle = new THREE.Mesh(sparkleGeo, sparkleMat);
                sparkle.position.copy(position);
                sparkle.scale.setScalar(0.8 + Math.random() * 0.5);

                const angle = (i / count) * Math.PI * 2;
                const speed = 2 + Math.random();
                scene.add(sparkle);
                sparkles.push({
                    mesh: sparkle,
                    life: 2.0 + Math.random() * 0.5,
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        1 + Math.random() * 2,
                        Math.sin(angle) * speed
                    ),
                    rotSpeed: (Math.random() - 0.5) * 15
                });
            }
        }

        // --- Zzz PARTICLES ---
        function createZzzTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Z', 32, 32);
            // Add slight outline
            ctx.strokeStyle = '#88ccff';
            ctx.lineWidth = 2;
            ctx.strokeText('Z', 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const zzzTexture = createZzzTexture();
        const zzzMaterial = new THREE.SpriteMaterial({ map: zzzTexture, transparent: true, opacity: 0.8 });
        const zzzs = [];

        function spawnZzz() {
            const zzz = new THREE.Sprite(zzzMaterial);
            zzz.scale.set(0.5, 0.5, 0.5);

            const worldPos = new THREE.Vector3();
            head.getWorldPosition(worldPos);
            zzz.position.copy(worldPos);
            zzz.position.y += 0.8;
            zzz.position.x += (Math.random() - 0.5) * 0.2;

            scene.add(zzz);
            zzzs.push({ mesh: zzz, life: 2.0, speedY: 0.8, swayOffset: Math.random() * 10 });
        }

        // --- TOYS ---
        const toys = [];
        let draggedToy = null;
        let specialYarn = null;
        const toyMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.4 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.4 }),
        ];

        function createToys() {
            // Ball (red)
            const ballGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const ball = new THREE.Mesh(ballGeo, toyMaterials[0]);
            ball.castShadow = true;
            ball.position.set(3, 0.4, 3);
            scene.add(ball);
            toys.push({ mesh: ball, type: 'ball', radius: 0.4, velocity: new THREE.Vector3() });

            // Small jingle ball (green)
            const jingleBall = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), toyMaterials[1]);
            jingleBall.castShadow = true;
            jingleBall.position.set(-2, 0.25, 4);
            scene.add(jingleBall);
            toys.push({ mesh: jingleBall, type: 'ball', radius: 0.25, velocity: new THREE.Vector3() });

            // Box (blue)
            const boxGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
            const box = new THREE.Mesh(boxGeo, toyMaterials[2]);
            box.castShadow = true;
            box.position.set(-3, 0.35, -2);
            scene.add(box);
            toys.push({ mesh: box, type: 'box', radius: 0.5, velocity: new THREE.Vector3() });

            // Mouse toy
            const mouseGroup = new THREE.Group();
            const mouseMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 });
            const mouseBody = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), mouseMat);
            mouseBody.scale.set(1.5, 0.8, 1);
            mouseGroup.add(mouseBody);
            // Mouse ears
            const earMat = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.6 });
            const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), earMat);
            ear1.position.set(0.1, 0.12, -0.15);
            mouseGroup.add(ear1);
            const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), earMat);
            ear2.position.set(-0.1, 0.12, -0.15);
            mouseGroup.add(ear2);
            // Mouse tail
            const tailCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0.25),
                new THREE.Vector3(0, 0.1, 0.5),
                new THREE.Vector3(0, 0, 0.7)
            );
            const tailGeo = new THREE.TubeGeometry(tailCurve, 8, 0.02, 6, false);
            const tail = new THREE.Mesh(tailGeo, mouseMat);
            mouseGroup.add(tail);
            mouseGroup.position.set(2, 0.15, -3);
            mouseGroup.castShadow = true;
            scene.add(mouseGroup);
            toys.push({ mesh: mouseGroup, type: 'mouse', radius: 0.3, velocity: new THREE.Vector3() });

            // Crinkle ball (foil-like)
            const crinkleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.2, metalness: 0.8 });
            const crinkleBall = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), crinkleMat);
            crinkleBall.castShadow = true;
            crinkleBall.position.set(-4, 0.3, 2);
            scene.add(crinkleBall);
            toys.push({ mesh: crinkleBall, type: 'ball', radius: 0.3, velocity: new THREE.Vector3() });

            // Feather toy
            const featherGroup = new THREE.Group();
            const featherMat = new THREE.MeshStandardMaterial({ color: 0x9932CC, roughness: 0.5 });
            const featherStick = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            featherStick.rotation.x = Math.PI / 2;
            featherGroup.add(featherStick);
            // Feather plumes
            for (let i = 0; i < 5; i++) {
                const plume = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 4), featherMat);
                plume.position.set((i - 2) * 0.05, 0, -0.25);
                plume.rotation.x = -0.3;
                featherGroup.add(plume);
            }
            featherGroup.position.set(5, 0.15, 2);
            featherGroup.castShadow = true;
            scene.add(featherGroup);
            toys.push({ mesh: featherGroup, type: 'feather', radius: 0.25, velocity: new THREE.Vector3() });

            // Paper bag in kitchen (cat loves these!)
            const bagGroup = new THREE.Group();
            const bagMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.9 });
            const bagBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 0.8), bagMat);
            bagBody.position.y = 0.4;
            bagGroup.add(bagBody);
            // Open top
            const bagOpen = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 0.6), bagMat);
            bagOpen.position.set(0, 0.85, 0);
            bagGroup.add(bagOpen);
            bagGroup.position.set(16, 0, 0);
            bagGroup.castShadow = true;
            scene.add(bagGroup);
            toys.push({ mesh: bagGroup, type: 'bag', radius: 0.8, velocity: new THREE.Vector3() });

            // Small rubber ball in bedroom
            const rubberBall = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12),
                new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.3 }));
            rubberBall.castShadow = true;
            rubberBall.position.set(-16, 0.2, 2);
            scene.add(rubberBall);
            toys.push({ mesh: rubberBall, type: 'ball', radius: 0.2, velocity: new THREE.Vector3() });

            // Yarn Ball (special draggable - pink)
            const yarnGroup = new THREE.Group();
            const yarnMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.8 });
            const yarnCore = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), yarnMat);
            yarnGroup.add(yarnCore);
            // Add yarn texture lines
            for (let i = 0; i < 8; i++) {
                const strand = new THREE.Mesh(
                    new THREE.TorusGeometry(0.38, 0.02, 8, 16),
                    yarnMat
                );
                strand.rotation.x = Math.random() * Math.PI;
                strand.rotation.y = Math.random() * Math.PI;
                yarnGroup.add(strand);
            }
            // Trailing string
            const stringCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0.35),
                new THREE.Vector3(0.3, 0, 0.6),
                new THREE.Vector3(0.5, 0, 0.8)
            );
            const stringGeo = new THREE.TubeGeometry(stringCurve, 10, 0.02, 8, false);
            const string = new THREE.Mesh(stringGeo, yarnMat);
            yarnGroup.add(string);
            yarnGroup.position.set(4, 0.35, -1);
            yarnGroup.castShadow = true;
            scene.add(yarnGroup);
            specialYarn = { mesh: yarnGroup, type: 'yarn', radius: 0.35, velocity: new THREE.Vector3() };
            toys.push(specialYarn);

            // Catnip mouse on lawn
            const catnipMouse = new THREE.Group();
            const greenMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
            const cmBody = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), greenMat);
            cmBody.scale.set(1.4, 0.9, 1);
            catnipMouse.add(cmBody);
            const cmEar1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), greenMat);
            cmEar1.position.set(0.08, 0.1, -0.12);
            catnipMouse.add(cmEar1);
            const cmEar2 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), greenMat);
            cmEar2.position.set(-0.08, 0.1, -0.12);
            catnipMouse.add(cmEar2);
            catnipMouse.position.set(0, 0.15, 15);
            catnipMouse.castShadow = true;
            scene.add(catnipMouse);
            toys.push({ mesh: catnipMouse, type: 'mouse', radius: 0.25, velocity: new THREE.Vector3() });

            // === MAGICAL FANTASY TOYS ===

            // Glowing magic orb
            const magicOrbGroup = new THREE.Group();
            const orbMat = new THREE.MeshStandardMaterial({
                color: 0x9370DB,
                emissive: 0x9370DB,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });
            const magicOrb = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), orbMat);
            magicOrbGroup.add(magicOrb);
            // Sparkle ring around orb
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.6 });
            const sparkleRing = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.02, 8, 32), ringMat);
            magicOrbGroup.add(sparkleRing);
            magicOrbGroup.position.set(32, 0.35, 28);
            magicOrbGroup.castShadow = true;
            scene.add(magicOrbGroup);
            toys.push({ mesh: magicOrbGroup, type: 'magic_orb', radius: 0.35, velocity: new THREE.Vector3(), isMagical: true });

            // Enchanted acorn (bouncy!)
            const acornGroup = new THREE.Group();
            const acornBodyMat = new THREE.MeshStandardMaterial({ color: 0xD2691E, emissive: 0x8B4513, emissiveIntensity: 0.2 });
            const acornBody = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), acornBodyMat);
            acornBody.scale.set(1, 1.3, 1);
            acornGroup.add(acornBody);
            const acornCapMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const acornCap = new THREE.Mesh(new THREE.SphereGeometry(0.22, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), acornCapMat);
            acornCap.position.y = 0.15;
            acornGroup.add(acornCap);
            acornGroup.position.set(38, 0.25, 22);
            acornGroup.castShadow = true;
            scene.add(acornGroup);
            toys.push({ mesh: acornGroup, type: 'acorn', radius: 0.25, velocity: new THREE.Vector3(), isMagical: true, bouncy: 0.9 });

            // Fairy dust ball (sparkly, leaves trail)
            const fairyDustBall = new THREE.Group();
            const dustMat = new THREE.MeshStandardMaterial({
                color: 0xFF69B4,
                emissive: 0xFF1493,
                emissiveIntensity: 0.6
            });
            const dustCore = new THREE.Mesh(new THREE.IcosahedronGeometry(0.25, 1), dustMat);
            fairyDustBall.add(dustCore);
            // Tiny sparkles around it
            const sparkleMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 8; i++) {
                const sparkle = new THREE.Mesh(new THREE.SphereGeometry(0.03, 4, 4), sparkleMat);
                const angle = (i / 8) * Math.PI * 2;
                sparkle.position.set(Math.cos(angle) * 0.35, Math.sin(angle * 2) * 0.1, Math.sin(angle) * 0.35);
                fairyDustBall.add(sparkle);
            }
            fairyDustBall.position.set(40, 0.3, 30);
            fairyDustBall.castShadow = true;
            scene.add(fairyDustBall);
            toys.push({ mesh: fairyDustBall, type: 'fairy_dust', radius: 0.3, velocity: new THREE.Vector3(), isMagical: true });

            // Mini crystal (kitten can bat around)
            const miniCrystal = new THREE.Group();
            const crystMat = new THREE.MeshStandardMaterial({
                color: 0x00FFFF,
                emissive: 0x00CED1,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.85
            });
            const crystCore = new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), crystMat);
            crystCore.scale.y = 1.5;
            miniCrystal.add(crystCore);
            miniCrystal.position.set(44, 0.3, 26);
            miniCrystal.castShadow = true;
            scene.add(miniCrystal);
            toys.push({ mesh: miniCrystal, type: 'crystal', radius: 0.25, velocity: new THREE.Vector3(), isMagical: true });

            // Glowing mushroom (small, rollable)
            const miniMushroom = new THREE.Group();
            const mStemMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC, roughness: 0.8 });
            const mStem = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.2, 8), mStemMat);
            mStem.position.y = 0.1;
            miniMushroom.add(mStem);
            const mCapMat = new THREE.MeshStandardMaterial({
                color: 0xFF6B6B,
                emissive: 0xFF0000,
                emissiveIntensity: 0.2
            });
            const mCap = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), mCapMat);
            mCap.position.y = 0.2;
            miniMushroom.add(mCap);
            // White spots
            const spotMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 4; i++) {
                const spot = new THREE.Mesh(new THREE.CircleGeometry(0.03, 6), spotMat);
                const ang = (i / 4) * Math.PI * 2;
                spot.position.set(Math.sin(ang) * 0.12, 0.25, Math.cos(ang) * 0.12);
                spot.lookAt(0, 0.2, 0);
                miniMushroom.add(spot);
            }
            miniMushroom.position.set(30, 0.15, 20);
            miniMushroom.castShadow = true;
            scene.add(miniMushroom);
            toys.push({ mesh: miniMushroom, type: 'mushroom', radius: 0.2, velocity: new THREE.Vector3(), isMagical: true });
        }
        createToys();

        // --- FOOD/WATER LOCATIONS (in kitchen) ---
        const foodBowlPos = new THREE.Vector3(18, 0, 2);
        const waterBowlPos = new THREE.Vector3(18, 0, -2);

        // --- DAY/NIGHT CYCLE ---
        const DAY_DURATION = 300; // 5 minutes = 1 full day
        let timeOfDay = 0.35; // Start in morning (0=midnight, 0.25=dawn, 0.5=noon, 0.75=dusk)

        // Sky colors for different times
        const skyColors = {
            midnight: new THREE.Color(0x0a0a20),
            dawn: new THREE.Color(0xff9966),
            noon: new THREE.Color(0x87ceeb),
            dusk: new THREE.Color(0xff6b6b),
            night: new THREE.Color(0x1a1a3a)
        };

        // Create stars for night sky
        const starsGroup = new THREE.Group();
        scene.add(starsGroup);
        const starGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (let i = 0; i < 100; i++) {
            const star = new THREE.Mesh(starGeo, starMat);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 0.4; // Upper hemisphere
            const r = 80;
            star.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi) + 20,
                r * Math.sin(phi) * Math.sin(theta)
            );
            star.scale.setScalar(0.5 + Math.random() * 1.5);
            starsGroup.add(star);
        }
        starsGroup.visible = false;

        // Moon
        const moonGeo = new THREE.SphereGeometry(2, 16, 16);
        const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
        const moon = new THREE.Mesh(moonGeo, moonMat);
        moon.position.set(30, 40, -20);
        scene.add(moon);
        moon.visible = false;

        function updateDayNightCycle(dt) {
            // Progress time
            timeOfDay = (timeOfDay + dt / DAY_DURATION) % 1.0;

            // Determine sky color based on time
            let skyColor;
            if (timeOfDay < 0.2) {
                // Night to dawn
                const t = timeOfDay / 0.2;
                skyColor = skyColors.night.clone().lerp(skyColors.dawn, t);
            } else if (timeOfDay < 0.3) {
                // Dawn to morning
                const t = (timeOfDay - 0.2) / 0.1;
                skyColor = skyColors.dawn.clone().lerp(skyColors.noon, t);
            } else if (timeOfDay < 0.7) {
                // Day
                skyColor = skyColors.noon.clone();
            } else if (timeOfDay < 0.8) {
                // Afternoon to dusk
                const t = (timeOfDay - 0.7) / 0.1;
                skyColor = skyColors.noon.clone().lerp(skyColors.dusk, t);
            } else if (timeOfDay < 0.9) {
                // Dusk to night
                const t = (timeOfDay - 0.8) / 0.1;
                skyColor = skyColors.dusk.clone().lerp(skyColors.night, t);
            } else {
                // Night
                skyColor = skyColors.night.clone();
            }
            scene.background = skyColor;

            // Sun/moon position (sun rises in east, sets in west)
            const sunAngle = (timeOfDay - 0.25) * Math.PI * 2; // 0.25 = sunrise
            const sunHeight = Math.sin(sunAngle);
            const sunX = Math.cos(sunAngle) * 30;
            const sunY = Math.max(5, sunHeight * 30 + 10);

            dirLight.position.set(sunX, sunY, 10);

            // Light intensity based on time
            const dayBrightness = Math.max(0, Math.sin(sunAngle));
            dirLight.intensity = 0.2 + dayBrightness * 0.7;
            ambientLight.intensity = 0.3 + dayBrightness * 0.4;

            // Stars and moon visibility
            const isNight = timeOfDay < 0.22 || timeOfDay > 0.78;
            starsGroup.visible = isNight;
            moon.visible = isNight;

            // Twinkle stars
            if (isNight) {
                starsGroup.children.forEach((star, i) => {
                    star.material.opacity = 0.5 + Math.sin(clock.getElapsedTime() * 2 + i) * 0.5;
                });
            }

            // Indoor lights get brighter at night
            const nightLightBoost = isNight ? 1.5 : 0.5;
            fireLight.intensity = (0.4 + Math.sin(clock.getElapsedTime() * 8) * 0.15) * (isNight ? 2 : 1);

            // Update mood based on time of day
            // Morning = energetic, night = sleepy
            if (timeOfDay > 0.25 && timeOfDay < 0.4) {
                mood.energy = Math.min(0.9, mood.energy + dt * 0.02); // Morning boost
            } else if (timeOfDay > 0.8 || timeOfDay < 0.2) {
                mood.energy = Math.max(0.2, mood.energy - dt * 0.02); // Night sleepiness
            }
        }

        // --- MOOD SYSTEM (Non-stress, just behavioral variety) ---
        const mood = {
            energy: 0.5,      // 0 = sleepy, 1 = playful
            curiosity: 0.5,   // 0 = lazy, 1 = exploratory
            affection: 0.5    // 0 = independent, 1 = cuddly
        };

        // Mood drifts naturally over time
        function updateMood(dt) {
            const time = clock.getElapsedTime();
            // Slow sinusoidal drift with noise
            mood.energy = 0.5 + Math.sin(time * 0.02) * 0.3 + Math.sin(time * 0.07) * 0.15;
            mood.curiosity = 0.5 + Math.sin(time * 0.015 + 1) * 0.3 + Math.sin(time * 0.05 + 2) * 0.15;
            // Affection influenced by petting (decays slowly)
            mood.affection = Math.max(0.3, mood.affection - dt * 0.01);
            // Clamp all values
            mood.energy = THREE.MathUtils.clamp(mood.energy, 0.1, 0.95);
            mood.curiosity = THREE.MathUtils.clamp(mood.curiosity, 0.1, 0.95);
            mood.affection = THREE.MathUtils.clamp(mood.affection, 0.1, 0.95);
        }

        // --- AI & LOGIC ---
        let state = 'IDLE'; // IDLE, WALK, PET, SLEEP, GROOM, STRETCH, LOAF, CURIOUS
        let stateTimer = 0;
        let targetPos = new THREE.Vector3();
        let walkSpeed = 2.5;
        let turnSpeed = 3.0;
        let petTimer = 0;
        let sleepTimer = 0;
        let blinkTimer = 0;
        let nextBlinkTime = 2 + Math.random() * 4;
        let groomPhase = 0; // For groom animation stages
        let stretchPhase = 0; // For stretch animation

        // Helper function for eyelid animation (0 = open, 1 = closed)
        function setEyelids(amount) {
            leftEyelid.scale.y = amount;
            rightEyelid.scale.y = amount;
        }

        // Helper for pupil dilation (mood/light based)
        function setPupilSize(scale) {
            leftPupil.scale.set(scale, 1, 1);
            rightPupil.scale.set(scale, 1, 1);
        }

        // Animate tail segments with wave
        function animateTail(time, intensity = 1.0, speed = 2.0) {
            const segments = kittenGroup.userData.tailSegments;
            segments.forEach((seg, i) => {
                const phase = i * 0.4;
                seg.rotation.z = Math.sin(time * speed + phase) * 0.2 * intensity;
                seg.rotation.x = (i === 0 ? -0.5 : 0.15) + Math.sin(time * speed * 0.5 + phase) * 0.05 * intensity;
            });
        }

        // Whisker twitch animation
        function animateWhiskers(time, intensity = 0.02) {
            whiskers.forEach((w, i) => {
                w.rotation.y = Math.sin(time * 3 + i) * intensity;
            });
        }

        // Head tracking toward camera (subtle)
        function updateHeadTracking(dt, intensity = 0.3) {
            const camDir = camera.position.clone().sub(kittenGroup.position);
            const targetHeadRotY = Math.atan2(camDir.x, camDir.z) - kittenGroup.rotation.y;
            // Normalize angle
            let normRot = targetHeadRotY;
            while (normRot > Math.PI) normRot -= Math.PI * 2;
            while (normRot < -Math.PI) normRot += Math.PI * 2;
            // Clamp to reasonable head turn range
            normRot = THREE.MathUtils.clamp(normRot, -0.6, 0.6);
            headGroup.rotation.y = THREE.MathUtils.lerp(headGroup.rotation.y, normRot * intensity, 2 * dt);
        }

        // Special interest points for autonomous behavior
        const interestPoints = {
            food: new THREE.Vector3(16, 0, 2),      // Kitchen food bowl (kitchen at 18, bowl at -2 relative)
            water: new THREE.Vector3(16.8, 0, 2),   // Kitchen water bowl (next to food)
            bed: new THREE.Vector3(-18, 0, -3),    // Bedroom bed (bedroom at -18, bed at 0,0,-3 relative)
            couch: new THREE.Vector3(0, 0, -3),    // Living room couch
            window: new THREE.Vector3(0, 0, 6),     // Window for bird watching (in front wall)
            garden: new THREE.Vector3(5, 0, 20),   // Garden (butterflies!)
            pond: new THREE.Vector3(15, 0, 25),    // Pond (fish watching)
            fireplace: new THREE.Vector3(-5, 0, 0), // Warm spot by fireplace
            // Fantasy area interest points
            mushroomHouse: new THREE.Vector3(35, 0, 25),     // Big mushroom house
            crystals: new THREE.Vector3(43, 0, 19),          // Crystal cluster
            fairyRing: new THREE.Vector3(33, 0, 33),         // Fairy ring
            enchantedTree: new THREE.Vector3(37, 0, 17),     // Magical tree
            fairyCottage: new THREE.Vector3(29, 0, 22)       // Tiny cottage
        };

        // Find nearest toy for cat to play with
        function findNearestToy() {
            let nearest = null;
            let nearestDist = Infinity;
            const catPos = kittenGroup.position;
            toys.forEach(toy => {
                const dist = catPos.distanceTo(toy.mesh.position);
                if (dist < nearestDist && dist < 15) { // Only consider toys within 15 units
                    nearest = toy;
                    nearestDist = dist;
                }
            });
            return { toy: nearest, distance: nearestDist };
        }

        // Choose next state based on mood AND needs
        function chooseNextState() {
            const roll = Math.random();

            // AUTONOMOUS SELF-CARE: Check needs first

            // Playful and sees a toy? Chase it!
            if (mood.energy > 0.6 && Math.random() < 0.4) {
                const { toy, distance } = findNearestToy();
                if (toy && distance < 10) {
                    targetPos.copy(toy.mesh.position);
                    stateTimer = 8;
                    stats.happiness = Math.min(100, stats.happiness + 5);
                    return 'WALK';
                }
            }

            // Hungry? Go eat! (higher threshold, always go when very hungry)
            if (stats.fullness < 50) {
                const urgency = stats.fullness < 30 ? 1.0 : 0.8;
                if (Math.random() < urgency) {
                    targetPos.copy(interestPoints.food);
                    stateTimer = 20;
                    return 'WALK'; // Will eat when arrives
                }
            }

            // Tired? Go to bed! (higher threshold)
            if (stats.energy < 40) {
                const urgency = stats.energy < 25 ? 1.0 : 0.7;
                if (Math.random() < urgency) {
                    targetPos.copy(interestPoints.bed);
                    stateTimer = 20;
                    return 'WALK'; // Will sleep when arrives
                }
            }

            // Unhappy? Go somewhere fun or play!
            if (stats.happiness < 50) {
                const urgency = stats.happiness < 30 ? 0.9 : 0.6;
                if (Math.random() < urgency) {
                    const funPlaces = ['garden', 'pond', 'window', 'fireplace'];
                    const place = funPlaces[Math.floor(Math.random() * funPlaces.length)];
                    targetPos.copy(interestPoints[place]);
                    stateTimer = 20;
                    return 'WALK';
                }
            }

            // Cold? Go to fireplace or sunny spot
            if (timeOfDay > 0.7 || timeOfDay < 0.25) { // Night time
                if (Math.random() < 0.2) {
                    targetPos.copy(interestPoints.fireplace);
                    stateTimer = 10;
                    return 'WALK';
                }
            }

            // Goal-directed behavior - almost always walk to do something
            if (mood.energy < 0.3) {
                // Sleepy - might nap in place or go to bed
                if (roll < 0.3) return 'SLEEP';
                if (roll < 0.5) return 'LOAF';
                if (roll < 0.7) return 'GROOM';
                // Go somewhere cozy
                targetPos.copy(pickRandomPoint());
                stateTimer = 15;
                return 'WALK';
            } else if (mood.energy > 0.7) {
                // Playful - go play!
                if (roll < 0.1) return 'STRETCH';
                if (roll < 0.2) return 'CURIOUS';
                // Walk to a goal (toy, interesting spot)
                targetPos.copy(pickRandomPoint());
                stateTimer = 15;
                return 'WALK';
            } else {
                // Normal energy - variety of activities
                if (roll < 0.1) return 'GROOM';
                if (roll < 0.15) return 'STRETCH';
                if (roll < 0.25) return 'LOAF';
                // Walk to do something interesting
                targetPos.copy(pickRandomPoint());
                stateTimer = 15;
                return 'WALK';
            }
        }

        // Goal system - cat picks a goal and walks to it
        let currentGoal = null; // { type: 'toy'|'spot'|'explore', target: Vector3, activity: string }

        const catGoals = [
            // === Toy-related goals ===
            { type: 'toy', name: 'play_with_toy', activity: 'CURIOUS', duration: 5 },
            { type: 'toy', name: 'bat_toy_around', activity: 'CURIOUS', duration: 4, energetic: true },
            { type: 'toy', name: 'stalk_toy', activity: 'CURIOUS', duration: 6, energetic: true },

            // === Living Room goals ===
            { type: 'spot', name: 'nap_couch', target: 'couch', activity: 'LOAF', duration: 10, location: 'livingRoom' },
            { type: 'spot', name: 'warm_fireplace', target: 'fireplace', activity: 'LOAF', duration: 8, location: 'livingRoom' },
            { type: 'spot', name: 'watch_birds', target: 'window', activity: 'CURIOUS', duration: 8, location: 'livingRoom' },
            { type: 'spot', name: 'sunbathe_window', target: 'window', activity: 'LOAF', duration: 7, location: 'livingRoom' },

            // === Bedroom goals ===
            { type: 'spot', name: 'nap_bed', target: 'bed', activity: 'SLEEP', duration: 12, location: 'bedroom' },
            { type: 'spot', name: 'explore_under_bed', target: 'bed', activity: 'CURIOUS', duration: 5, location: 'bedroom' },

            // === Kitchen goals ===
            { type: 'spot', name: 'check_food_bowl', target: 'food', activity: 'CURIOUS', duration: 3, location: 'kitchen' },
            { type: 'spot', name: 'kitchen_windowsill', target: 'food', activity: 'LOAF', duration: 6, location: 'kitchen' },

            // === Outdoor - Lawn goals ===
            { type: 'spot', name: 'explore_lawn', target: 'garden', activity: 'CURIOUS', duration: 5, location: 'lawn' },
            { type: 'spot', name: 'roll_in_grass', target: 'garden', activity: 'STRETCH', duration: 4, location: 'lawn', energetic: true },
            { type: 'chase', name: 'chase_butterflies', target: 'garden', activity: 'CURIOUS', duration: 6, location: 'lawn', energetic: true },

            // === Outdoor - Garden goals ===
            { type: 'spot', name: 'sniff_flowers', target: 'garden', activity: 'CURIOUS', duration: 4, location: 'garden' },
            { type: 'spot', name: 'hide_in_grass', target: 'garden', activity: 'LOAF', duration: 6, location: 'garden' },

            // === Outdoor - Pond goals ===
            { type: 'spot', name: 'watch_fish', target: 'pond', activity: 'CURIOUS', duration: 6, location: 'pond' },
            { type: 'spot', name: 'paw_at_water', target: 'pond', activity: 'CURIOUS', duration: 4, location: 'pond', energetic: true },

            // === Self-care goals (location independent) ===
            { type: 'groom', name: 'grooming', activity: 'GROOM', duration: 4 },
            { type: 'stretch', name: 'stretching', activity: 'STRETCH', duration: 3 },
            { type: 'groom', name: 'clean_paws', activity: 'GROOM', duration: 3 },
            { type: 'stretch', name: 'big_yawn_stretch', activity: 'STRETCH', duration: 2 },

            // === Fantasy area goals ===
            { type: 'spot', name: 'explore_mushrooms', target: 'mushroomHouse', activity: 'CURIOUS', duration: 6, location: 'fantasy' },
            { type: 'spot', name: 'stare_crystals', target: 'crystals', activity: 'CURIOUS', duration: 7, location: 'fantasy' },
            { type: 'spot', name: 'visit_fairy_ring', target: 'fairyRing', activity: 'CURIOUS', duration: 5, location: 'fantasy' },
            { type: 'spot', name: 'nap_enchanted_tree', target: 'enchantedTree', activity: 'LOAF', duration: 8, location: 'fantasy' },
            { type: 'spot', name: 'peek_cottage', target: 'fairyCottage', activity: 'CURIOUS', duration: 4, location: 'fantasy' },
            { type: 'chase', name: 'chase_sparkles', target: 'fairyRing', activity: 'CURIOUS', duration: 5, location: 'fantasy', energetic: true },
            { type: 'spot', name: 'watch_floating_islands', target: 'mushroomHouse', activity: 'CURIOUS', duration: 6, location: 'fantasy' },
            { type: 'spot', name: 'bat_magic_orb', target: 'mushroomHouse', activity: 'CURIOUS', duration: 4, location: 'fantasy', energetic: true },
        ];

        function pickGoal() {
            // Priority 1: Basic needs
            if (stats.fullness < 50) {
                return { type: 'need', target: interestPoints.food.clone(), activity: 'EAT', name: 'eat_food' };
            }
            if (stats.energy < 40) {
                return { type: 'need', target: interestPoints.bed.clone(), activity: 'SLEEP', name: 'sleep_bed' };
            }

            // Priority 2: Play with nearby toy if playful
            if (mood.energy > 0.5) {
                const { toy, distance } = findNearestToy();
                if (toy && distance < 12 && Math.random() < 0.6) {
                    return { type: 'toy', target: toy.mesh.position.clone(), activity: 'CURIOUS', name: 'play_toy', toyRef: toy };
                }
            }

            // Priority 3: Prefer goals in current location (60% chance to stay local)
            const localGoals = catGoals.filter(g => g.location === currentLocation || !g.location);
            const preferLocal = Math.random() < 0.6 && localGoals.length > 0;
            const goalPool = preferLocal ? localGoals : catGoals;

            // Priority 4: Filter by energy level
            let filteredGoals;
            if (mood.energy > 0.6) {
                // High energy - prefer energetic and curious activities
                filteredGoals = goalPool.filter(g => g.energetic || g.activity === 'CURIOUS' || g.type === 'toy' || g.type === 'chase');
            } else if (mood.energy < 0.35) {
                // Low energy - prefer restful activities
                filteredGoals = goalPool.filter(g => !g.energetic && (g.activity === 'LOAF' || g.activity === 'GROOM' || g.activity === 'SLEEP'));
            } else {
                // Medium energy - anything goes
                filteredGoals = goalPool;
            }

            // Fallback to full pool if filter too restrictive
            if (filteredGoals.length === 0) filteredGoals = goalPool;
            if (filteredGoals.length === 0) filteredGoals = catGoals;

            // Pick a random goal from filtered list
            const goal = filteredGoals[Math.floor(Math.random() * filteredGoals.length)];

            // Handle different goal types
            if (goal.type === 'toy' || goal.type === 'chase') {
                const { toy } = findNearestToy();
                if (toy) return { ...goal, target: toy.mesh.position.clone(), toyRef: toy };
                // No toy - explore nearby area instead
                const fallbackTarget = interestPoints[goal.target] || interestPoints.garden;
                return { type: 'spot', target: fallbackTarget.clone(), activity: 'CURIOUS', name: 'explore' };
            }

            if (goal.target && interestPoints[goal.target]) {
                return { ...goal, target: interestPoints[goal.target].clone() };
            }

            // Self-care goals (no target location)
            return goal;
        }

        function pickRandomPoint() {
            // Use goal system instead of random points
            currentGoal = pickGoal();

            if (currentGoal.target) {
                return currentGoal.target.clone();
            }

            // Fallback: nearby random point for activities without a destination
            const bounds = locationBounds[currentLocation] || locationBounds.livingRoom;
            const x = kittenGroup.position.x + (Math.random() - 0.5) * 3;
            const z = kittenGroup.position.z + (Math.random() - 0.5) * 3;
            return new THREE.Vector3(
                THREE.MathUtils.clamp(x, bounds.minX, bounds.maxX),
                0,
                THREE.MathUtils.clamp(z, bounds.minZ, bounds.maxZ)
            );
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        let lastMouseX = 0;
        let lastMouseY = 0;

        function getFloorIntersection(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(floorPlane, target);
            return target;
        }

        function onPointerDown(event) {
            // Ignore clicks on UI panels
            if (event.target.closest('#tools-panel') || event.target.closest('#stats-panel') || event.target.closest('#instructions')) return;

            // Store previous position for camera dragging
            previousMousePosition = { x: event.clientX, y: event.clientY };

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // First check if clicking on a toy to drag it (any tool)
            const toyMeshes = toys.map(t => t.mesh);
            const toyIntersects = raycaster.intersectObjects(toyMeshes, true);
            if (toyIntersects.length > 0) {
                // Find which toy was clicked
                let clickedMesh = toyIntersects[0].object;
                while (clickedMesh.parent && !toyMeshes.includes(clickedMesh)) {
                    clickedMesh = clickedMesh.parent;
                }
                const clickedToy = toys.find(t => t.mesh === clickedMesh || clickedMesh.parent === t.mesh);
                if (clickedToy) {
                    draggedToy = clickedToy;
                    draggedToy.velocity.set(0, 0, 0);

                    // Magical toys spawn sparkles when clicked!
                    if (clickedToy.isMagical) {
                        spawnSparkleBurst(clickedToy.mesh.position.clone().add(new THREE.Vector3(0, 0.3, 0)), 15);
                    }

                    // Kitten might notice
                    if (state === 'IDLE' && Math.random() < 0.4) {
                        targetPos.copy(clickedToy.mesh.position);
                        state = 'WALK';
                        stateTimer = 10;
                    }
                    return;
                }
            }

            // Check for fantasy area clicks (creates magical effects!)
            const clickPos = getFloorIntersection(event);
            if (clickPos) {
                // Click near fairy ring center spawns big sparkle burst
                const fairyRingCenter = new THREE.Vector3(33, 0, 33); // fantasyArea (35,25) + fairyRing (-2, 8)
                if (clickPos.distanceTo(fairyRingCenter) < 4) {
                    spawnSparkleBurst(new THREE.Vector3(33, 1, 33), 25);
                    // Kitten might come investigate
                    if (state === 'IDLE' && Math.random() < 0.5) {
                        targetPos.copy(fairyRingCenter);
                        state = 'WALK';
                        stateTimer = 8;
                    }
                }

                // Click near crystals makes them flash
                const crystalCluster = new THREE.Vector3(43, 0, 19);
                if (clickPos.distanceTo(crystalCluster) < 3) {
                    spawnSparkleBurst(new THREE.Vector3(43, 1.5, 19), 20);
                }

                // Click near enchanted tree drops sparkles
                const treePos = new THREE.Vector3(37, 0, 17);
                if (clickPos.distanceTo(treePos) < 4) {
                    spawnSparkle(new THREE.Vector3(37, 5, 17), 8);
                }
            }

            if (currentTool === 'pet') {
                // Check intersection with kitten parts
                const intersects = raycaster.intersectObjects(kittenGroup.children, true);
                if (intersects.length > 0) {
                    // Pet the kitten!
                    state = 'PET';
                    petTimer = 1.5;
                    mood.affection = Math.min(0.95, mood.affection + 0.15);
                    stats.happiness = Math.min(100, stats.happiness + 10);
                    updateStatsUI();
                    for (let i = 0; i < 5; i++) spawnHeart();
                } else {
                    // Start camera drag (works when follow is off)
                    isDragging = true;
                }
            } else if (currentTool === 'laser') {
                laserActive = true;
                const pos = getFloorIntersection(event);
                if (pos) {
                    laserDot.position.set(pos.x, 0.02, pos.z);
                    laserDot.visible = true;
                    if (state !== 'SLEEP' && Math.random() < 0.7) {
                        state = 'WALK';
                        stateTimer = 8;
                        targetPos.copy(pos);
                    }
                }
            } else if (currentTool === 'treat') {
                const pos = getFloorIntersection(event);
                if (pos) {
                    stats.fullness = Math.min(100, stats.fullness + 15);
                    stats.happiness = Math.min(100, stats.happiness + 5);
                    updateStatsUI();
                    if (state === 'IDLE' || state === 'WALK') {
                        targetPos.copy(pos);
                        state = 'WALK';
                        stateTimer = 10;
                    }
                    // Spawn treat particle
                    const treat = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x8B4513 })
                    );
                    treat.position.copy(pos);
                    treat.position.y = 0.1;
                    scene.add(treat);
                    setTimeout(() => scene.remove(treat), 3000);
                }
            } else if (currentTool === 'yarn') {
                const pos = getFloorIntersection(event);
                if (pos && specialYarn) {
                    // Pick up the yarn ball and start dragging
                    specialYarn.mesh.position.set(pos.x, 0.35, pos.z);
                    specialYarn.velocity.set(0, 0, 0);
                    draggedToy = specialYarn;
                    // Kitten might notice
                    if (state !== 'SLEEP' && Math.random() < 0.6) {
                        targetPos.copy(pos);
                        state = 'WALK';
                        stateTimer = 10;
                    }
                }
            } else if (currentTool === 'catnip') {
                const pos = getFloorIntersection(event);
                if (pos) {
                    stats.energy = Math.min(100, stats.energy + 30);
                    stats.happiness = Math.min(100, stats.happiness + 20);
                    mood.energy = Math.min(0.95, mood.energy + 0.3);
                    updateStatsUI();
                    state = 'WALK';
                    stateTimer = 5;
                    // Green particles
                    for (let i = 0; i < 10; i++) {
                        const leaf = new THREE.Mesh(
                            new THREE.SphereGeometry(0.05, 4, 4),
                            new THREE.MeshBasicMaterial({ color: 0x22cc22, transparent: true })
                        );
                        leaf.position.set(pos.x + (Math.random() - 0.5), 0.5 + Math.random(), pos.z + (Math.random() - 0.5));
                        scene.add(leaf);
                        setTimeout(() => scene.remove(leaf), 2000);
                    }
                }
            }

            // Allow camera orbit dragging when not doing other actions (works in both modes)
            if (!draggedToy && !laserActive) {
                isDragging = true;
            }
        }

        function onPointerMove(event) {
            const pos = getFloorIntersection(event);

            // Validate floor intersection (can fail at extreme camera angles)
            if (!pos || isNaN(pos.x) || isNaN(pos.z) || Math.abs(pos.x) > 100 || Math.abs(pos.z) > 100) {
                return; // Invalid intersection, skip update
            }

            // Handle dragging any toy
            if (draggedToy && pos) {
                const oldPos = draggedToy.mesh.position.clone();
                // Use global world bounds for dragging
                const clampedX = THREE.MathUtils.clamp(pos.x, WORLD_BOUNDS.minX, WORLD_BOUNDS.maxX);
                const clampedZ = THREE.MathUtils.clamp(pos.z, WORLD_BOUNDS.minZ, WORLD_BOUNDS.maxZ);
                const yPos = draggedToy.type === 'yarn' ? 0.35 : (draggedToy.radius || 0.4);
                draggedToy.mesh.position.set(clampedX, yPos, clampedZ);
                // Calculate velocity for when released
                draggedToy.velocity.set(
                    (draggedToy.mesh.position.x - oldPos.x) * 15,
                    0,
                    (draggedToy.mesh.position.z - oldPos.z) * 15
                );
                // Kitten follows if interested
                if (state === 'WALK') {
                    targetPos.copy(draggedToy.mesh.position);
                    stateTimer = Math.max(stateTimer, 3);
                }
                return;
            }

            // Track mouse position for continuous updates
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            if (currentTool === 'laser' && laserActive && pos) {
                // Use global world bounds for laser
                laserDot.position.set(
                    THREE.MathUtils.clamp(pos.x, WORLD_BOUNDS.minX, WORLD_BOUNDS.maxX),
                    0.02,
                    THREE.MathUtils.clamp(pos.z, WORLD_BOUNDS.minZ, WORLD_BOUNDS.maxZ)
                );
                targetPos.copy(laserDot.position);
            } else if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                if (cameraFollowEnabled) {
                    // Orbit around cat
                    cameraAngle += deltaX * 0.01;
                } else {
                    // Free look - rotate view direction
                    freeCamLookAngle -= deltaX * 0.005;
                    freeCamPitch = THREE.MathUtils.clamp(freeCamPitch - deltaY * 0.005, -1.0, 0.5);
                }
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onPointerUp() {
            // Release dragged toy with momentum
            if (draggedToy) {
                // Toy keeps its velocity from dragging
                draggedToy = null;
            }
            isDragging = false;
            if (currentTool === 'laser') {
                laserActive = false;
                laserDot.visible = false;
            }
        }

        function onWheel(event) {
            if (cameraFollowEnabled) {
                // Zoom in/out from cat (allow zooming out further)
                cameraDistance = THREE.MathUtils.clamp(cameraDistance + event.deltaY * 0.01, 4, 60);
            } else {
                // Move free camera forward/backward in look direction
                const zoomSpeed = event.deltaY * -0.02;
                freeCamPosition.x += Math.sin(freeCamLookAngle) * zoomSpeed;
                freeCamPosition.z -= Math.cos(freeCamLookAngle) * zoomSpeed;
                freeCamPosition.y += freeCamPitch * zoomSpeed;
                // Keep camera above ground
                freeCamPosition.y = Math.max(1, freeCamPosition.y);
            }
        }

        // Touch support for mobile
        let lastPinchDistance = 0;
        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onTouchStart(event) {
            if (event.touches.length === 2) {
                lastPinchDistance = getTouchDistance(event.touches);
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                const currentDistance = getTouchDistance(event.touches);
                const delta = lastPinchDistance - currentDistance;
                if (cameraFollowEnabled) {
                    cameraDistance = THREE.MathUtils.clamp(cameraDistance + delta * 0.05, 4, 60);
                } else {
                    // Move free camera forward/backward
                    const zoomSpeed = delta * 0.02;
                    freeCamPosition.x += Math.sin(freeCamLookAngle) * zoomSpeed;
                    freeCamPosition.z -= Math.cos(freeCamLookAngle) * zoomSpeed;
                    freeCamPosition.y = Math.max(1, freeCamPosition.y + freeCamPitch * zoomSpeed);
                }
                lastPinchDistance = currentDistance;
            }
        }

        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('wheel', onWheel);
        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        // State emoji mapping
        const stateEmojis = {
            'IDLE': 'üò∫ Idle',
            'WALK': 'üö∂ Walking',
            'SLEEP': 'üò¥ Sleeping',
            'PET': 'üòª Being Pet',
            'GROOM': 'üßº Grooming',
            'LOAF': 'üçû Loafing',
            'CURIOUS': 'üëÄ Curious',
            'STRETCH': 'üôÜ Stretching'
        };

        // Location name mapping
        const locationNames = {
            'livingRoom': 'üìç Living Room',
            'bedroom': 'üìç Bedroom',
            'kitchen': 'üìç Kitchen',
            'lawn': 'üìç Lawn',
            'garden': 'üìç Garden',
            'patio': 'üìç Patio',
            'pond': 'üìç Pond'
        };

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Camera modes:
            // Follow ON: orbit camera that follows the cat around
            // Follow OFF: free camera that stays in place, can look around
            if (cameraFollowEnabled) {
                camera.position.x = Math.sin(cameraAngle) * cameraDistance + kittenGroup.position.x;
                camera.position.z = Math.cos(cameraAngle) * cameraDistance + kittenGroup.position.z;
                camera.position.y = cameraHeight;
                camera.lookAt(kittenGroup.position.x, 1, kittenGroup.position.z);
            } else {
                // Free camera mode - position stays fixed, can rotate view
                camera.position.copy(freeCamPosition);
                // Look in the direction based on freeCamLookAngle
                const lookDist = 10;
                const lookX = freeCamPosition.x + Math.sin(freeCamLookAngle) * lookDist;
                const lookZ = freeCamPosition.z - Math.cos(freeCamLookAngle) * lookDist;
                const lookY = freeCamPosition.y + freeCamPitch * lookDist;
                camera.lookAt(lookX, lookY, lookZ);
            }

            // Update UI indicators
            document.getElementById('state-indicator').textContent = stateEmojis[state] || 'üò∫ Idle';
            document.getElementById('location-indicator').textContent = locationNames[currentLocation] || 'üìç Unknown';

            // Stats decay over time (unless sleeping or doing activities that restore them)
            // Happiness decays slowly, faster if alone
            if (state !== 'PET') {
                stats.happiness = Math.max(20, stats.happiness - dt * 0.3);
            }
            // Energy decays when active, recovers when sleeping (handled in SLEEP state)
            if (state !== 'SLEEP' && state !== 'LOAF') {
                stats.energy = Math.max(20, stats.energy - dt * 0.4);
            }
            // Fullness decays slowly always
            stats.fullness = Math.max(20, stats.fullness - dt * 0.5);
            updateStatsUI();

            // Update day/night cycle
            updateDayNightCycle(dt);

            // Update mood system
            updateMood(dt);

            // Natural blinking (in all states except sleep)
            if (state !== 'SLEEP' && state !== 'LOAF') {
                blinkTimer += dt;
                if (blinkTimer >= nextBlinkTime) {
                    blinkTimer = 0;
                    nextBlinkTime = 2 + Math.random() * 4;
                }
            }

            // Whisker animation (subtle, always)
            animateWhiskers(time, 0.015);

            // Head tracking (in idle-like states)
            if (state === 'IDLE' || state === 'CURIOUS' || state === 'LOAF') {
                updateHeadTracking(dt, state === 'CURIOUS' ? 0.5 : 0.25);
            } else {
                headGroup.rotation.y = THREE.MathUtils.lerp(headGroup.rotation.y, 0, 3 * dt);
            }

            // Behavior State Machine
            if (state === 'IDLE') {
                stateTimer -= dt;

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 3) * 0.02, 1);
                chest.scale.set(0.8, 0.7 + Math.sin(time * 3) * 0.02, 0.6);

                // Tail animation with segments
                animateTail(time, 0.8, 2.0);
                tailGroup.rotation.y = Math.sin(time * 2) * 0.15;

                // Lerp back to standing pose
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 5 * dt);
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 5 * dt);
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.75, 5 * dt);

                // Eyes open with natural blinking
                const blinkAmount = (blinkTimer < 0.15) ? Math.sin(blinkTimer / 0.15 * Math.PI) : 0;
                setEyelids(blinkAmount);
                setPupilSize(1.0);

                // Subtle ear movement
                leftEar.rotation.x = -0.15 + Math.sin(time * 0.5) * 0.05;
                rightEar.rotation.x = -0.15 + Math.sin(time * 0.5 + 1) * 0.05;

                // Reset leg rotations
                legs.forEach(leg => {
                    leg.group.rotation.x = THREE.MathUtils.lerp(leg.group.rotation.x, 0, 5 * dt);
                    leg.lowerLeg.rotation.x = THREE.MathUtils.lerp(leg.lowerLeg.rotation.x, 0, 5 * dt);
                });

                if (stateTimer <= 0) {
                    const nextState = chooseNextState();
                    state = nextState;
                    if (nextState === 'SLEEP') {
                        stateTimer = 5.0 + Math.random() * 5.0;
                    } else if (nextState === 'WALK') {
                        targetPos = pickRandomPoint();
                        stateTimer = 5.0;
                    } else if (nextState === 'LOAF') {
                        stateTimer = 4.0 + Math.random() * 4.0;
                    } else if (nextState === 'GROOM') {
                        stateTimer = 3.0 + Math.random() * 3.0;
                        groomPhase = 0;
                    } else if (nextState === 'CURIOUS') {
                        stateTimer = 2.0 + Math.random() * 3.0;
                    } else {
                        stateTimer = 1.0 + Math.random() * 2.0;
                    }
                }
            }
            else if (state === 'GROOM') {
                // Grooming: licking paw, rubbing face
                stateTimer -= dt;
                groomPhase += dt;

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 3) * 0.015, 1);

                // Sit down slightly
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.2, 3 * dt);

                // Raise one front paw to face
                const pawLift = Math.sin(groomPhase * 2) * 0.5 + 0.5;
                legs[0].group.rotation.x = THREE.MathUtils.lerp(legs[0].group.rotation.x, -0.8 * pawLift, 5 * dt);
                legs[0].group.rotation.z = -0.3 * pawLift;
                legs[0].lowerLeg.rotation.x = 0.6 * pawLift;

                // Head movement - licking paw or rubbing face
                const groomCycle = Math.sin(groomPhase * 4);
                headGroup.rotation.x = groomCycle * 0.15;
                headGroup.position.z = 1.1 - pawLift * 0.15;

                // Eyes mostly closed during grooming
                setEyelids(0.5 + groomCycle * 0.2);

                // Tail relaxed
                animateTail(time, 0.3, 1.0);

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                    legs[0].group.rotation.z = 0;
                    headGroup.rotation.x = 0;
                    headGroup.position.z = 1.1;
                }
            }
            else if (state === 'LOAF') {
                // Cat loaf pose - legs tucked under body
                stateTimer -= dt;

                // Lower body
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.45, 2 * dt);

                // Tuck legs under
                legs.forEach(leg => {
                    leg.group.rotation.x = THREE.MathUtils.lerp(leg.group.rotation.x, 0.5, 3 * dt);
                    leg.lowerLeg.rotation.x = THREE.MathUtils.lerp(leg.lowerLeg.rotation.x, 1.2, 3 * dt);
                });

                // Head up, alert but relaxed
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.55, 3 * dt);

                // Slow breathing
                body.scale.set(1, 1 + Math.sin(time * 2) * 0.02, 1);

                // Relaxed tail wrapped around
                animateTail(time, 0.2, 0.8);
                tailGroup.rotation.y = THREE.MathUtils.lerp(tailGroup.rotation.y, 0.4, 2 * dt);

                // Slow blink
                const loafBlink = Math.sin(time * 0.5) > 0.8 ? 0.6 : 0;
                setEyelids(loafBlink);
                setPupilSize(0.8);

                // Ears relaxed
                leftEar.rotation.x = THREE.MathUtils.lerp(leftEar.rotation.x, 0, 2 * dt);
                rightEar.rotation.x = THREE.MathUtils.lerp(rightEar.rotation.x, 0, 2 * dt);

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                }
            }
            else if (state === 'CURIOUS') {
                // Curious state - ears perked, watching something
                stateTimer -= dt;

                // Standing pose
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 5 * dt);

                // Breathing
                body.scale.set(1, 1 + Math.sin(time * 3.5) * 0.015, 1);

                // Ears very forward and alert
                leftEar.rotation.x = -0.3;
                rightEar.rotation.x = -0.3;
                // One ear might twitch
                leftEar.rotation.z = Math.sin(time * 8) * 0.1;

                // Wide eyes, dilated pupils
                setEyelids(0);
                setPupilSize(1.4);

                // Tail tip twitching
                animateTail(time, 0.5, 1.5);
                const segments = kittenGroup.userData.tailSegments;
                if (segments.length > 0) {
                    segments[segments.length - 1].rotation.z += Math.sin(time * 12) * 0.15;
                }

                // Head slightly forward
                headGroup.position.z = THREE.MathUtils.lerp(headGroup.position.z, 1.2, 3 * dt);

                // Whiskers forward
                animateWhiskers(time, 0.03);

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                    headGroup.position.z = 1.1;
                }
            }
            else if (state === 'SLEEP') {
                stateTimer -= dt;

                // Recover energy while sleeping
                stats.energy = Math.min(100, stats.energy + dt * 3); // Recover ~3 energy per second
                mood.energy = Math.min(0.95, mood.energy + dt * 0.02);
                updateStatsUI();

                // Curl/Lower animation
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, -0.55, 2 * dt);
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0.2, 2 * dt);
                headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.45, 2 * dt);

                // Close eyes with eyelids
                setEyelids(THREE.MathUtils.lerp(leftEyelid.scale.y, 1.0, 8 * dt));

                // Slow breathing
                body.scale.set(1, 1 + Math.sin(time * 1.5) * 0.03, 1);
                chest.scale.set(0.8, 0.7 + Math.sin(time * 1.5) * 0.03, 0.6);

                // Relaxed tail - minimal movement
                animateTail(time, 0.2, 0.5);
                tailGroup.rotation.y = THREE.MathUtils.lerp(tailGroup.rotation.y, 0.1, 2 * dt);

                // Ears relaxed/back
                leftEar.rotation.x = THREE.MathUtils.lerp(leftEar.rotation.x, 0.1, 3 * dt);
                rightEar.rotation.x = THREE.MathUtils.lerp(rightEar.rotation.x, 0.1, 3 * dt);

                // Tuck legs
                legs.forEach(leg => {
                    leg.group.rotation.x = THREE.MathUtils.lerp(leg.group.rotation.x, 0.3, 2 * dt);
                    leg.lowerLeg.rotation.x = THREE.MathUtils.lerp(leg.lowerLeg.rotation.x, 0.8, 2 * dt);
                });

                // Spawn Zzz
                if (Math.random() < 0.02) spawnZzz();

                if (stateTimer <= 0) {
                    // 70% chance to stretch after sleep
                    if (Math.random() < 0.7) {
                        state = 'STRETCH';
                        stateTimer = 2.5;
                        stretchPhase = 0;
                    } else {
                        state = 'IDLE';
                        stateTimer = 1.0;
                    }
                }
            }
            else if (state === 'STRETCH') {
                // Big stretch after waking up
                stateTimer -= dt;
                stretchPhase += dt;

                // Rise up
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 3 * dt);
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 4 * dt);

                if (stretchPhase < 1.2) {
                    // Front stretch - butt up, front down (add to base rotation)
                    body.rotation.x = THREE.MathUtils.lerp(body.rotation.x, Math.PI / 2 + 0.3, 4 * dt);

                    // Front legs extended forward
                    legs[0].group.rotation.x = THREE.MathUtils.lerp(legs[0].group.rotation.x, 0.4, 4 * dt);
                    legs[1].group.rotation.x = THREE.MathUtils.lerp(legs[1].group.rotation.x, 0.4, 4 * dt);
                    legs[0].lowerLeg.rotation.x = 0;
                    legs[1].lowerLeg.rotation.x = 0;

                    // Back legs straight
                    legs[2].group.rotation.x = THREE.MathUtils.lerp(legs[2].group.rotation.x, -0.2, 4 * dt);
                    legs[3].group.rotation.x = THREE.MathUtils.lerp(legs[3].group.rotation.x, -0.2, 4 * dt);

                    // Head down
                    headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.4, 3 * dt);

                    // Tail up high
                    tailGroup.rotation.x = THREE.MathUtils.lerp(tailGroup.rotation.x || 0, -0.5, 3 * dt);
                } else {
                    // Return to standing (restore base rotation)
                    body.rotation.x = THREE.MathUtils.lerp(body.rotation.x, Math.PI / 2, 4 * dt);
                    legs.forEach(leg => {
                        leg.group.rotation.x = THREE.MathUtils.lerp(leg.group.rotation.x, 0, 4 * dt);
                        leg.lowerLeg.rotation.x = THREE.MathUtils.lerp(leg.lowerLeg.rotation.x, 0, 4 * dt);
                    });
                    headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 1.75, 3 * dt);
                    tailGroup.rotation.x = THREE.MathUtils.lerp(tailGroup.rotation.x || 0, 0, 3 * dt);
                }

                // Open eyes slowly
                setEyelids(Math.max(0, 1 - stretchPhase * 0.8));

                // Yawn-like mouth (subtle head tilt)
                if (stretchPhase > 0.5 && stretchPhase < 1.0) {
                    headGroup.rotation.x = Math.sin((stretchPhase - 0.5) * Math.PI * 2) * 0.2;
                } else {
                    headGroup.rotation.x = THREE.MathUtils.lerp(headGroup.rotation.x, 0, 4 * dt);
                }

                if (stateTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.5;
                    body.rotation.x = Math.PI / 2; // Restore horizontal orientation
                    tailGroup.rotation.x = 0;
                }
            }
            else if (state === 'WALK') {
                const currentPos = kittenGroup.position.clone();
                const direction = targetPos.clone().sub(currentPos);
                const dist = direction.length();
                const moveDistance = walkSpeed * dt;

                // Arrived if close enough OR if we would overshoot this frame
                if (dist < 0.5 || dist < moveDistance) {
                    // Arrived at destination! Do the goal activity
                    const nearFood = currentPos.distanceTo(interestPoints.food) < 1.5;
                    const nearWater = currentPos.distanceTo(interestPoints.water) < 1.5;
                    const nearBed = currentPos.distanceTo(interestPoints.bed) < 2;

                    if (nearFood && stats.fullness < 90) {
                        // Eat until full!
                        stats.fullness = 100;
                        stats.happiness = Math.min(100, stats.happiness + 15);
                        updateStatsUI();
                        state = 'IDLE';
                        stateTimer = 3.0;
                        currentGoal = null;
                    } else if (nearWater) {
                        stats.fullness = Math.min(100, stats.fullness + 20);
                        stats.happiness = Math.min(100, stats.happiness + 5);
                        updateStatsUI();
                        state = 'IDLE';
                        stateTimer = 2.0;
                        currentGoal = null;
                    } else if (nearBed && stats.energy < 70) {
                        state = 'SLEEP';
                        stateTimer = 10.0 + Math.random() * 8.0;
                        currentGoal = null;
                    } else if (currentGoal) {
                        // Use goal system for activity
                        const goalActivity = currentGoal.activity || 'IDLE';
                        const goalDuration = currentGoal.duration || 3;

                        if (currentGoal.type === 'toy' && currentGoal.toyRef) {
                            // Play with the toy! Push it around
                            const pushDir = currentGoal.toyRef.mesh.position.clone().sub(currentPos).normalize();
                            currentGoal.toyRef.velocity.add(pushDir.multiplyScalar(3));
                            stats.happiness = Math.min(100, stats.happiness + 8);
                        }

                        state = goalActivity;
                        stateTimer = goalDuration + Math.random() * 3;
                        stats.happiness = Math.min(100, stats.happiness + 5);
                        updateStatsUI();
                        currentGoal = null;
                    } else {
                        state = 'IDLE';
                        stateTimer = 1.0 + Math.random() * 2.0;
                    }
                } else {
                    direction.normalize();

                    // Rotate towards target
                    const targetRotation = Math.atan2(direction.x, direction.z);
                    let rotDiff = targetRotation - kittenGroup.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    kittenGroup.rotation.y += rotDiff * turnSpeed * dt;

                    // Move forward (but don't overshoot)
                    const actualMove = Math.min(dist, walkSpeed * dt);
                    kittenGroup.position.add(direction.multiplyScalar(actualMove));

                    // Walk Animation with detailed leg joints
                    const legAmp = 0.35;
                    const legFreq = 10;
                    legs[0].group.rotation.x = Math.sin(time * legFreq) * legAmp;
                    legs[0].lowerLeg.rotation.x = Math.max(0, Math.sin(time * legFreq + 0.5)) * 0.3;
                    legs[1].group.rotation.x = Math.cos(time * legFreq) * legAmp;
                    legs[1].lowerLeg.rotation.x = Math.max(0, Math.cos(time * legFreq + 0.5)) * 0.3;
                    legs[2].group.rotation.x = Math.cos(time * legFreq) * legAmp;
                    legs[2].lowerLeg.rotation.x = Math.max(0, Math.cos(time * legFreq + 0.5)) * 0.3;
                    legs[3].group.rotation.x = Math.sin(time * legFreq) * legAmp;
                    legs[3].lowerLeg.rotation.x = Math.max(0, Math.sin(time * legFreq + 0.5)) * 0.3;

                    // Bob head
                    headGroup.position.y = 1.75 + Math.sin(time * legFreq * 2) * 0.04;

                    // Alert ears while walking
                    leftEar.rotation.x = -0.2;
                    rightEar.rotation.x = -0.2;

                    // Tail up and wagging while walking
                    animateTail(time, 1.2, 3.0);
                    tailGroup.rotation.y = Math.sin(time * 3) * 0.25;

                    // Eyes open
                    setEyelids(0);
                    setPupilSize(0.9);

                    stateTimer -= dt;
                    if (stateTimer <= 0) {
                        state = 'IDLE';
                        stateTimer = 1.0;
                    }
                }
            }
            else if (state === 'PET') {
                petTimer -= dt;

                // Wake up pose quickly
                kittenGroup.rotation.z = THREE.MathUtils.lerp(kittenGroup.rotation.z, 0, 5 * dt);
                kittenGroup.position.y = THREE.MathUtils.lerp(kittenGroup.position.y, 0, 5 * dt);

                // Happy purr vibration
                const purrOffset = Math.sin(time * 50) * 0.015;
                kittenGroup.position.y = Math.max(0, kittenGroup.position.y + purrOffset);

                // Happy closed eyes (squint)
                setEyelids(0.7);

                // Happy tail - fast wagging
                animateTail(time, 1.5, 8.0);
                tailGroup.rotation.y = Math.sin(time * 10) * 0.4;
                tailGroup.rotation.z = Math.sin(time * 15) * 0.3;

                // Ears forward (happy)
                leftEar.rotation.x = -0.25;
                rightEar.rotation.x = -0.25;

                // Dilated pupils (happy)
                setPupilSize(1.3);

                // Spawn occasional hearts
                if (Math.random() < 0.05) spawnHeart();

                if (petTimer <= 0) {
                    state = 'IDLE';
                    stateTimer = 1.0;
                    kittenGroup.position.y = 0;
                    setEyelids(0);
                }
            }

            // Update Hearts
            for (let i = hearts.length - 1; i >= 0; i--) {
                const h = hearts[i];
                h.life -= dt;
                h.mesh.position.y += h.speedY * dt;
                h.mesh.material.opacity = h.life;
                h.mesh.material.transparent = true;

                if (h.life <= 0) {
                    scene.remove(h.mesh);
                    hearts.splice(i, 1);
                }
            }

            // Update Sparkles
            for (let i = sparkles.length - 1; i >= 0; i--) {
                const s = sparkles[i];
                s.life -= dt;
                s.mesh.position.add(s.velocity.clone().multiplyScalar(dt));
                s.velocity.y -= dt * 3; // Gravity
                s.mesh.rotation.x += s.rotSpeed * dt;
                s.mesh.rotation.y += s.rotSpeed * dt;
                s.mesh.material.opacity = Math.min(1, s.life);
                s.mesh.scale.multiplyScalar(0.99); // Shrink slowly

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    sparkles.splice(i, 1);
                }
            }

            // Update Zzzs
            for (let i = zzzs.length - 1; i >= 0; i--) {
                const z = zzzs[i];
                z.life -= dt;
                z.mesh.position.y += z.speedY * dt;
                z.mesh.position.x += Math.sin(time * 2 + z.swayOffset) * 0.01;
                z.mesh.material.opacity = Math.min(z.life, 0.8);

                if (z.life <= 0) {
                    scene.remove(z.mesh);
                    zzzs.splice(i, 1);
                }
            }

            // Constrain to floor
            if(kittenGroup.position.y < 0) kittenGroup.position.y = 0;

            // Toy Physics & Interaction
            const kittenPos = kittenGroup.position.clone();
            toys.forEach(toy => {
                // Simple friction
                toy.velocity.multiplyScalar(0.92);
                toy.mesh.position.add(toy.velocity.clone().multiplyScalar(dt));

                // Rotation for balls
                if (toy.type === 'ball') {
                    toy.mesh.rotation.x += toy.velocity.z * dt * 2;
                    toy.mesh.rotation.z -= toy.velocity.x * dt * 2;
                }

                // Collision with kitten
                const dist = kittenPos.distanceTo(toy.mesh.position);
                if (dist < 1.0) { // Kitten radius approx 0.7 + toy radius
                    const pushDir = toy.mesh.position.clone().sub(kittenPos).normalize();
                    toy.velocity.add(pushDir.multiplyScalar(5.0 * dt)); // Push toy

                    // If kitten is walking, maybe it pushes harder?
                    if (state === 'WALK') {
                         toy.velocity.add(pushDir.multiplyScalar(2.0 * dt));
                    }

                    // Magical toys spawn sparkles when kitten plays with them!
                    if (toy.isMagical && Math.random() < 0.05) {
                        spawnSparkle(toy.mesh.position.clone().add(new THREE.Vector3(0, 0.2, 0)), 3);
                    }
                }

                // Bounds check (use global world bounds)
                if (toy.mesh.position.x > WORLD_BOUNDS.maxX) { toy.mesh.position.x = WORLD_BOUNDS.maxX; toy.velocity.x *= -0.8; }
                if (toy.mesh.position.x < WORLD_BOUNDS.minX) { toy.mesh.position.x = WORLD_BOUNDS.minX; toy.velocity.x *= -0.8; }
                if (toy.mesh.position.z > WORLD_BOUNDS.maxZ) { toy.mesh.position.z = WORLD_BOUNDS.maxZ; toy.velocity.z *= -0.8; }
                if (toy.mesh.position.z < WORLD_BOUNDS.minZ) { toy.mesh.position.z = WORLD_BOUNDS.minZ; toy.velocity.z *= -0.8; }

                // Special animations for magical toys
                if (toy.isMagical) {
                    // Rotate magical toys slowly
                    toy.mesh.rotation.y += dt * 0.5;

                    // Pulse glow on magic orb
                    if (toy.type === 'magic_orb') {
                        const ring = toy.mesh.children[1];
                        if (ring) {
                            ring.rotation.x += dt * 2;
                            ring.rotation.z += dt;
                        }
                        toy.mesh.position.y = 0.35 + Math.sin(time * 2) * 0.05;
                    }

                    // Fairy dust sparkles rotate
                    if (toy.type === 'fairy_dust') {
                        toy.mesh.children.forEach((child, idx) => {
                            if (idx > 0) { // Skip core
                                child.position.y = Math.sin(time * 3 + idx) * 0.15;
                            }
                        });
                    }

                    // Crystal spins and bobs
                    if (toy.type === 'crystal') {
                        toy.mesh.rotation.y += dt * 1.5;
                        toy.mesh.position.y = 0.3 + Math.sin(time * 2.5) * 0.03;
                    }

                    // Bouncy acorns
                    if (toy.bouncy && toy.velocity.length() > 0.1) {
                        toy.mesh.position.y = 0.25 + Math.abs(Math.sin(time * 8)) * 0.1 * toy.velocity.length();
                    }
                }
            });

            // Animate fireplace flames
            fireParticles.forEach((f, i) => {
                f.mesh.scale.y = 0.8 + Math.sin(time * 5 + f.offset) * 0.4;
                f.mesh.position.y = 0.5 + Math.sin(time * 4 + f.offset) * 0.15;
                f.mesh.rotation.z = Math.sin(time * 3 + f.offset) * 0.2;
            });
            // Flicker fire light
            fireLight.intensity = 0.4 + Math.sin(time * 8) * 0.15 + Math.sin(time * 13) * 0.1;

            // Animate fish swimming in pond
            const fishTime = time * 0.5;
            fishGroup.position.x = Math.sin(fishTime) * 2;
            fishGroup.position.z = Math.cos(fishTime * 0.7) * 2;
            fishGroup.rotation.y = Math.atan2(Math.cos(fishTime), -Math.sin(fishTime * 0.7) * 0.7);

            // Gently bob lily pads
            lilyPads.forEach((pad, i) => {
                pad.position.y = 0.08 + Math.sin(time * 1.5 + i) * 0.01;
            });

            // === FANTASY AREA ANIMATIONS ===
            // Pulse crystal glow
            fantasyElements.crystals.forEach((crystal, i) => {
                if (crystal.userData.glow) {
                    crystal.userData.glow.intensity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                }
            });

            // Pulse fairy flower glow
            fantasyElements.fairyFlowers.forEach((f) => {
                const intensity = 0.3 + Math.sin(time * 3 + f.phase) * 0.3;
                f.bloom.material.emissiveIntensity = intensity;
            });

            // Sway hanging orbs
            fantasyElements.hangingOrbs.forEach((orb) => {
                orb.mesh.position.y = orb.baseY + Math.sin(time * 1.5 + orb.phase) * 0.1;
                orb.mesh.position.x += Math.sin(time * 0.8 + orb.phase) * 0.002;
            });

            // Pulse stepping stones when nearby
            fantasyElements.steppingStones.forEach((stone) => {
                const dist = kittenGroup.position.distanceTo(stone.mesh.position);
                const baseIntensity = dist < 3 ? 0.4 : 0.1;
                stone.mesh.material.emissiveIntensity = baseIntensity + Math.sin(time * 2 + stone.phase) * 0.1;
            });

            // Gently bob floating islands
            fantasyElements.floatingIslands.forEach((island) => {
                island.position.y = island.userData.baseY + Math.sin(time * 0.5 + island.userData.phase) * 0.2;
            });

            // Pulse fairy ring light
            fantasyElements.fairyLight.intensity = 0.7 + Math.sin(time * 2) * 0.3;

            // Update all ambient creatures
            updateCreatures(dt, time);

            // Update current location based on kitten position
            const kx = kittenGroup.position.x;
            const kz = kittenGroup.position.z;
            // Check from most specific to least specific
            // Fantasy area check: must be east of x=20 (no overlap with garden/patio)
            if (kx >= 20 && kz >= 10) {
                currentLocation = 'fantasy';
            } else if (kz > 28) {
                // Far north areas
                if (kx < -4) currentLocation = 'pond';
                else if (kx > 6) currentLocation = 'patio';
                else currentLocation = 'garden';
            } else if (kz > 8) {
                // Lawn area (north of houses)
                currentLocation = 'lawn';
            } else if (kx < -10) {
                // Bedroom (west house)
                currentLocation = 'bedroom';
            } else if (kx > 10) {
                // Kitchen (east house)
                currentLocation = 'kitchen';
            } else {
                // Center house
                currentLocation = 'livingRoom';
            }

            // Fade walls based on camera and kitten proximity (aggressive fading)
            fadingWalls.forEach(wall => {
                const wallPos = wall.position;
                const camDist = camera.position.distanceTo(wallPos);
                const kittenDist = kittenGroup.position.distanceTo(new THREE.Vector3(wallPos.x, 0, wallPos.z));

                // Check if wall is between camera and kitten (more sensitive)
                const camToKitten = kittenGroup.position.clone().sub(camera.position).normalize();
                const camToWall = wallPos.clone().sub(camera.position).normalize();
                const isBetween = camToKitten.dot(camToWall) > 0.15; // More sensitive

                // Calculate target opacity - more aggressive fading
                let targetOpacity = 1.0;
                if (camDist < 15) targetOpacity = Math.min(targetOpacity, camDist / 15); // Farther fade distance
                if (kittenDist < 8) targetOpacity = Math.min(targetOpacity, kittenDist / 8); // Farther from kitten
                if (isBetween && camDist < 25) targetOpacity = Math.min(targetOpacity, 0.05); // Nearly invisible when blocking view

                // Faster smooth transition
                wall.material.opacity = THREE.MathUtils.lerp(wall.material.opacity, targetOpacity, 0.15);
            });

            // Camera is handled at the start of animate() based on cameraFollowEnabled

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
